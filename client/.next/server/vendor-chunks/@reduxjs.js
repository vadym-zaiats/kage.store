"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reduxjs";
exports.ids = ["vendor-chunks/@reduxjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiProvider: () => (/* binding */ ApiProvider),\n/* harmony export */   QueryStatus: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.QueryStatus),\n/* harmony export */   buildCreateApi: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.buildCreateApi),\n/* harmony export */   copyWithStructuralSharing: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.copyWithStructuralSharing),\n/* harmony export */   coreModule: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.coreModule),\n/* harmony export */   coreModuleName: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.coreModuleName),\n/* harmony export */   createApi: () => (/* binding */ createApi),\n/* harmony export */   defaultSerializeQueryArgs: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.defaultSerializeQueryArgs),\n/* harmony export */   fakeBaseQuery: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.fakeBaseQuery),\n/* harmony export */   fetchBaseQuery: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.fetchBaseQuery),\n/* harmony export */   reactHooksModule: () => (/* binding */ reactHooksModule),\n/* harmony export */   reactHooksModuleName: () => (/* binding */ reactHooksModuleName),\n/* harmony export */   retry: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.retry),\n/* harmony export */   setupListeners: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.setupListeners),\n/* harmony export */   skipToken: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.skipToken)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @reduxjs/toolkit/query */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-redux */ \"(ssr)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n// src/query/react/index.ts\n\n// src/query/react/module.ts\n\n// src/query/react/buildHooks.ts\n\n\n\n\n\n\n// src/query/react/useSerializedStableValue.ts\n\nfunction useStableQueryArgs(queryArgs, serialize, endpointDefinition, endpointName) {\n    const incoming = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            queryArgs,\n            serialized: typeof queryArgs == \"object\" ? serialize({\n                queryArgs,\n                endpointDefinition,\n                endpointName\n            }) : queryArgs\n        }), [\n        queryArgs,\n        serialize,\n        endpointDefinition,\n        endpointName\n    ]);\n    const cache2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(incoming);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (cache2.current.serialized !== incoming.serialized) {\n            cache2.current = incoming;\n        }\n    }, [\n        incoming\n    ]);\n    return cache2.current.serialized === incoming.serialized ? cache2.current.queryArgs : queryArgs;\n}\n// src/query/react/constants.ts\nvar UNINITIALIZED_VALUE = Symbol();\n// src/query/react/useShallowStableValue.ts\n\n\nfunction useShallowStableValue(value) {\n    const cache2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!(0,react_redux__WEBPACK_IMPORTED_MODULE_1__.shallowEqual)(cache2.current, value)) {\n            cache2.current = value;\n        }\n    }, [\n        value\n    ]);\n    return (0,react_redux__WEBPACK_IMPORTED_MODULE_1__.shallowEqual)(cache2.current, value) ? cache2.current : value;\n}\n// src/query/core/rtkImports.ts\n\n// src/query/defaultSerializeQueryArgs.ts\nvar cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;\nvar defaultSerializeQueryArgs = ({ endpointName, queryArgs })=>{\n    let serialized = \"\";\n    const cached = cache?.get(queryArgs);\n    if (typeof cached === \"string\") {\n        serialized = cached;\n    } else {\n        const stringified = JSON.stringify(queryArgs, (key, value)=>(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(value) ? Object.keys(value).sort().reduce((acc, key2)=>{\n                acc[key2] = value[key2];\n                return acc;\n            }, {}) : value);\n        if ((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(queryArgs)) {\n            cache?.set(queryArgs, stringified);\n        }\n        serialized = stringified;\n    }\n    return `${endpointName}(${serialized})`;\n};\n// src/query/react/buildHooks.ts\nvar useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar noPendingQueryStateSelector = (selected)=>{\n    if (selected.isUninitialized) {\n        return {\n            ...selected,\n            isUninitialized: false,\n            isFetching: true,\n            isLoading: selected.data !== void 0 ? false : true,\n            status: _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.QueryStatus.pending\n        };\n    }\n    return selected;\n};\nfunction buildHooks({ api, moduleOptions: { batch, hooks: { useDispatch, useSelector, useStore }, unstable__sideEffectsInRender }, serializeQueryArgs, context }) {\n    const usePossiblyImmediateEffect = unstable__sideEffectsInRender ? (cb)=>cb() : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n    return {\n        buildQueryHooks,\n        buildMutationHook,\n        usePrefetch\n    };\n    function queryStatePreSelector(currentState, lastResult, queryArgs) {\n        if (lastResult?.endpointName && currentState.isUninitialized) {\n            const { endpointName } = lastResult;\n            const endpointDefinition = context.endpointDefinitions[endpointName];\n            if (serializeQueryArgs({\n                queryArgs: lastResult.originalArgs,\n                endpointDefinition,\n                endpointName\n            }) === serializeQueryArgs({\n                queryArgs,\n                endpointDefinition,\n                endpointName\n            })) lastResult = void 0;\n        }\n        let data = currentState.isSuccess ? currentState.data : lastResult?.data;\n        if (data === void 0) data = currentState.data;\n        const hasData = data !== void 0;\n        const isFetching = currentState.isLoading;\n        const isLoading = !hasData && isFetching;\n        const isSuccess = currentState.isSuccess || isFetching && hasData;\n        return {\n            ...currentState,\n            data,\n            currentData: currentState.data,\n            isFetching,\n            isLoading,\n            isSuccess\n        };\n    }\n    function usePrefetch(endpointName, defaultOptions) {\n        const dispatch = useDispatch();\n        const stableDefaultOptions = useShallowStableValue(defaultOptions);\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((arg, options)=>dispatch(api.util.prefetch(endpointName, arg, {\n                ...stableDefaultOptions,\n                ...options\n            })), [\n            endpointName,\n            dispatch,\n            stableDefaultOptions\n        ]);\n    }\n    function buildQueryHooks(name) {\n        const useQuerySubscription = (arg, { refetchOnReconnect, refetchOnFocus, refetchOnMountOrArgChange, skip = false, pollingInterval = 0 } = {})=>{\n            const { initiate } = api.endpoints[name];\n            const dispatch = useDispatch();\n            const subscriptionSelectorsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n            if (!subscriptionSelectorsRef.current) {\n                const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());\n                if (true) {\n                    if (typeof returnedValue !== \"object\" || typeof returnedValue?.type === \"string\") {\n                        throw new Error( false ? 0 : `Warning: Middleware for RTK-Query API at reducerPath \"${api.reducerPath}\" has not been added to the store.\n    You must add the middleware for RTK-Query to function correctly!`);\n                    }\n                }\n                subscriptionSelectorsRef.current = returnedValue;\n            }\n            const stableArg = useStableQueryArgs(skip ? _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.skipToken : arg, // Even if the user provided a per-endpoint `serializeQueryArgs` with\n            // a consistent return value, _here_ we want to use the default behavior\n            // so we can tell if _anything_ actually changed. Otherwise, we can end up\n            // with a case where the query args did change but the serialization doesn't,\n            // and then we never try to initiate a refetch.\n            defaultSerializeQueryArgs, context.endpointDefinitions[name], name);\n            const stableSubscriptionOptions = useShallowStableValue({\n                refetchOnReconnect,\n                refetchOnFocus,\n                pollingInterval\n            });\n            const lastRenderHadSubscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n            const promiseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n            let { queryCacheKey, requestId } = promiseRef.current || {};\n            let currentRenderHasSubscription = false;\n            if (queryCacheKey && requestId) {\n                currentRenderHasSubscription = subscriptionSelectorsRef.current.isRequestSubscribed(queryCacheKey, requestId);\n            }\n            const subscriptionRemoved = !currentRenderHasSubscription && lastRenderHadSubscription.current;\n            usePossiblyImmediateEffect(()=>{\n                lastRenderHadSubscription.current = currentRenderHasSubscription;\n            });\n            usePossiblyImmediateEffect(()=>{\n                if (subscriptionRemoved) {\n                    promiseRef.current = void 0;\n                }\n            }, [\n                subscriptionRemoved\n            ]);\n            usePossiblyImmediateEffect(()=>{\n                const lastPromise = promiseRef.current;\n                if (typeof process !== \"undefined\" && \"development\" === \"removeMeOnCompilation\") {}\n                if (stableArg === _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.skipToken) {\n                    lastPromise?.unsubscribe();\n                    promiseRef.current = void 0;\n                    return;\n                }\n                const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;\n                if (!lastPromise || lastPromise.arg !== stableArg) {\n                    lastPromise?.unsubscribe();\n                    const promise = dispatch(initiate(stableArg, {\n                        subscriptionOptions: stableSubscriptionOptions,\n                        forceRefetch: refetchOnMountOrArgChange\n                    }));\n                    promiseRef.current = promise;\n                } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {\n                    lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);\n                }\n            }, [\n                dispatch,\n                initiate,\n                refetchOnMountOrArgChange,\n                stableArg,\n                stableSubscriptionOptions,\n                subscriptionRemoved\n            ]);\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n                return ()=>{\n                    promiseRef.current?.unsubscribe();\n                    promiseRef.current = void 0;\n                };\n            }, []);\n            return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                    /**\n         * A method to manually refetch data for the query\n         */ refetch: ()=>{\n                        if (!promiseRef.current) throw new Error( false ? 0 : \"Cannot refetch a query that has not been started yet.\");\n                        return promiseRef.current?.refetch();\n                    }\n                }), []);\n        };\n        const useLazyQuerySubscription = ({ refetchOnReconnect, refetchOnFocus, pollingInterval = 0 } = {})=>{\n            const { initiate } = api.endpoints[name];\n            const dispatch = useDispatch();\n            const [arg, setArg] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(UNINITIALIZED_VALUE);\n            const promiseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n            const stableSubscriptionOptions = useShallowStableValue({\n                refetchOnReconnect,\n                refetchOnFocus,\n                pollingInterval\n            });\n            usePossiblyImmediateEffect(()=>{\n                const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;\n                if (stableSubscriptionOptions !== lastSubscriptionOptions) {\n                    promiseRef.current?.updateSubscriptionOptions(stableSubscriptionOptions);\n                }\n            }, [\n                stableSubscriptionOptions\n            ]);\n            const subscriptionOptionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(stableSubscriptionOptions);\n            usePossiblyImmediateEffect(()=>{\n                subscriptionOptionsRef.current = stableSubscriptionOptions;\n            }, [\n                stableSubscriptionOptions\n            ]);\n            const trigger = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(arg2, preferCacheValue = false) {\n                let promise;\n                batch(()=>{\n                    promiseRef.current?.unsubscribe();\n                    promiseRef.current = promise = dispatch(initiate(arg2, {\n                        subscriptionOptions: subscriptionOptionsRef.current,\n                        forceRefetch: !preferCacheValue\n                    }));\n                    setArg(arg2);\n                });\n                return promise;\n            }, [\n                dispatch,\n                initiate\n            ]);\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n                return ()=>{\n                    promiseRef?.current?.unsubscribe();\n                };\n            }, []);\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n                if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {\n                    trigger(arg, true);\n                }\n            }, [\n                arg,\n                trigger\n            ]);\n            return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n                    trigger,\n                    arg\n                ], [\n                trigger,\n                arg\n            ]);\n        };\n        const useQueryState = (arg, { skip = false, selectFromResult } = {})=>{\n            const { select } = api.endpoints[name];\n            const stableArg = useStableQueryArgs(skip ? _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.skipToken : arg, serializeQueryArgs, context.endpointDefinitions[name], name);\n            const lastValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n            const selectDefaultResult = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__.createSelector)([\n                    select(stableArg),\n                    (_, lastResult)=>lastResult,\n                    (_)=>stableArg\n                ], queryStatePreSelector), [\n                select,\n                stableArg\n            ]);\n            const querySelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>selectFromResult ? (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__.createSelector)([\n                    selectDefaultResult\n                ], selectFromResult, {\n                    devModeChecks: {\n                        identityFunctionCheck: \"never\"\n                    }\n                }) : selectDefaultResult, [\n                selectDefaultResult,\n                selectFromResult\n            ]);\n            const currentState = useSelector((state)=>querySelector(state, lastValue.current), react_redux__WEBPACK_IMPORTED_MODULE_1__.shallowEqual);\n            const store = useStore();\n            const newLastValue = selectDefaultResult(store.getState(), lastValue.current);\n            useIsomorphicLayoutEffect(()=>{\n                lastValue.current = newLastValue;\n            }, [\n                newLastValue\n            ]);\n            return currentState;\n        };\n        return {\n            useQueryState,\n            useQuerySubscription,\n            useLazyQuerySubscription,\n            useLazyQuery (options) {\n                const [trigger, arg] = useLazyQuerySubscription(options);\n                const queryStateResults = useQueryState(arg, {\n                    ...options,\n                    skip: arg === UNINITIALIZED_VALUE\n                });\n                const info = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                        lastArg: arg\n                    }), [\n                    arg\n                ]);\n                return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n                        trigger,\n                        queryStateResults,\n                        info\n                    ], [\n                    trigger,\n                    queryStateResults,\n                    info\n                ]);\n            },\n            useQuery (arg, options) {\n                const querySubscriptionResults = useQuerySubscription(arg, options);\n                const queryStateResults = useQueryState(arg, {\n                    selectFromResult: arg === _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.skipToken || options?.skip ? void 0 : noPendingQueryStateSelector,\n                    ...options\n                });\n                const { data, status, isLoading, isSuccess, isError, error } = queryStateResults;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)({\n                    data,\n                    status,\n                    isLoading,\n                    isSuccess,\n                    isError,\n                    error\n                });\n                return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                        ...queryStateResults,\n                        ...querySubscriptionResults\n                    }), [\n                    queryStateResults,\n                    querySubscriptionResults\n                ]);\n            }\n        };\n    }\n    function buildMutationHook(name) {\n        return ({ selectFromResult, fixedCacheKey } = {})=>{\n            const { select, initiate } = api.endpoints[name];\n            const dispatch = useDispatch();\n            const [promise, setPromise] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>()=>{\n                    if (!promise?.arg.fixedCacheKey) {\n                        promise?.reset();\n                    }\n                }, [\n                promise\n            ]);\n            const triggerMutation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(arg) {\n                const promise2 = dispatch(initiate(arg, {\n                    fixedCacheKey\n                }));\n                setPromise(promise2);\n                return promise2;\n            }, [\n                dispatch,\n                initiate,\n                fixedCacheKey\n            ]);\n            const { requestId } = promise || {};\n            const selectDefaultResult = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>select({\n                    fixedCacheKey,\n                    requestId: promise?.requestId\n                }), [\n                fixedCacheKey,\n                promise,\n                select\n            ]);\n            const mutationSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>selectFromResult ? (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__.createSelector)([\n                    selectDefaultResult\n                ], selectFromResult) : selectDefaultResult, [\n                selectFromResult,\n                selectDefaultResult\n            ]);\n            const currentState = useSelector(mutationSelector, react_redux__WEBPACK_IMPORTED_MODULE_1__.shallowEqual);\n            const originalArgs = fixedCacheKey == null ? promise?.arg.originalArgs : void 0;\n            const reset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n                batch(()=>{\n                    if (promise) {\n                        setPromise(void 0);\n                    }\n                    if (fixedCacheKey) {\n                        dispatch(api.internalActions.removeMutationResult({\n                            requestId,\n                            fixedCacheKey\n                        }));\n                    }\n                });\n            }, [\n                dispatch,\n                fixedCacheKey,\n                promise,\n                requestId\n            ]);\n            const { endpointName, data, status, isLoading, isSuccess, isError, error } = currentState;\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)({\n                endpointName,\n                data,\n                status,\n                isLoading,\n                isSuccess,\n                isError,\n                error\n            });\n            const finalState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                    ...currentState,\n                    originalArgs,\n                    reset\n                }), [\n                currentState,\n                originalArgs,\n                reset\n            ]);\n            return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n                    triggerMutation,\n                    finalState\n                ], [\n                triggerMutation,\n                finalState\n            ]);\n        };\n    }\n}\n// src/query/endpointDefinitions.ts\nfunction isQueryDefinition(e) {\n    return e.type === \"query\" /* query */ ;\n}\nfunction isMutationDefinition(e) {\n    return e.type === \"mutation\" /* mutation */ ;\n}\n// src/query/utils/capitalize.ts\nfunction capitalize(str) {\n    return str.replace(str[0], str[0].toUpperCase());\n}\n// src/query/tsHelpers.ts\nfunction safeAssign(target, ...args) {\n    return Object.assign(target, ...args);\n}\n// src/query/react/module.ts\n\n// src/query/utils/countObjectKeys.ts\nfunction countObjectKeys(obj) {\n    let count = 0;\n    for(const _key in obj){\n        count++;\n    }\n    return count;\n}\n// src/query/react/module.ts\nvar reactHooksModuleName = /* @__PURE__ */ Symbol();\nvar reactHooksModule = ({ batch = react_redux__WEBPACK_IMPORTED_MODULE_1__.batch, hooks = {\n    useDispatch: react_redux__WEBPACK_IMPORTED_MODULE_1__.useDispatch,\n    useSelector: react_redux__WEBPACK_IMPORTED_MODULE_1__.useSelector,\n    useStore: react_redux__WEBPACK_IMPORTED_MODULE_1__.useStore\n}, unstable__sideEffectsInRender = false, ...rest } = {})=>{\n    if (true) {\n        const hookNames = [\n            \"useDispatch\",\n            \"useSelector\",\n            \"useStore\"\n        ];\n        let warned = false;\n        for (const hookName of hookNames){\n            if (countObjectKeys(rest) > 0) {\n                if (rest[hookName]) {\n                    if (!warned) {\n                        console.warn(\"As of RTK 2.0, the hooks now need to be specified as one object, provided under a `hooks` key:\\n`reactHooksModule({ hooks: { useDispatch, useSelector, useStore } })`\");\n                        warned = true;\n                    }\n                }\n                hooks[hookName] = rest[hookName];\n            }\n            if (typeof hooks[hookName] !== \"function\") {\n                throw new Error( false ? 0 : `When using custom hooks for context, all ${hookNames.length} hooks need to be provided: ${hookNames.join(\", \")}.\nHook ${hookName} was either not provided or not a function.`);\n            }\n        }\n    }\n    return {\n        name: reactHooksModuleName,\n        init (api, { serializeQueryArgs }, context) {\n            const anyApi = api;\n            const { buildQueryHooks, buildMutationHook, usePrefetch } = buildHooks({\n                api,\n                moduleOptions: {\n                    batch,\n                    hooks,\n                    unstable__sideEffectsInRender\n                },\n                serializeQueryArgs,\n                context\n            });\n            safeAssign(anyApi, {\n                usePrefetch\n            });\n            safeAssign(context, {\n                batch\n            });\n            return {\n                injectEndpoint (endpointName, definition) {\n                    if (isQueryDefinition(definition)) {\n                        const { useQuery, useLazyQuery, useLazyQuerySubscription, useQueryState, useQuerySubscription } = buildQueryHooks(endpointName);\n                        safeAssign(anyApi.endpoints[endpointName], {\n                            useQuery,\n                            useLazyQuery,\n                            useLazyQuerySubscription,\n                            useQueryState,\n                            useQuerySubscription\n                        });\n                        api[`use${capitalize(endpointName)}Query`] = useQuery;\n                        api[`useLazy${capitalize(endpointName)}Query`] = useLazyQuery;\n                    } else if (isMutationDefinition(definition)) {\n                        const useMutation = buildMutationHook(endpointName);\n                        safeAssign(anyApi.endpoints[endpointName], {\n                            useMutation\n                        });\n                        api[`use${capitalize(endpointName)}Mutation`] = useMutation;\n                    }\n                }\n            };\n        }\n    };\n};\n// src/query/react/index.ts\n\n// src/query/react/ApiProvider.tsx\n\n\n\n\n\n\n\nfunction ApiProvider(props) {\n    const context = props.context || react_redux__WEBPACK_IMPORTED_MODULE_1__.ReactReduxContext;\n    const existingContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(context);\n    if (existingContext) {\n        throw new Error( false ? 0 : \"Existing Redux context detected. If you already have a store set up, please use the traditional Redux setup.\");\n    }\n    const [store] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_5__.configureStore)({\n            reducer: {\n                [props.api.reducerPath]: props.api.reducer\n            },\n            middleware: (gDM)=>gDM().concat(props.api.middleware)\n        }));\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>props.setupListeners === false ? void 0 : (0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.setupListeners)(store.dispatch, props.setupListeners), [\n        props.setupListeners,\n        store.dispatch\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_redux__WEBPACK_IMPORTED_MODULE_1__.Provider, {\n        store,\n        context\n    }, props.children);\n}\n// src/query/react/index.ts\nvar createApi = /* @__PURE__ */ (0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.buildCreateApi)((0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.coreModule)(), reactHooksModule());\n //# sourceMappingURL=rtk-query-react.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3F1ZXJ5L3JlYWN0L3J0ay1xdWVyeS1yZWFjdC5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJCQUEyQjtBQUN5QztBQUVwRSw0QkFBNEI7QUFDMEQ7QUFFdEYsZ0NBQWdDO0FBQ3NEO0FBQ0Q7QUFDaEI7QUFDMEU7QUFDL0U7QUFDSjtBQUU1RCw4Q0FBOEM7QUFDSztBQUNuRCxTQUFTc0IsbUJBQW1CQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsa0JBQWtCLEVBQUVDLFlBQVk7SUFDaEYsTUFBTUMsV0FBV2QsOENBQU9BLENBQUMsSUFBTztZQUM5QlU7WUFDQUssWUFBWSxPQUFPTCxhQUFhLFdBQVdDLFVBQVU7Z0JBQ25ERDtnQkFDQUU7Z0JBQ0FDO1lBQ0YsS0FBS0g7UUFDUCxJQUFJO1FBQUNBO1FBQVdDO1FBQVdDO1FBQW9CQztLQUFhO0lBQzVELE1BQU1HLFNBQVNkLDZDQUFNQSxDQUFDWTtJQUN0QmpCLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSW1CLE9BQU9DLE9BQU8sQ0FBQ0YsVUFBVSxLQUFLRCxTQUFTQyxVQUFVLEVBQUU7WUFDckRDLE9BQU9DLE9BQU8sR0FBR0g7UUFDbkI7SUFDRixHQUFHO1FBQUNBO0tBQVM7SUFDYixPQUFPRSxPQUFPQyxPQUFPLENBQUNGLFVBQVUsS0FBS0QsU0FBU0MsVUFBVSxHQUFHQyxPQUFPQyxPQUFPLENBQUNQLFNBQVMsR0FBR0E7QUFDeEY7QUFFQSwrQkFBK0I7QUFDL0IsSUFBSVEsc0JBQXNCQztBQUUxQiwyQ0FBMkM7QUFDd0I7QUFDeEI7QUFDM0MsU0FBU0csc0JBQXNCQyxLQUFLO0lBQ2xDLE1BQU1QLFNBQVNLLDZDQUFPQSxDQUFDRTtJQUN2QkgsZ0RBQVVBLENBQUM7UUFDVCxJQUFJLENBQUNiLHlEQUFZQSxDQUFDUyxPQUFPQyxPQUFPLEVBQUVNLFFBQVE7WUFDeENQLE9BQU9DLE9BQU8s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SCxnRUFBY0EsQ0FBQztZQUNsRFUsU0FBUztnQkFDUCxDQUFDRixNQUFNL0ksR0FBRyxDQUFDOEMsV0FBVyxDQUFDLEVBQUVpRyxNQUFNL0ksR0FBRyxDQUFDaUosT0FBTztZQUM1QztZQUNBQyxZQUFZLENBQUNDLE1BQVFBLE1BQU1DLE1BQU0sQ0FBQ0wsTUFBTS9JLEdBQUcsQ0FBQ2tKLFVBQVU7UUFDeEQ7SUFDQVQsZ0RBQVVBLENBQUMsSUFBTU0sTUFBTUYsY0FBYyxLQUFLLFFBQVEsS0FBSyxJQUFJQSxzRUFBY0EsQ0FBQzNELE1BQU0xRCxRQUFRLEVBQUV1SCxNQUFNRixjQUFjLEdBQUc7UUFBQ0UsTUFBTUYsY0FBYztRQUFFM0QsTUFBTTFELFFBQVE7S0FBQztJQUN2SixPQUFPLGFBQWEsaUJBQUdrSCxnREFBbUIsQ0FBQ0MsaURBQVFBLEVBQUU7UUFBRXpEO1FBQU96RTtJQUFRLEdBQUdzSSxNQUFNTSxRQUFRO0FBQ3pGO0FBRUEsMkJBQTJCO0FBQzNCLElBQUlDLFlBQVksYUFBYSxHQUFHeE8sc0VBQWNBLENBQUNELGtFQUFVQSxJQUFJNE07QUFNM0QsQ0FDRixtREFBbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYWdlLnN0b3JlLy4vbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvZGlzdC9xdWVyeS9yZWFjdC9ydGstcXVlcnktcmVhY3QubW9kZXJuLm1qcz9jODQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9xdWVyeS9yZWFjdC9pbmRleC50c1xuaW1wb3J0IHsgY29yZU1vZHVsZSwgYnVpbGRDcmVhdGVBcGkgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdC9xdWVyeVwiO1xuXG4vLyBzcmMvcXVlcnkvcmVhY3QvbW9kdWxlLnRzXG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMyB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5cbi8vIHNyYy9xdWVyeS9yZWFjdC9idWlsZEhvb2tzLnRzXG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIGFzIGNyZWF0ZVNlbGVjdG9yMiB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRGVidWdWYWx1ZSwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDMsIHVzZUxheW91dEVmZmVjdCwgdXNlTWVtbyBhcyB1c2VNZW1vMiwgdXNlUmVmIGFzIHVzZVJlZjMsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBRdWVyeVN0YXR1cywgc2tpcFRva2VuIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXQvcXVlcnlcIjtcbmltcG9ydCB7IHNoYWxsb3dFcXVhbCBhcyBzaGFsbG93RXF1YWwyIH0gZnJvbSBcInJlYWN0LXJlZHV4XCI7XG5cbi8vIHNyYy9xdWVyeS9yZWFjdC91c2VTZXJpYWxpemVkU3RhYmxlVmFsdWUudHNcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VTdGFibGVRdWVyeUFyZ3MocXVlcnlBcmdzLCBzZXJpYWxpemUsIGVuZHBvaW50RGVmaW5pdGlvbiwgZW5kcG9pbnROYW1lKSB7XG4gIGNvbnN0IGluY29taW5nID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHF1ZXJ5QXJncyxcbiAgICBzZXJpYWxpemVkOiB0eXBlb2YgcXVlcnlBcmdzID09IFwib2JqZWN0XCIgPyBzZXJpYWxpemUoe1xuICAgICAgcXVlcnlBcmdzLFxuICAgICAgZW5kcG9pbnREZWZpbml0aW9uLFxuICAgICAgZW5kcG9pbnROYW1lXG4gICAgfSkgOiBxdWVyeUFyZ3NcbiAgfSksIFtxdWVyeUFyZ3MsIHNlcmlhbGl6ZSwgZW5kcG9pbnREZWZpbml0aW9uLCBlbmRwb2ludE5hbWVdKTtcbiAgY29uc3QgY2FjaGUyID0gdXNlUmVmKGluY29taW5nKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY2FjaGUyLmN1cnJlbnQuc2VyaWFsaXplZCAhPT0gaW5jb21pbmcuc2VyaWFsaXplZCkge1xuICAgICAgY2FjaGUyLmN1cnJlbnQgPSBpbmNvbWluZztcbiAgICB9XG4gIH0sIFtpbmNvbWluZ10pO1xuICByZXR1cm4gY2FjaGUyLmN1cnJlbnQuc2VyaWFsaXplZCA9PT0gaW5jb21pbmcuc2VyaWFsaXplZCA/IGNhY2hlMi5jdXJyZW50LnF1ZXJ5QXJncyA6IHF1ZXJ5QXJncztcbn1cblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L2NvbnN0YW50cy50c1xudmFyIFVOSU5JVElBTElaRURfVkFMVUUgPSBTeW1ib2woKTtcblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L3VzZVNoYWxsb3dTdGFibGVWYWx1ZS50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIsIHVzZVJlZiBhcyB1c2VSZWYyIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzaGFsbG93RXF1YWwgfSBmcm9tIFwicmVhY3QtcmVkdXhcIjtcbmZ1bmN0aW9uIHVzZVNoYWxsb3dTdGFibGVWYWx1ZSh2YWx1ZSkge1xuICBjb25zdCBjYWNoZTIgPSB1c2VSZWYyKHZhbHVlKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKCFzaGFsbG93RXF1YWwoY2FjaGUyLmN1cnJlbnQsIHZhbHVlKSkge1xuICAgICAgY2FjaGUyLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIFt2YWx1ZV0pO1xuICByZXR1cm4gc2hhbGxvd0VxdWFsKGNhY2hlMi5jdXJyZW50LCB2YWx1ZSkgPyBjYWNoZTIuY3VycmVudCA6IHZhbHVlO1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9ydGtJbXBvcnRzLnRzXG5pbXBvcnQgeyBjcmVhdGVBY3Rpb24sIGNyZWF0ZVNsaWNlLCBjcmVhdGVTZWxlY3RvciwgY3JlYXRlQXN5bmNUaHVuaywgY29tYmluZVJlZHVjZXJzLCBjcmVhdGVOZXh0U3RhdGUsIGlzQW55T2YsIGlzQWxsT2YsIGlzQWN0aW9uLCBpc1BlbmRpbmcsIGlzUmVqZWN0ZWQsIGlzRnVsZmlsbGVkLCBpc1JlamVjdGVkV2l0aFZhbHVlLCBpc0FzeW5jVGh1bmtBY3Rpb24sIHByZXBhcmVBdXRvQmF0Y2hlZCwgU0hPVUxEX0FVVE9CQVRDSCwgaXNQbGFpbk9iamVjdCwgbmFub2lkIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcblxuLy8gc3JjL3F1ZXJ5L2RlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MudHNcbnZhciBjYWNoZSA9IFdlYWtNYXAgPyAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSA6IHZvaWQgMDtcbnZhciBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzID0gKHtcbiAgZW5kcG9pbnROYW1lLFxuICBxdWVyeUFyZ3Ncbn0pID0+IHtcbiAgbGV0IHNlcmlhbGl6ZWQgPSBcIlwiO1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZT8uZ2V0KHF1ZXJ5QXJncyk7XG4gIGlmICh0eXBlb2YgY2FjaGVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgc2VyaWFsaXplZCA9IGNhY2hlZDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5QXJncywgKGtleSwgdmFsdWUpID0+IGlzUGxhaW5PYmplY3QodmFsdWUpID8gT2JqZWN0LmtleXModmFsdWUpLnNvcnQoKS5yZWR1Y2UoKGFjYywga2V5MikgPT4ge1xuICAgICAgYWNjW2tleTJdID0gdmFsdWVba2V5Ml07XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KSA6IHZhbHVlKTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChxdWVyeUFyZ3MpKSB7XG4gICAgICBjYWNoZT8uc2V0KHF1ZXJ5QXJncywgc3RyaW5naWZpZWQpO1xuICAgIH1cbiAgICBzZXJpYWxpemVkID0gc3RyaW5naWZpZWQ7XG4gIH1cbiAgcmV0dXJuIGAke2VuZHBvaW50TmFtZX0oJHtzZXJpYWxpemVkfSlgO1xufTtcblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L2J1aWxkSG9va3MudHNcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIXdpbmRvdy5kb2N1bWVudCAmJiAhIXdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0MztcbnZhciBub1BlbmRpbmdRdWVyeVN0YXRlU2VsZWN0b3IgPSAoc2VsZWN0ZWQpID0+IHtcbiAgaWYgKHNlbGVjdGVkLmlzVW5pbml0aWFsaXplZCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zZWxlY3RlZCxcbiAgICAgIGlzVW5pbml0aWFsaXplZDogZmFsc2UsXG4gICAgICBpc0ZldGNoaW5nOiB0cnVlLFxuICAgICAgaXNMb2FkaW5nOiBzZWxlY3RlZC5kYXRhICE9PSB2b2lkIDAgPyBmYWxzZSA6IHRydWUsXG4gICAgICBzdGF0dXM6IFF1ZXJ5U3RhdHVzLnBlbmRpbmdcbiAgICB9O1xuICB9XG4gIHJldHVybiBzZWxlY3RlZDtcbn07XG5mdW5jdGlvbiBidWlsZEhvb2tzKHtcbiAgYXBpLFxuICBtb2R1bGVPcHRpb25zOiB7XG4gICAgYmF0Y2gsXG4gICAgaG9va3M6IHtcbiAgICAgIHVzZURpc3BhdGNoLFxuICAgICAgdXNlU2VsZWN0b3IsXG4gICAgICB1c2VTdG9yZVxuICAgIH0sXG4gICAgdW5zdGFibGVfX3NpZGVFZmZlY3RzSW5SZW5kZXJcbiAgfSxcbiAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICBjb250ZXh0XG59KSB7XG4gIGNvbnN0IHVzZVBvc3NpYmx5SW1tZWRpYXRlRWZmZWN0ID0gdW5zdGFibGVfX3NpZGVFZmZlY3RzSW5SZW5kZXIgPyAoY2IpID0+IGNiKCkgOiB1c2VFZmZlY3QzO1xuICByZXR1cm4ge1xuICAgIGJ1aWxkUXVlcnlIb29rcyxcbiAgICBidWlsZE11dGF0aW9uSG9vayxcbiAgICB1c2VQcmVmZXRjaFxuICB9O1xuICBmdW5jdGlvbiBxdWVyeVN0YXRlUHJlU2VsZWN0b3IoY3VycmVudFN0YXRlLCBsYXN0UmVzdWx0LCBxdWVyeUFyZ3MpIHtcbiAgICBpZiAobGFzdFJlc3VsdD8uZW5kcG9pbnROYW1lICYmIGN1cnJlbnRTdGF0ZS5pc1VuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9ID0gbGFzdFJlc3VsdDtcbiAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgICAgaWYgKHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICAgIHF1ZXJ5QXJnczogbGFzdFJlc3VsdC5vcmlnaW5hbEFyZ3MsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KSA9PT0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzLFxuICAgICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICAgIGVuZHBvaW50TmFtZVxuICAgICAgfSkpXG4gICAgICAgIGxhc3RSZXN1bHQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGxldCBkYXRhID0gY3VycmVudFN0YXRlLmlzU3VjY2VzcyA/IGN1cnJlbnRTdGF0ZS5kYXRhIDogbGFzdFJlc3VsdD8uZGF0YTtcbiAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKVxuICAgICAgZGF0YSA9IGN1cnJlbnRTdGF0ZS5kYXRhO1xuICAgIGNvbnN0IGhhc0RhdGEgPSBkYXRhICE9PSB2b2lkIDA7XG4gICAgY29uc3QgaXNGZXRjaGluZyA9IGN1cnJlbnRTdGF0ZS5pc0xvYWRpbmc7XG4gICAgY29uc3QgaXNMb2FkaW5nID0gIWhhc0RhdGEgJiYgaXNGZXRjaGluZztcbiAgICBjb25zdCBpc1N1Y2Nlc3MgPSBjdXJyZW50U3RhdGUuaXNTdWNjZXNzIHx8IGlzRmV0Y2hpbmcgJiYgaGFzRGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY3VycmVudFN0YXRlLFxuICAgICAgZGF0YSxcbiAgICAgIGN1cnJlbnREYXRhOiBjdXJyZW50U3RhdGUuZGF0YSxcbiAgICAgIGlzRmV0Y2hpbmcsXG4gICAgICBpc0xvYWRpbmcsXG4gICAgICBpc1N1Y2Nlc3NcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHVzZVByZWZldGNoKGVuZHBvaW50TmFtZSwgZGVmYXVsdE9wdGlvbnMpIHtcbiAgICBjb25zdCBkaXNwYXRjaCA9IHVzZURpc3BhdGNoKCk7XG4gICAgY29uc3Qgc3RhYmxlRGVmYXVsdE9wdGlvbnMgPSB1c2VTaGFsbG93U3RhYmxlVmFsdWUoZGVmYXVsdE9wdGlvbnMpO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoYXJnLCBvcHRpb25zKSA9PiBkaXNwYXRjaChhcGkudXRpbC5wcmVmZXRjaChlbmRwb2ludE5hbWUsIGFyZywge1xuICAgICAgLi4uc3RhYmxlRGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSkpLCBbZW5kcG9pbnROYW1lLCBkaXNwYXRjaCwgc3RhYmxlRGVmYXVsdE9wdGlvbnNdKTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZFF1ZXJ5SG9va3MobmFtZSkge1xuICAgIGNvbnN0IHVzZVF1ZXJ5U3Vic2NyaXB0aW9uID0gKGFyZywge1xuICAgICAgcmVmZXRjaE9uUmVjb25uZWN0LFxuICAgICAgcmVmZXRjaE9uRm9jdXMsXG4gICAgICByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlLFxuICAgICAgc2tpcCA9IGZhbHNlLFxuICAgICAgcG9sbGluZ0ludGVydmFsID0gMFxuICAgIH0gPSB7fSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpbml0aWF0ZVxuICAgICAgfSA9IGFwaS5lbmRwb2ludHNbbmFtZV07XG4gICAgICBjb25zdCBkaXNwYXRjaCA9IHVzZURpc3BhdGNoKCk7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb25TZWxlY3RvcnNSZWYgPSB1c2VSZWYzKCk7XG4gICAgICBpZiAoIXN1YnNjcmlwdGlvblNlbGVjdG9yc1JlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IHJldHVybmVkVmFsdWUgPSBkaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLmludGVybmFsX2dldFJUS1FTdWJzY3JpcHRpb25zKCkpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXR1cm5lZFZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiByZXR1cm5lZFZhbHVlPy50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzcpIDogYFdhcm5pbmc6IE1pZGRsZXdhcmUgZm9yIFJUSy1RdWVyeSBBUEkgYXQgcmVkdWNlclBhdGggXCIke2FwaS5yZWR1Y2VyUGF0aH1cIiBoYXMgbm90IGJlZW4gYWRkZWQgdG8gdGhlIHN0b3JlLlxuICAgIFlvdSBtdXN0IGFkZCB0aGUgbWlkZGxld2FyZSBmb3IgUlRLLVF1ZXJ5IHRvIGZ1bmN0aW9uIGNvcnJlY3RseSFgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaXB0aW9uU2VsZWN0b3JzUmVmLmN1cnJlbnQgPSByZXR1cm5lZFZhbHVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhYmxlQXJnID0gdXNlU3RhYmxlUXVlcnlBcmdzKFxuICAgICAgICBza2lwID8gc2tpcFRva2VuIDogYXJnLFxuICAgICAgICAvLyBFdmVuIGlmIHRoZSB1c2VyIHByb3ZpZGVkIGEgcGVyLWVuZHBvaW50IGBzZXJpYWxpemVRdWVyeUFyZ3NgIHdpdGhcbiAgICAgICAgLy8gYSBjb25zaXN0ZW50IHJldHVybiB2YWx1ZSwgX2hlcmVfIHdlIHdhbnQgdG8gdXNlIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgIC8vIHNvIHdlIGNhbiB0ZWxsIGlmIF9hbnl0aGluZ18gYWN0dWFsbHkgY2hhbmdlZC4gT3RoZXJ3aXNlLCB3ZSBjYW4gZW5kIHVwXG4gICAgICAgIC8vIHdpdGggYSBjYXNlIHdoZXJlIHRoZSBxdWVyeSBhcmdzIGRpZCBjaGFuZ2UgYnV0IHRoZSBzZXJpYWxpemF0aW9uIGRvZXNuJ3QsXG4gICAgICAgIC8vIGFuZCB0aGVuIHdlIG5ldmVyIHRyeSB0byBpbml0aWF0ZSBhIHJlZmV0Y2guXG4gICAgICAgIGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MsXG4gICAgICAgIGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tuYW1lXSxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMgPSB1c2VTaGFsbG93U3RhYmxlVmFsdWUoe1xuICAgICAgICByZWZldGNoT25SZWNvbm5lY3QsXG4gICAgICAgIHJlZmV0Y2hPbkZvY3VzLFxuICAgICAgICBwb2xsaW5nSW50ZXJ2YWxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbGFzdFJlbmRlckhhZFN1YnNjcmlwdGlvbiA9IHVzZVJlZjMoZmFsc2UpO1xuICAgICAgY29uc3QgcHJvbWlzZVJlZiA9IHVzZVJlZjMoKTtcbiAgICAgIGxldCB7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgIHJlcXVlc3RJZFxuICAgICAgfSA9IHByb21pc2VSZWYuY3VycmVudCB8fCB7fTtcbiAgICAgIGxldCBjdXJyZW50UmVuZGVySGFzU3Vic2NyaXB0aW9uID0gZmFsc2U7XG4gICAgICBpZiAocXVlcnlDYWNoZUtleSAmJiByZXF1ZXN0SWQpIHtcbiAgICAgICAgY3VycmVudFJlbmRlckhhc1N1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvblNlbGVjdG9yc1JlZi5jdXJyZW50LmlzUmVxdWVzdFN1YnNjcmliZWQocXVlcnlDYWNoZUtleSwgcmVxdWVzdElkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvblJlbW92ZWQgPSAhY3VycmVudFJlbmRlckhhc1N1YnNjcmlwdGlvbiAmJiBsYXN0UmVuZGVySGFkU3Vic2NyaXB0aW9uLmN1cnJlbnQ7XG4gICAgICB1c2VQb3NzaWJseUltbWVkaWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxhc3RSZW5kZXJIYWRTdWJzY3JpcHRpb24uY3VycmVudCA9IGN1cnJlbnRSZW5kZXJIYXNTdWJzY3JpcHRpb247XG4gICAgICB9KTtcbiAgICAgIHVzZVBvc3NpYmx5SW1tZWRpYXRlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvblJlbW92ZWQpIHtcbiAgICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH0sIFtzdWJzY3JpcHRpb25SZW1vdmVkXSk7XG4gICAgICB1c2VQb3NzaWJseUltbWVkaWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhc3RQcm9taXNlID0gcHJvbWlzZVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicmVtb3ZlTWVPbkNvbXBpbGF0aW9uXCIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhzdWJzY3JpcHRpb25SZW1vdmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhYmxlQXJnID09PSBza2lwVG9rZW4pIHtcbiAgICAgICAgICBsYXN0UHJvbWlzZT8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3RTdWJzY3JpcHRpb25PcHRpb25zID0gcHJvbWlzZVJlZi5jdXJyZW50Py5zdWJzY3JpcHRpb25PcHRpb25zO1xuICAgICAgICBpZiAoIWxhc3RQcm9taXNlIHx8IGxhc3RQcm9taXNlLmFyZyAhPT0gc3RhYmxlQXJnKSB7XG4gICAgICAgICAgbGFzdFByb21pc2U/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGRpc3BhdGNoKGluaXRpYXRlKHN0YWJsZUFyZywge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9uczogc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyxcbiAgICAgICAgICAgIGZvcmNlUmVmZXRjaDogcmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQgPSBwcm9taXNlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMgIT09IGxhc3RTdWJzY3JpcHRpb25PcHRpb25zKSB7XG4gICAgICAgICAgbGFzdFByb21pc2UudXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyhzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSwgW2Rpc3BhdGNoLCBpbml0aWF0ZSwgcmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZSwgc3RhYmxlQXJnLCBzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zLCBzdWJzY3JpcHRpb25SZW1vdmVkXSk7XG4gICAgICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQ/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50ID0gdm9pZCAwO1xuICAgICAgICB9O1xuICAgICAgfSwgW10pO1xuICAgICAgcmV0dXJuIHVzZU1lbW8yKCgpID0+ICh7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1ldGhvZCB0byBtYW51YWxseSByZWZldGNoIGRhdGEgZm9yIHRoZSBxdWVyeVxuICAgICAgICAgKi9cbiAgICAgICAgcmVmZXRjaDogKCkgPT4ge1xuICAgICAgICAgIGlmICghcHJvbWlzZVJlZi5jdXJyZW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMigzOCkgOiBcIkNhbm5vdCByZWZldGNoIGEgcXVlcnkgdGhhdCBoYXMgbm90IGJlZW4gc3RhcnRlZCB5ZXQuXCIpO1xuICAgICAgICAgIHJldHVybiBwcm9taXNlUmVmLmN1cnJlbnQ/LnJlZmV0Y2goKTtcbiAgICAgICAgfVxuICAgICAgfSksIFtdKTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZUxhenlRdWVyeVN1YnNjcmlwdGlvbiA9ICh7XG4gICAgICByZWZldGNoT25SZWNvbm5lY3QsXG4gICAgICByZWZldGNoT25Gb2N1cyxcbiAgICAgIHBvbGxpbmdJbnRlcnZhbCA9IDBcbiAgICB9ID0ge30pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5pdGlhdGVcbiAgICAgIH0gPSBhcGkuZW5kcG9pbnRzW25hbWVdO1xuICAgICAgY29uc3QgZGlzcGF0Y2ggPSB1c2VEaXNwYXRjaCgpO1xuICAgICAgY29uc3QgW2FyZywgc2V0QXJnXSA9IHVzZVN0YXRlKFVOSU5JVElBTElaRURfVkFMVUUpO1xuICAgICAgY29uc3QgcHJvbWlzZVJlZiA9IHVzZVJlZjMoKTtcbiAgICAgIGNvbnN0IHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMgPSB1c2VTaGFsbG93U3RhYmxlVmFsdWUoe1xuICAgICAgICByZWZldGNoT25SZWNvbm5lY3QsXG4gICAgICAgIHJlZmV0Y2hPbkZvY3VzLFxuICAgICAgICBwb2xsaW5nSW50ZXJ2YWxcbiAgICAgIH0pO1xuICAgICAgdXNlUG9zc2libHlJbW1lZGlhdGVFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBsYXN0U3Vic2NyaXB0aW9uT3B0aW9ucyA9IHByb21pc2VSZWYuY3VycmVudD8uc3Vic2NyaXB0aW9uT3B0aW9ucztcbiAgICAgICAgaWYgKHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMgIT09IGxhc3RTdWJzY3JpcHRpb25PcHRpb25zKSB7XG4gICAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50Py51cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zKHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9LCBbc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9uc10pO1xuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uT3B0aW9uc1JlZiA9IHVzZVJlZjMoc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyk7XG4gICAgICB1c2VQb3NzaWJseUltbWVkaWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnNSZWYuY3VycmVudCA9IHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnM7XG4gICAgICB9LCBbc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9uc10pO1xuICAgICAgY29uc3QgdHJpZ2dlciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uKGFyZzIsIHByZWZlckNhY2hlVmFsdWUgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcHJvbWlzZTtcbiAgICAgICAgYmF0Y2goKCkgPT4ge1xuICAgICAgICAgIHByb21pc2VSZWYuY3VycmVudD8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQgPSBwcm9taXNlID0gZGlzcGF0Y2goaW5pdGlhdGUoYXJnMiwge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9uczogc3Vic2NyaXB0aW9uT3B0aW9uc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgZm9yY2VSZWZldGNoOiAhcHJlZmVyQ2FjaGVWYWx1ZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBzZXRBcmcoYXJnMik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH0sIFtkaXNwYXRjaCwgaW5pdGlhdGVdKTtcbiAgICAgIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHByb21pc2VSZWY/LmN1cnJlbnQ/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH07XG4gICAgICB9LCBbXSk7XG4gICAgICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICAgICAgaWYgKGFyZyAhPT0gVU5JTklUSUFMSVpFRF9WQUxVRSAmJiAhcHJvbWlzZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgdHJpZ2dlcihhcmcsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCBbYXJnLCB0cmlnZ2VyXSk7XG4gICAgICByZXR1cm4gdXNlTWVtbzIoKCkgPT4gW3RyaWdnZXIsIGFyZ10sIFt0cmlnZ2VyLCBhcmddKTtcbiAgICB9O1xuICAgIGNvbnN0IHVzZVF1ZXJ5U3RhdGUgPSAoYXJnLCB7XG4gICAgICBza2lwID0gZmFsc2UsXG4gICAgICBzZWxlY3RGcm9tUmVzdWx0XG4gICAgfSA9IHt9KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdFxuICAgICAgfSA9IGFwaS5lbmRwb2ludHNbbmFtZV07XG4gICAgICBjb25zdCBzdGFibGVBcmcgPSB1c2VTdGFibGVRdWVyeUFyZ3Moc2tpcCA/IHNraXBUb2tlbiA6IGFyZywgc2VyaWFsaXplUXVlcnlBcmdzLCBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbbmFtZV0sIG5hbWUpO1xuICAgICAgY29uc3QgbGFzdFZhbHVlID0gdXNlUmVmMygpO1xuICAgICAgY29uc3Qgc2VsZWN0RGVmYXVsdFJlc3VsdCA9IHVzZU1lbW8yKCgpID0+IGNyZWF0ZVNlbGVjdG9yMihbc2VsZWN0KHN0YWJsZUFyZyksIChfLCBsYXN0UmVzdWx0KSA9PiBsYXN0UmVzdWx0LCAoXykgPT4gc3RhYmxlQXJnXSwgcXVlcnlTdGF0ZVByZVNlbGVjdG9yKSwgW3NlbGVjdCwgc3RhYmxlQXJnXSk7XG4gICAgICBjb25zdCBxdWVyeVNlbGVjdG9yID0gdXNlTWVtbzIoKCkgPT4gc2VsZWN0RnJvbVJlc3VsdCA/IGNyZWF0ZVNlbGVjdG9yMihbc2VsZWN0RGVmYXVsdFJlc3VsdF0sIHNlbGVjdEZyb21SZXN1bHQsIHtcbiAgICAgICAgZGV2TW9kZUNoZWNrczoge1xuICAgICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjazogXCJuZXZlclwiXG4gICAgICAgIH1cbiAgICAgIH0pIDogc2VsZWN0RGVmYXVsdFJlc3VsdCwgW3NlbGVjdERlZmF1bHRSZXN1bHQsIHNlbGVjdEZyb21SZXN1bHRdKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHVzZVNlbGVjdG9yKChzdGF0ZSkgPT4gcXVlcnlTZWxlY3RvcihzdGF0ZSwgbGFzdFZhbHVlLmN1cnJlbnQpLCBzaGFsbG93RXF1YWwyKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKTtcbiAgICAgIGNvbnN0IG5ld0xhc3RWYWx1ZSA9IHNlbGVjdERlZmF1bHRSZXN1bHQoc3RvcmUuZ2V0U3RhdGUoKSwgbGFzdFZhbHVlLmN1cnJlbnQpO1xuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxhc3RWYWx1ZS5jdXJyZW50ID0gbmV3TGFzdFZhbHVlO1xuICAgICAgfSwgW25ld0xhc3RWYWx1ZV0pO1xuICAgICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB1c2VRdWVyeVN0YXRlLFxuICAgICAgdXNlUXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICB1c2VMYXp5UXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICB1c2VMYXp5UXVlcnkob3B0aW9ucykge1xuICAgICAgICBjb25zdCBbdHJpZ2dlciwgYXJnXSA9IHVzZUxhenlRdWVyeVN1YnNjcmlwdGlvbihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcXVlcnlTdGF0ZVJlc3VsdHMgPSB1c2VRdWVyeVN0YXRlKGFyZywge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgc2tpcDogYXJnID09PSBVTklOSVRJQUxJWkVEX1ZBTFVFXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbmZvID0gdXNlTWVtbzIoKCkgPT4gKHtcbiAgICAgICAgICBsYXN0QXJnOiBhcmdcbiAgICAgICAgfSksIFthcmddKTtcbiAgICAgICAgcmV0dXJuIHVzZU1lbW8yKCgpID0+IFt0cmlnZ2VyLCBxdWVyeVN0YXRlUmVzdWx0cywgaW5mb10sIFt0cmlnZ2VyLCBxdWVyeVN0YXRlUmVzdWx0cywgaW5mb10pO1xuICAgICAgfSxcbiAgICAgIHVzZVF1ZXJ5KGFyZywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBxdWVyeVN1YnNjcmlwdGlvblJlc3VsdHMgPSB1c2VRdWVyeVN1YnNjcmlwdGlvbihhcmcsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBxdWVyeVN0YXRlUmVzdWx0cyA9IHVzZVF1ZXJ5U3RhdGUoYXJnLCB7XG4gICAgICAgICAgc2VsZWN0RnJvbVJlc3VsdDogYXJnID09PSBza2lwVG9rZW4gfHwgb3B0aW9ucz8uc2tpcCA/IHZvaWQgMCA6IG5vUGVuZGluZ1F1ZXJ5U3RhdGVTZWxlY3RvcixcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgaXNMb2FkaW5nLFxuICAgICAgICAgIGlzU3VjY2VzcyxcbiAgICAgICAgICBpc0Vycm9yLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0gPSBxdWVyeVN0YXRlUmVzdWx0cztcbiAgICAgICAgdXNlRGVidWdWYWx1ZSh7XG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgaXNMb2FkaW5nLFxuICAgICAgICAgIGlzU3VjY2VzcyxcbiAgICAgICAgICBpc0Vycm9yLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXNlTWVtbzIoKCkgPT4gKHtcbiAgICAgICAgICAuLi5xdWVyeVN0YXRlUmVzdWx0cyxcbiAgICAgICAgICAuLi5xdWVyeVN1YnNjcmlwdGlvblJlc3VsdHNcbiAgICAgICAgfSksIFtxdWVyeVN0YXRlUmVzdWx0cywgcXVlcnlTdWJzY3JpcHRpb25SZXN1bHRzXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZE11dGF0aW9uSG9vayhuYW1lKSB7XG4gICAgcmV0dXJuICh7XG4gICAgICBzZWxlY3RGcm9tUmVzdWx0LFxuICAgICAgZml4ZWRDYWNoZUtleVxuICAgIH0gPSB7fSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3QsXG4gICAgICAgIGluaXRpYXRlXG4gICAgICB9ID0gYXBpLmVuZHBvaW50c1tuYW1lXTtcbiAgICAgIGNvbnN0IGRpc3BhdGNoID0gdXNlRGlzcGF0Y2goKTtcbiAgICAgIGNvbnN0IFtwcm9taXNlLCBzZXRQcm9taXNlXSA9IHVzZVN0YXRlKCk7XG4gICAgICB1c2VFZmZlY3QzKCgpID0+ICgpID0+IHtcbiAgICAgICAgaWYgKCFwcm9taXNlPy5hcmcuZml4ZWRDYWNoZUtleSkge1xuICAgICAgICAgIHByb21pc2U/LnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIFtwcm9taXNlXSk7XG4gICAgICBjb25zdCB0cmlnZ2VyTXV0YXRpb24gPSB1c2VDYWxsYmFjayhmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZTIgPSBkaXNwYXRjaChpbml0aWF0ZShhcmcsIHtcbiAgICAgICAgICBmaXhlZENhY2hlS2V5XG4gICAgICAgIH0pKTtcbiAgICAgICAgc2V0UHJvbWlzZShwcm9taXNlMik7XG4gICAgICAgIHJldHVybiBwcm9taXNlMjtcbiAgICAgIH0sIFtkaXNwYXRjaCwgaW5pdGlhdGUsIGZpeGVkQ2FjaGVLZXldKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdElkXG4gICAgICB9ID0gcHJvbWlzZSB8fCB7fTtcbiAgICAgIGNvbnN0IHNlbGVjdERlZmF1bHRSZXN1bHQgPSB1c2VNZW1vMigoKSA9PiBzZWxlY3Qoe1xuICAgICAgICBmaXhlZENhY2hlS2V5LFxuICAgICAgICByZXF1ZXN0SWQ6IHByb21pc2U/LnJlcXVlc3RJZFxuICAgICAgfSksIFtmaXhlZENhY2hlS2V5LCBwcm9taXNlLCBzZWxlY3RdKTtcbiAgICAgIGNvbnN0IG11dGF0aW9uU2VsZWN0b3IgPSB1c2VNZW1vMigoKSA9PiBzZWxlY3RGcm9tUmVzdWx0ID8gY3JlYXRlU2VsZWN0b3IyKFtzZWxlY3REZWZhdWx0UmVzdWx0XSwgc2VsZWN0RnJvbVJlc3VsdCkgOiBzZWxlY3REZWZhdWx0UmVzdWx0LCBbc2VsZWN0RnJvbVJlc3VsdCwgc2VsZWN0RGVmYXVsdFJlc3VsdF0pO1xuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdXNlU2VsZWN0b3IobXV0YXRpb25TZWxlY3Rvciwgc2hhbGxvd0VxdWFsMik7XG4gICAgICBjb25zdCBvcmlnaW5hbEFyZ3MgPSBmaXhlZENhY2hlS2V5ID09IG51bGwgPyBwcm9taXNlPy5hcmcub3JpZ2luYWxBcmdzIDogdm9pZCAwO1xuICAgICAgY29uc3QgcmVzZXQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGJhdGNoKCgpID0+IHtcbiAgICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgICAgc2V0UHJvbWlzZSh2b2lkIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZml4ZWRDYWNoZUtleSkge1xuICAgICAgICAgICAgZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5yZW1vdmVNdXRhdGlvblJlc3VsdCh7XG4gICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgZml4ZWRDYWNoZUtleVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCBbZGlzcGF0Y2gsIGZpeGVkQ2FjaGVLZXksIHByb21pc2UsIHJlcXVlc3RJZF0pO1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbmRwb2ludE5hbWUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgaXNMb2FkaW5nLFxuICAgICAgICBpc1N1Y2Nlc3MsXG4gICAgICAgIGlzRXJyb3IsXG4gICAgICAgIGVycm9yXG4gICAgICB9ID0gY3VycmVudFN0YXRlO1xuICAgICAgdXNlRGVidWdWYWx1ZSh7XG4gICAgICAgIGVuZHBvaW50TmFtZSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBpc0xvYWRpbmcsXG4gICAgICAgIGlzU3VjY2VzcyxcbiAgICAgICAgaXNFcnJvcixcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZmluYWxTdGF0ZSA9IHVzZU1lbW8yKCgpID0+ICh7XG4gICAgICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICAgICAgb3JpZ2luYWxBcmdzLFxuICAgICAgICByZXNldFxuICAgICAgfSksIFtjdXJyZW50U3RhdGUsIG9yaWdpbmFsQXJncywgcmVzZXRdKTtcbiAgICAgIHJldHVybiB1c2VNZW1vMigoKSA9PiBbdHJpZ2dlck11dGF0aW9uLCBmaW5hbFN0YXRlXSwgW3RyaWdnZXJNdXRhdGlvbiwgZmluYWxTdGF0ZV0pO1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3F1ZXJ5L2VuZHBvaW50RGVmaW5pdGlvbnMudHNcbmZ1bmN0aW9uIGlzUXVlcnlEZWZpbml0aW9uKGUpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gXCJxdWVyeVwiIC8qIHF1ZXJ5ICovO1xufVxuZnVuY3Rpb24gaXNNdXRhdGlvbkRlZmluaXRpb24oZSkge1xuICByZXR1cm4gZS50eXBlID09PSBcIm11dGF0aW9uXCIgLyogbXV0YXRpb24gKi87XG59XG5cbi8vIHNyYy9xdWVyeS91dGlscy9jYXBpdGFsaXplLnRzXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2Uoc3RyWzBdLCBzdHJbMF0udG9VcHBlckNhc2UoKSk7XG59XG5cbi8vIHNyYy9xdWVyeS90c0hlbHBlcnMudHNcbmZ1bmN0aW9uIHNhZmVBc3NpZ24odGFyZ2V0LCAuLi5hcmdzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHRhcmdldCwgLi4uYXJncyk7XG59XG5cbi8vIHNyYy9xdWVyeS9yZWFjdC9tb2R1bGUudHNcbmltcG9ydCB7IHVzZURpc3BhdGNoIGFzIHJyVXNlRGlzcGF0Y2gsIHVzZVNlbGVjdG9yIGFzIHJyVXNlU2VsZWN0b3IsIHVzZVN0b3JlIGFzIHJyVXNlU3RvcmUsIGJhdGNoIGFzIHJyQmF0Y2ggfSBmcm9tIFwicmVhY3QtcmVkdXhcIjtcblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2NvdW50T2JqZWN0S2V5cy50c1xuZnVuY3Rpb24gY291bnRPYmplY3RLZXlzKG9iaikge1xuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKGNvbnN0IF9rZXkgaW4gb2JqKSB7XG4gICAgY291bnQrKztcbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbi8vIHNyYy9xdWVyeS9yZWFjdC9tb2R1bGUudHNcbnZhciByZWFjdEhvb2tzTW9kdWxlTmFtZSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woKTtcbnZhciByZWFjdEhvb2tzTW9kdWxlID0gKHtcbiAgYmF0Y2ggPSByckJhdGNoLFxuICBob29rcyA9IHtcbiAgICB1c2VEaXNwYXRjaDogcnJVc2VEaXNwYXRjaCxcbiAgICB1c2VTZWxlY3RvcjogcnJVc2VTZWxlY3RvcixcbiAgICB1c2VTdG9yZTogcnJVc2VTdG9yZVxuICB9LFxuICB1bnN0YWJsZV9fc2lkZUVmZmVjdHNJblJlbmRlciA9IGZhbHNlLFxuICAuLi5yZXN0XG59ID0ge30pID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IGhvb2tOYW1lcyA9IFtcInVzZURpc3BhdGNoXCIsIFwidXNlU2VsZWN0b3JcIiwgXCJ1c2VTdG9yZVwiXTtcbiAgICBsZXQgd2FybmVkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBob29rTmFtZSBvZiBob29rTmFtZXMpIHtcbiAgICAgIGlmIChjb3VudE9iamVjdEtleXMocmVzdCkgPiAwKSB7XG4gICAgICAgIGlmIChyZXN0W2hvb2tOYW1lXSkge1xuICAgICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBcyBvZiBSVEsgMi4wLCB0aGUgaG9va3Mgbm93IG5lZWQgdG8gYmUgc3BlY2lmaWVkIGFzIG9uZSBvYmplY3QsIHByb3ZpZGVkIHVuZGVyIGEgYGhvb2tzYCBrZXk6XFxuYHJlYWN0SG9va3NNb2R1bGUoeyBob29rczogeyB1c2VEaXNwYXRjaCwgdXNlU2VsZWN0b3IsIHVzZVN0b3JlIH0gfSlgXCIpO1xuICAgICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaG9va3NbaG9va05hbWVdID0gcmVzdFtob29rTmFtZV07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGhvb2tzW2hvb2tOYW1lXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMoMzYpIDogYFdoZW4gdXNpbmcgY3VzdG9tIGhvb2tzIGZvciBjb250ZXh0LCBhbGwgJHtob29rTmFtZXMubGVuZ3RofSBob29rcyBuZWVkIHRvIGJlIHByb3ZpZGVkOiAke2hvb2tOYW1lcy5qb2luKFwiLCBcIil9LlxuSG9vayAke2hvb2tOYW1lfSB3YXMgZWl0aGVyIG5vdCBwcm92aWRlZCBvciBub3QgYSBmdW5jdGlvbi5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiByZWFjdEhvb2tzTW9kdWxlTmFtZSxcbiAgICBpbml0KGFwaSwge1xuICAgICAgc2VyaWFsaXplUXVlcnlBcmdzXG4gICAgfSwgY29udGV4dCkge1xuICAgICAgY29uc3QgYW55QXBpID0gYXBpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBidWlsZFF1ZXJ5SG9va3MsXG4gICAgICAgIGJ1aWxkTXV0YXRpb25Ib29rLFxuICAgICAgICB1c2VQcmVmZXRjaFxuICAgICAgfSA9IGJ1aWxkSG9va3Moe1xuICAgICAgICBhcGksXG4gICAgICAgIG1vZHVsZU9wdGlvbnM6IHtcbiAgICAgICAgICBiYXRjaCxcbiAgICAgICAgICBob29rcyxcbiAgICAgICAgICB1bnN0YWJsZV9fc2lkZUVmZmVjdHNJblJlbmRlclxuICAgICAgICB9LFxuICAgICAgICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pO1xuICAgICAgc2FmZUFzc2lnbihhbnlBcGksIHtcbiAgICAgICAgdXNlUHJlZmV0Y2hcbiAgICAgIH0pO1xuICAgICAgc2FmZUFzc2lnbihjb250ZXh0LCB7XG4gICAgICAgIGJhdGNoXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluamVjdEVuZHBvaW50KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbikge1xuICAgICAgICAgIGlmIChpc1F1ZXJ5RGVmaW5pdGlvbihkZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB1c2VRdWVyeSxcbiAgICAgICAgICAgICAgdXNlTGF6eVF1ZXJ5LFxuICAgICAgICAgICAgICB1c2VMYXp5UXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3RhdGUsXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3Vic2NyaXB0aW9uXG4gICAgICAgICAgICB9ID0gYnVpbGRRdWVyeUhvb2tzKGVuZHBvaW50TmFtZSk7XG4gICAgICAgICAgICBzYWZlQXNzaWduKGFueUFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSwge1xuICAgICAgICAgICAgICB1c2VRdWVyeSxcbiAgICAgICAgICAgICAgdXNlTGF6eVF1ZXJ5LFxuICAgICAgICAgICAgICB1c2VMYXp5UXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3RhdGUsXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3Vic2NyaXB0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFwaVtgdXNlJHtjYXBpdGFsaXplKGVuZHBvaW50TmFtZSl9UXVlcnlgXSA9IHVzZVF1ZXJ5O1xuICAgICAgICAgICAgYXBpW2B1c2VMYXp5JHtjYXBpdGFsaXplKGVuZHBvaW50TmFtZSl9UXVlcnlgXSA9IHVzZUxhenlRdWVyeTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTXV0YXRpb25EZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VNdXRhdGlvbiA9IGJ1aWxkTXV0YXRpb25Ib29rKGVuZHBvaW50TmFtZSk7XG4gICAgICAgICAgICBzYWZlQXNzaWduKGFueUFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSwge1xuICAgICAgICAgICAgICB1c2VNdXRhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcGlbYHVzZSR7Y2FwaXRhbGl6ZShlbmRwb2ludE5hbWUpfU11dGF0aW9uYF0gPSB1c2VNdXRhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdC9xdWVyeVwiO1xuXG4vLyBzcmMvcXVlcnkvcmVhY3QvQXBpUHJvdmlkZXIudHN4XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyBjb25maWd1cmVTdG9yZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgUHJvdmlkZXIsIFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSBcInJlYWN0LXJlZHV4XCI7XG5pbXBvcnQgeyBzZXR1cExpc3RlbmVycyB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0L3F1ZXJ5XCI7XG5mdW5jdGlvbiBBcGlQcm92aWRlcihwcm9wcykge1xuICBjb25zdCBjb250ZXh0ID0gcHJvcHMuY29udGV4dCB8fCBSZWFjdFJlZHV4Q29udGV4dDtcbiAgY29uc3QgZXhpc3RpbmdDb250ZXh0ID0gdXNlQ29udGV4dChjb250ZXh0KTtcbiAgaWYgKGV4aXN0aW5nQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTQoMzUpIDogXCJFeGlzdGluZyBSZWR1eCBjb250ZXh0IGRldGVjdGVkLiBJZiB5b3UgYWxyZWFkeSBoYXZlIGEgc3RvcmUgc2V0IHVwLCBwbGVhc2UgdXNlIHRoZSB0cmFkaXRpb25hbCBSZWR1eCBzZXR1cC5cIik7XG4gIH1cbiAgY29uc3QgW3N0b3JlXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGNvbmZpZ3VyZVN0b3JlKHtcbiAgICByZWR1Y2VyOiB7XG4gICAgICBbcHJvcHMuYXBpLnJlZHVjZXJQYXRoXTogcHJvcHMuYXBpLnJlZHVjZXJcbiAgICB9LFxuICAgIG1pZGRsZXdhcmU6IChnRE0pID0+IGdETSgpLmNvbmNhdChwcm9wcy5hcGkubWlkZGxld2FyZSlcbiAgfSkpO1xuICB1c2VFZmZlY3Q0KCgpID0+IHByb3BzLnNldHVwTGlzdGVuZXJzID09PSBmYWxzZSA/IHZvaWQgMCA6IHNldHVwTGlzdGVuZXJzKHN0b3JlLmRpc3BhdGNoLCBwcm9wcy5zZXR1cExpc3RlbmVycyksIFtwcm9wcy5zZXR1cExpc3RlbmVycywgc3RvcmUuZGlzcGF0Y2hdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFByb3ZpZGVyLCB7IHN0b3JlLCBjb250ZXh0IH0sIHByb3BzLmNoaWxkcmVuKTtcbn1cblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L2luZGV4LnRzXG52YXIgY3JlYXRlQXBpID0gLyogQF9fUFVSRV9fICovIGJ1aWxkQ3JlYXRlQXBpKGNvcmVNb2R1bGUoKSwgcmVhY3RIb29rc01vZHVsZSgpKTtcbmV4cG9ydCB7XG4gIEFwaVByb3ZpZGVyLFxuICBjcmVhdGVBcGksXG4gIHJlYWN0SG9va3NNb2R1bGUsXG4gIHJlYWN0SG9va3NNb2R1bGVOYW1lXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnRrLXF1ZXJ5LXJlYWN0Lm1vZGVybi5tanMubWFwIl0sIm5hbWVzIjpbImNvcmVNb2R1bGUiLCJidWlsZENyZWF0ZUFwaSIsImZvcm1hdFByb2RFcnJvck1lc3NhZ2UiLCJfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMiLCJfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIiLCJfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSIsImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlU2VsZWN0b3IyIiwidXNlQ2FsbGJhY2siLCJ1c2VEZWJ1Z1ZhbHVlIiwidXNlRWZmZWN0IiwidXNlRWZmZWN0MyIsInVzZUxheW91dEVmZmVjdCIsInVzZU1lbW8iLCJ1c2VNZW1vMiIsInVzZVJlZiIsInVzZVJlZjMiLCJ1c2VTdGF0ZSIsIlF1ZXJ5U3RhdHVzIiwic2tpcFRva2VuIiwic2hhbGxvd0VxdWFsIiwic2hhbGxvd0VxdWFsMiIsInVzZVN0YWJsZVF1ZXJ5QXJncyIsInF1ZXJ5QXJncyIsInNlcmlhbGl6ZSIsImVuZHBvaW50RGVmaW5pdGlvbiIsImVuZHBvaW50TmFtZSIsImluY29taW5nIiwic2VyaWFsaXplZCIsImNhY2hlMiIsImN1cnJlbnQiLCJVTklOSVRJQUxJWkVEX1ZBTFVFIiwiU3ltYm9sIiwidXNlRWZmZWN0MiIsInVzZVJlZjIiLCJ1c2VTaGFsbG93U3RhYmxlVmFsdWUiLCJ2YWx1ZSIsImNyZWF0ZUFjdGlvbiIsImNyZWF0ZVNsaWNlIiwiY3JlYXRlQXN5bmNUaHVuayIsImNvbWJpbmVSZWR1Y2VycyIsImNyZWF0ZU5leHRTdGF0ZSIsImlzQW55T2YiLCJpc0FsbE9mIiwiaXNBY3Rpb24iLCJpc1BlbmRpbmciLCJpc1JlamVjdGVkIiwiaXNGdWxmaWxsZWQiLCJpc1JlamVjdGVkV2l0aFZhbHVlIiwiaXNBc3luY1RodW5rQWN0aW9uIiwicHJlcGFyZUF1dG9CYXRjaGVkIiwiU0hPVUxEX0FVVE9CQVRDSCIsImlzUGxhaW5PYmplY3QiLCJuYW5vaWQiLCJjYWNoZSIsIldlYWtNYXAiLCJkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzIiwiY2FjaGVkIiwiZ2V0Iiwic3RyaW5naWZpZWQiLCJKU09OIiwic3RyaW5naWZ5Iiwia2V5IiwiT2JqZWN0Iiwia2V5cyIsInNvcnQiLCJyZWR1Y2UiLCJhY2MiLCJrZXkyIiwic2V0IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm5vUGVuZGluZ1F1ZXJ5U3RhdGVTZWxlY3RvciIsInNlbGVjdGVkIiwiaXNVbmluaXRpYWxpemVkIiwiaXNGZXRjaGluZyIsImlzTG9hZGluZyIsImRhdGEiLCJzdGF0dXMiLCJwZW5kaW5nIiwiYnVpbGRIb29rcyIsImFwaSIsIm1vZHVsZU9wdGlvbnMiLCJiYXRjaCIsImhvb2tzIiwidXNlRGlzcGF0Y2giLCJ1c2VTZWxlY3RvciIsInVzZVN0b3JlIiwidW5zdGFibGVfX3NpZGVFZmZlY3RzSW5SZW5kZXIiLCJzZXJpYWxpemVRdWVyeUFyZ3MiLCJjb250ZXh0IiwidXNlUG9zc2libHlJbW1lZGlhdGVFZmZlY3QiLCJjYiIsImJ1aWxkUXVlcnlIb29rcyIsImJ1aWxkTXV0YXRpb25Ib29rIiwidXNlUHJlZmV0Y2giLCJxdWVyeVN0YXRlUHJlU2VsZWN0b3IiLCJjdXJyZW50U3RhdGUiLCJsYXN0UmVzdWx0IiwiZW5kcG9pbnREZWZpbml0aW9ucyIsIm9yaWdpbmFsQXJncyIsImlzU3VjY2VzcyIsImhhc0RhdGEiLCJjdXJyZW50RGF0YSIsImRlZmF1bHRPcHRpb25zIiwiZGlzcGF0Y2giLCJzdGFibGVEZWZhdWx0T3B0aW9ucyIsImFyZyIsIm9wdGlvbnMiLCJ1dGlsIiwicHJlZmV0Y2giLCJuYW1lIiwidXNlUXVlcnlTdWJzY3JpcHRpb24iLCJyZWZldGNoT25SZWNvbm5lY3QiLCJyZWZldGNoT25Gb2N1cyIsInJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UiLCJza2lwIiwicG9sbGluZ0ludGVydmFsIiwiaW5pdGlhdGUiLCJlbmRwb2ludHMiLCJzdWJzY3JpcHRpb25TZWxlY3RvcnNSZWYiLCJyZXR1cm5lZFZhbHVlIiwiaW50ZXJuYWxBY3Rpb25zIiwiaW50ZXJuYWxfZ2V0UlRLUVN1YnNjcmlwdGlvbnMiLCJwcm9jZXNzIiwidHlwZSIsIkVycm9yIiwicmVkdWNlclBhdGgiLCJzdGFibGVBcmciLCJzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zIiwibGFzdFJlbmRlckhhZFN1YnNjcmlwdGlvbiIsInByb21pc2VSZWYiLCJxdWVyeUNhY2hlS2V5IiwicmVxdWVzdElkIiwiY3VycmVudFJlbmRlckhhc1N1YnNjcmlwdGlvbiIsImlzUmVxdWVzdFN1YnNjcmliZWQiLCJzdWJzY3JpcHRpb25SZW1vdmVkIiwibGFzdFByb21pc2UiLCJjb25zb2xlIiwibG9nIiwidW5zdWJzY3JpYmUiLCJsYXN0U3Vic2NyaXB0aW9uT3B0aW9ucyIsInN1YnNjcmlwdGlvbk9wdGlvbnMiLCJwcm9taXNlIiwiZm9yY2VSZWZldGNoIiwidXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyIsInJlZmV0Y2giLCJ1c2VMYXp5UXVlcnlTdWJzY3JpcHRpb24iLCJzZXRBcmciLCJzdWJzY3JpcHRpb25PcHRpb25zUmVmIiwidHJpZ2dlciIsImFyZzIiLCJwcmVmZXJDYWNoZVZhbHVlIiwidXNlUXVlcnlTdGF0ZSIsInNlbGVjdEZyb21SZXN1bHQiLCJzZWxlY3QiLCJsYXN0VmFsdWUiLCJzZWxlY3REZWZhdWx0UmVzdWx0IiwiXyIsInF1ZXJ5U2VsZWN0b3IiLCJkZXZNb2RlQ2hlY2tzIiwiaWRlbnRpdHlGdW5jdGlvbkNoZWNrIiwic3RhdGUiLCJzdG9yZSIsIm5ld0xhc3RWYWx1ZSIsImdldFN0YXRlIiwidXNlTGF6eVF1ZXJ5IiwicXVlcnlTdGF0ZVJlc3VsdHMiLCJpbmZvIiwibGFzdEFyZyIsInVzZVF1ZXJ5IiwicXVlcnlTdWJzY3JpcHRpb25SZXN1bHRzIiwiaXNFcnJvciIsImVycm9yIiwiZml4ZWRDYWNoZUtleSIsInNldFByb21pc2UiLCJyZXNldCIsInRyaWdnZXJNdXRhdGlvbiIsInByb21pc2UyIiwibXV0YXRpb25TZWxlY3RvciIsInJlbW92ZU11dGF0aW9uUmVzdWx0IiwiZmluYWxTdGF0ZSIsImlzUXVlcnlEZWZpbml0aW9uIiwiZSIsImlzTXV0YXRpb25EZWZpbml0aW9uIiwiY2FwaXRhbGl6ZSIsInN0ciIsInJlcGxhY2UiLCJ0b1VwcGVyQ2FzZSIsInNhZmVBc3NpZ24iLCJ0YXJnZXQiLCJhcmdzIiwiYXNzaWduIiwicnJVc2VEaXNwYXRjaCIsInJyVXNlU2VsZWN0b3IiLCJyclVzZVN0b3JlIiwicnJCYXRjaCIsImNvdW50T2JqZWN0S2V5cyIsIm9iaiIsImNvdW50IiwiX2tleSIsInJlYWN0SG9va3NNb2R1bGVOYW1lIiwicmVhY3RIb29rc01vZHVsZSIsInJlc3QiLCJob29rTmFtZXMiLCJ3YXJuZWQiLCJob29rTmFtZSIsIndhcm4iLCJsZW5ndGgiLCJqb2luIiwiaW5pdCIsImFueUFwaSIsImluamVjdEVuZHBvaW50IiwiZGVmaW5pdGlvbiIsInVzZU11dGF0aW9uIiwiX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U0IiwiY29uZmlndXJlU3RvcmUiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0NCIsIlJlYWN0IiwiUHJvdmlkZXIiLCJSZWFjdFJlZHV4Q29udGV4dCIsInNldHVwTGlzdGVuZXJzIiwiQXBpUHJvdmlkZXIiLCJwcm9wcyIsImV4aXN0aW5nQ29udGV4dCIsInJlZHVjZXIiLCJtaWRkbGV3YXJlIiwiZ0RNIiwiY29uY2F0IiwiY2hpbGRyZW4iLCJjcmVhdGVBcGkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryStatus: () => (/* binding */ QueryStatus),\n/* harmony export */   buildCreateApi: () => (/* binding */ buildCreateApi),\n/* harmony export */   copyWithStructuralSharing: () => (/* binding */ copyWithStructuralSharing),\n/* harmony export */   coreModule: () => (/* binding */ coreModule),\n/* harmony export */   coreModuleName: () => (/* binding */ coreModuleName),\n/* harmony export */   createApi: () => (/* binding */ createApi),\n/* harmony export */   defaultSerializeQueryArgs: () => (/* binding */ defaultSerializeQueryArgs),\n/* harmony export */   fakeBaseQuery: () => (/* binding */ fakeBaseQuery),\n/* harmony export */   fetchBaseQuery: () => (/* binding */ fetchBaseQuery),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   setupListeners: () => (/* binding */ setupListeners),\n/* harmony export */   skipToken: () => (/* binding */ skipToken)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n// src/query/core/apiState.ts\nvar QueryStatus = /* @__PURE__ */ ((QueryStatus2)=>{\n    QueryStatus2[\"uninitialized\"] = \"uninitialized\";\n    QueryStatus2[\"pending\"] = \"pending\";\n    QueryStatus2[\"fulfilled\"] = \"fulfilled\";\n    QueryStatus2[\"rejected\"] = \"rejected\";\n    return QueryStatus2;\n})(QueryStatus || {});\nfunction getRequestStatusFlags(status) {\n    return {\n        status,\n        isUninitialized: status === \"uninitialized\" /* uninitialized */ ,\n        isLoading: status === \"pending\" /* pending */ ,\n        isSuccess: status === \"fulfilled\" /* fulfilled */ ,\n        isError: status === \"rejected\" /* rejected */ \n    };\n}\n// src/query/utils/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n    return new RegExp(`(^|:)//`).test(url);\n}\n// src/query/utils/joinUrls.ts\nvar withoutTrailingSlash = (url)=>url.replace(/\\/$/, \"\");\nvar withoutLeadingSlash = (url)=>url.replace(/^\\//, \"\");\nfunction joinUrls(base, url) {\n    if (!base) {\n        return url;\n    }\n    if (!url) {\n        return base;\n    }\n    if (isAbsoluteUrl(url)) {\n        return url;\n    }\n    const delimiter = base.endsWith(\"/\") || !url.startsWith(\"?\") ? \"/\" : \"\";\n    base = withoutTrailingSlash(base);\n    url = withoutLeadingSlash(url);\n    return `${base}${delimiter}${url}`;\n}\n// src/query/utils/flatten.ts\nvar flatten = (arr)=>[].concat(...arr);\n// src/query/utils/isOnline.ts\nfunction isOnline() {\n    return typeof navigator === \"undefined\" ? true : navigator.onLine === void 0 ? true : navigator.onLine;\n}\n// src/query/utils/isDocumentVisible.ts\nfunction isDocumentVisible() {\n    if (typeof document === \"undefined\") {\n        return true;\n    }\n    return document.visibilityState !== \"hidden\";\n}\n// src/query/core/rtkImports.ts\n\n// src/query/utils/copyWithStructuralSharing.ts\nvar isPlainObject2 = _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject;\nfunction copyWithStructuralSharing(oldObj, newObj) {\n    if (oldObj === newObj || !(isPlainObject2(oldObj) && isPlainObject2(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {\n        return newObj;\n    }\n    const newKeys = Object.keys(newObj);\n    const oldKeys = Object.keys(oldObj);\n    let isSameObject = newKeys.length === oldKeys.length;\n    const mergeObj = Array.isArray(newObj) ? [] : {};\n    for (const key of newKeys){\n        mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);\n        if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];\n    }\n    return isSameObject ? oldObj : mergeObj;\n}\n// src/query/fetchBaseQuery.ts\nvar defaultFetchFn = (...args)=>fetch(...args);\nvar defaultValidateStatus = (response)=>response.status >= 200 && response.status <= 299;\nvar defaultIsJsonContentType = (headers)=>/*applicat*/ /ion\\/(vnd\\.api\\+)?json/.test(headers.get(\"content-type\") || \"\");\nfunction stripUndefined(obj) {\n    if (!(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(obj)) {\n        return obj;\n    }\n    const copy = {\n        ...obj\n    };\n    for (const [k, v] of Object.entries(copy)){\n        if (v === void 0) delete copy[k];\n    }\n    return copy;\n}\nfunction fetchBaseQuery({ baseUrl, prepareHeaders = (x)=>x, fetchFn = defaultFetchFn, paramsSerializer, isJsonContentType = defaultIsJsonContentType, jsonContentType = \"application/json\", jsonReplacer, timeout: defaultTimeout, responseHandler: globalResponseHandler, validateStatus: globalValidateStatus, ...baseFetchOptions } = {}) {\n    if (typeof fetch === \"undefined\" && fetchFn === defaultFetchFn) {\n        console.warn(\"Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.\");\n    }\n    return async (arg, api)=>{\n        const { signal, getState, extra, endpoint, forced, type } = api;\n        let meta;\n        let { url, headers = new Headers(baseFetchOptions.headers), params = void 0, responseHandler = globalResponseHandler ?? \"json\", validateStatus = globalValidateStatus ?? defaultValidateStatus, timeout = defaultTimeout, ...rest } = typeof arg == \"string\" ? {\n            url: arg\n        } : arg;\n        let config = {\n            ...baseFetchOptions,\n            signal,\n            ...rest\n        };\n        headers = new Headers(stripUndefined(headers));\n        config.headers = await prepareHeaders(headers, {\n            getState,\n            extra,\n            endpoint,\n            forced,\n            type\n        }) || headers;\n        const isJsonifiable = (body)=>typeof body === \"object\" && ((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(body) || Array.isArray(body) || typeof body.toJSON === \"function\");\n        if (!config.headers.has(\"content-type\") && isJsonifiable(config.body)) {\n            config.headers.set(\"content-type\", jsonContentType);\n        }\n        if (isJsonifiable(config.body) && isJsonContentType(config.headers)) {\n            config.body = JSON.stringify(config.body, jsonReplacer);\n        }\n        if (params) {\n            const divider = ~url.indexOf(\"?\") ? \"&\" : \"?\";\n            const query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));\n            url += divider + query;\n        }\n        url = joinUrls(baseUrl, url);\n        const request = new Request(url, config);\n        const requestClone = new Request(url, config);\n        meta = {\n            request: requestClone\n        };\n        let response, timedOut = false, timeoutId = timeout && setTimeout(()=>{\n            timedOut = true;\n            api.abort();\n        }, timeout);\n        try {\n            response = await fetchFn(request);\n        } catch (e) {\n            return {\n                error: {\n                    status: timedOut ? \"TIMEOUT_ERROR\" : \"FETCH_ERROR\",\n                    error: String(e)\n                },\n                meta\n            };\n        } finally{\n            if (timeoutId) clearTimeout(timeoutId);\n        }\n        const responseClone = response.clone();\n        meta.response = responseClone;\n        let resultData;\n        let responseText = \"\";\n        try {\n            let handleResponseError;\n            await Promise.all([\n                handleResponse(response, responseHandler).then((r)=>resultData = r, (e)=>handleResponseError = e),\n                // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182\n                // we *have* to \"use up\" both streams at the same time or they will stop running in node-fetch scenarios\n                responseClone.text().then((r)=>responseText = r, ()=>{})\n            ]);\n            if (handleResponseError) throw handleResponseError;\n        } catch (e) {\n            return {\n                error: {\n                    status: \"PARSING_ERROR\",\n                    originalStatus: response.status,\n                    data: responseText,\n                    error: String(e)\n                },\n                meta\n            };\n        }\n        return validateStatus(response, resultData) ? {\n            data: resultData,\n            meta\n        } : {\n            error: {\n                status: response.status,\n                data: resultData\n            },\n            meta\n        };\n    };\n    async function handleResponse(response, responseHandler) {\n        if (typeof responseHandler === \"function\") {\n            return responseHandler(response);\n        }\n        if (responseHandler === \"content-type\") {\n            responseHandler = isJsonContentType(response.headers) ? \"json\" : \"text\";\n        }\n        if (responseHandler === \"json\") {\n            const text = await response.text();\n            return text.length ? JSON.parse(text) : null;\n        }\n        return response.text();\n    }\n}\n// src/query/HandledError.ts\nvar HandledError = class {\n    constructor(value, meta = void 0){\n        this.value = value;\n        this.meta = meta;\n    }\n};\n// src/query/retry.ts\nasync function defaultBackoff(attempt = 0, maxRetries = 5) {\n    const attempts = Math.min(attempt, maxRetries);\n    const timeout = ~~((Math.random() + 0.4) * (300 << attempts));\n    await new Promise((resolve)=>setTimeout((res)=>resolve(res), timeout));\n}\nfunction fail(e) {\n    throw Object.assign(new HandledError({\n        error: e\n    }), {\n        throwImmediately: true\n    });\n}\nvar EMPTY_OPTIONS = {};\nvar retryWithBackoff = (baseQuery, defaultOptions)=>async (args, api, extraOptions)=>{\n        const possibleMaxRetries = [\n            5,\n            (defaultOptions || EMPTY_OPTIONS).maxRetries,\n            (extraOptions || EMPTY_OPTIONS).maxRetries\n        ].filter((x)=>x !== void 0);\n        const [maxRetries] = possibleMaxRetries.slice(-1);\n        const defaultRetryCondition = (_, __, { attempt })=>attempt <= maxRetries;\n        const options = {\n            maxRetries,\n            backoff: defaultBackoff,\n            retryCondition: defaultRetryCondition,\n            ...defaultOptions,\n            ...extraOptions\n        };\n        let retry2 = 0;\n        while(true){\n            try {\n                const result = await baseQuery(args, api, extraOptions);\n                if (result.error) {\n                    throw new HandledError(result);\n                }\n                return result;\n            } catch (e) {\n                retry2++;\n                if (e.throwImmediately) {\n                    if (e instanceof HandledError) {\n                        return e.value;\n                    }\n                    throw e;\n                }\n                if (e instanceof HandledError && !options.retryCondition(e.value.error, args, {\n                    attempt: retry2,\n                    baseQueryApi: api,\n                    extraOptions\n                })) {\n                    return e.value;\n                }\n                await options.backoff(retry2, options.maxRetries);\n            }\n        }\n    };\nvar retry = /* @__PURE__ */ Object.assign(retryWithBackoff, {\n    fail\n});\n// src/query/core/setupListeners.ts\nvar onFocus = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/focused\");\nvar onFocusLost = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/unfocused\");\nvar onOnline = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/online\");\nvar onOffline = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/offline\");\nvar initialized = false;\nfunction setupListeners(dispatch, customHandler) {\n    function defaultHandler() {\n        const handleFocus = ()=>dispatch(onFocus());\n        const handleFocusLost = ()=>dispatch(onFocusLost());\n        const handleOnline = ()=>dispatch(onOnline());\n        const handleOffline = ()=>dispatch(onOffline());\n        const handleVisibilityChange = ()=>{\n            if (window.document.visibilityState === \"visible\") {\n                handleFocus();\n            } else {\n                handleFocusLost();\n            }\n        };\n        if (!initialized) {\n            if (false) {}\n        }\n        const unsubscribe = ()=>{\n            window.removeEventListener(\"focus\", handleFocus);\n            window.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n            window.removeEventListener(\"online\", handleOnline);\n            window.removeEventListener(\"offline\", handleOffline);\n            initialized = false;\n        };\n        return unsubscribe;\n    }\n    return customHandler ? customHandler(dispatch, {\n        onFocus,\n        onFocusLost,\n        onOffline,\n        onOnline\n    }) : defaultHandler();\n}\n// src/query/endpointDefinitions.ts\nfunction isQueryDefinition(e) {\n    return e.type === \"query\" /* query */ ;\n}\nfunction isMutationDefinition(e) {\n    return e.type === \"mutation\" /* mutation */ ;\n}\nfunction calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {\n    if (isFunction(description)) {\n        return description(result, error, queryArg, meta).map(expandTagDescription).map(assertTagTypes);\n    }\n    if (Array.isArray(description)) {\n        return description.map(expandTagDescription).map(assertTagTypes);\n    }\n    return [];\n}\nfunction isFunction(t) {\n    return typeof t === \"function\";\n}\nfunction expandTagDescription(description) {\n    return typeof description === \"string\" ? {\n        type: description\n    } : description;\n}\n// src/query/core/buildInitiate.ts\n\n// src/query/utils/isNotNullish.ts\nfunction isNotNullish(v) {\n    return v != null;\n}\n// src/query/utils/countObjectKeys.ts\nfunction countObjectKeys(obj) {\n    let count = 0;\n    for(const _key in obj){\n        count++;\n    }\n    return count;\n}\n// src/query/core/buildInitiate.ts\nvar forceQueryFnSymbol = Symbol(\"forceQueryFn\");\nvar isUpsertQuery = (arg)=>typeof arg[forceQueryFnSymbol] === \"function\";\nfunction buildInitiate({ serializeQueryArgs, queryThunk, mutationThunk, api, context }) {\n    const runningQueries = /* @__PURE__ */ new Map();\n    const runningMutations = /* @__PURE__ */ new Map();\n    const { unsubscribeQueryResult, removeMutationResult, updateSubscriptionOptions } = api.internalActions;\n    return {\n        buildInitiateQuery,\n        buildInitiateMutation,\n        getRunningQueryThunk,\n        getRunningMutationThunk,\n        getRunningQueriesThunk,\n        getRunningMutationsThunk\n    };\n    function getRunningQueryThunk(endpointName, queryArgs) {\n        return (dispatch)=>{\n            const endpointDefinition = context.endpointDefinitions[endpointName];\n            const queryCacheKey = serializeQueryArgs({\n                queryArgs,\n                endpointDefinition,\n                endpointName\n            });\n            return runningQueries.get(dispatch)?.[queryCacheKey];\n        };\n    }\n    function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {\n        return (dispatch)=>{\n            return runningMutations.get(dispatch)?.[fixedCacheKeyOrRequestId];\n        };\n    }\n    function getRunningQueriesThunk() {\n        return (dispatch)=>Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);\n    }\n    function getRunningMutationsThunk() {\n        return (dispatch)=>Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);\n    }\n    function middlewareWarning(dispatch) {\n        if (true) {\n            if (middlewareWarning.triggered) return;\n            const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());\n            middlewareWarning.triggered = true;\n            if (typeof returnedValue !== \"object\" || typeof returnedValue?.type === \"string\") {\n                throw new Error( false ? 0 : `Warning: Middleware for RTK-Query API at reducerPath \"${api.reducerPath}\" has not been added to the store.\nYou must add the middleware for RTK-Query to function correctly!`);\n            }\n        }\n    }\n    function buildInitiateQuery(endpointName, endpointDefinition) {\n        const queryAction = (arg, { subscribe = true, forceRefetch, subscriptionOptions, [forceQueryFnSymbol]: forceQueryFn } = {})=>(dispatch, getState)=>{\n                const queryCacheKey = serializeQueryArgs({\n                    queryArgs: arg,\n                    endpointDefinition,\n                    endpointName\n                });\n                const thunk = queryThunk({\n                    type: \"query\",\n                    subscribe,\n                    forceRefetch,\n                    subscriptionOptions,\n                    endpointName,\n                    originalArgs: arg,\n                    queryCacheKey,\n                    [forceQueryFnSymbol]: forceQueryFn\n                });\n                const selector = api.endpoints[endpointName].select(arg);\n                const thunkResult = dispatch(thunk);\n                const stateAfter = selector(getState());\n                middlewareWarning(dispatch);\n                const { requestId, abort } = thunkResult;\n                const skippedSynchronously = stateAfter.requestId !== requestId;\n                const runningQuery = runningQueries.get(dispatch)?.[queryCacheKey];\n                const selectFromState = ()=>selector(getState());\n                const statePromise = Object.assign(forceQueryFn ? // a query has been forced (upsertQueryData)\n                // -> we want to resolve it once data has been written with the data that will be written\n                thunkResult.then(selectFromState) : skippedSynchronously && !runningQuery ? // a query has been skipped due to a condition and we do not have any currently running query\n                // -> we want to resolve it immediately with the current data\n                Promise.resolve(stateAfter) : // query just started or one is already in flight\n                // -> wait for the running query, then resolve with data from after that\n                Promise.all([\n                    runningQuery,\n                    thunkResult\n                ]).then(selectFromState), {\n                    arg,\n                    requestId,\n                    subscriptionOptions,\n                    queryCacheKey,\n                    abort,\n                    async unwrap () {\n                        const result = await statePromise;\n                        if (result.isError) {\n                            throw result.error;\n                        }\n                        return result.data;\n                    },\n                    refetch: ()=>dispatch(queryAction(arg, {\n                            subscribe: false,\n                            forceRefetch: true\n                        })),\n                    unsubscribe () {\n                        if (subscribe) dispatch(unsubscribeQueryResult({\n                            queryCacheKey,\n                            requestId\n                        }));\n                    },\n                    updateSubscriptionOptions (options) {\n                        statePromise.subscriptionOptions = options;\n                        dispatch(updateSubscriptionOptions({\n                            endpointName,\n                            requestId,\n                            queryCacheKey,\n                            options\n                        }));\n                    }\n                });\n                if (!runningQuery && !skippedSynchronously && !forceQueryFn) {\n                    const running = runningQueries.get(dispatch) || {};\n                    running[queryCacheKey] = statePromise;\n                    runningQueries.set(dispatch, running);\n                    statePromise.then(()=>{\n                        delete running[queryCacheKey];\n                        if (!countObjectKeys(running)) {\n                            runningQueries.delete(dispatch);\n                        }\n                    });\n                }\n                return statePromise;\n            };\n        return queryAction;\n    }\n    function buildInitiateMutation(endpointName) {\n        return (arg, { track = true, fixedCacheKey } = {})=>(dispatch, getState)=>{\n                const thunk = mutationThunk({\n                    type: \"mutation\",\n                    endpointName,\n                    originalArgs: arg,\n                    track,\n                    fixedCacheKey\n                });\n                const thunkResult = dispatch(thunk);\n                middlewareWarning(dispatch);\n                const { requestId, abort, unwrap } = thunkResult;\n                const returnValuePromise = thunkResult.unwrap().then((data)=>({\n                        data\n                    })).catch((error)=>({\n                        error\n                    }));\n                const reset = ()=>{\n                    dispatch(removeMutationResult({\n                        requestId,\n                        fixedCacheKey\n                    }));\n                };\n                const ret = Object.assign(returnValuePromise, {\n                    arg: thunkResult.arg,\n                    requestId,\n                    abort,\n                    unwrap,\n                    reset\n                });\n                const running = runningMutations.get(dispatch) || {};\n                runningMutations.set(dispatch, running);\n                running[requestId] = ret;\n                ret.then(()=>{\n                    delete running[requestId];\n                    if (!countObjectKeys(running)) {\n                        runningMutations.delete(dispatch);\n                    }\n                });\n                if (fixedCacheKey) {\n                    running[fixedCacheKey] = ret;\n                    ret.then(()=>{\n                        if (running[fixedCacheKey] === ret) {\n                            delete running[fixedCacheKey];\n                            if (!countObjectKeys(running)) {\n                                runningMutations.delete(dispatch);\n                            }\n                        }\n                    });\n                }\n                return ret;\n            };\n    }\n}\n// src/query/core/buildThunks.ts\n\nfunction defaultTransformResponse(baseQueryReturnValue) {\n    return baseQueryReturnValue;\n}\nfunction buildThunks({ reducerPath, baseQuery, context: { endpointDefinitions }, serializeQueryArgs, api, assertTagType }) {\n    const patchQueryData = (endpointName, args, patches, updateProvided)=>(dispatch, getState)=>{\n            const endpointDefinition = endpointDefinitions[endpointName];\n            const queryCacheKey = serializeQueryArgs({\n                queryArgs: args,\n                endpointDefinition,\n                endpointName\n            });\n            dispatch(api.internalActions.queryResultPatched({\n                queryCacheKey,\n                patches\n            }));\n            if (!updateProvided) {\n                return;\n            }\n            const newValue = api.endpoints[endpointName].select(args)(// Work around TS 4.1 mismatch\n            getState());\n            const providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, args, {}, assertTagType);\n            dispatch(api.internalActions.updateProvidedBy({\n                queryCacheKey,\n                providedTags\n            }));\n        };\n    const updateQueryData = (endpointName, args, updateRecipe, updateProvided = true)=>(dispatch, getState)=>{\n            const endpointDefinition = api.endpoints[endpointName];\n            const currentState = endpointDefinition.select(args)(// Work around TS 4.1 mismatch\n            getState());\n            let ret = {\n                patches: [],\n                inversePatches: [],\n                undo: ()=>dispatch(api.util.patchQueryData(endpointName, args, ret.inversePatches, updateProvided))\n            };\n            if (currentState.status === \"uninitialized\" /* uninitialized */ ) {\n                return ret;\n            }\n            let newValue;\n            if (\"data\" in currentState) {\n                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(currentState.data)) {\n                    const [value, patches, inversePatches] = (0,immer__WEBPACK_IMPORTED_MODULE_2__.produceWithPatches)(currentState.data, updateRecipe);\n                    ret.patches.push(...patches);\n                    ret.inversePatches.push(...inversePatches);\n                    newValue = value;\n                } else {\n                    newValue = updateRecipe(currentState.data);\n                    ret.patches.push({\n                        op: \"replace\",\n                        path: [],\n                        value: newValue\n                    });\n                    ret.inversePatches.push({\n                        op: \"replace\",\n                        path: [],\n                        value: currentState.data\n                    });\n                }\n            }\n            dispatch(api.util.patchQueryData(endpointName, args, ret.patches, updateProvided));\n            return ret;\n        };\n    const upsertQueryData = (endpointName, args, value)=>(dispatch)=>{\n            return dispatch(api.endpoints[endpointName].initiate(args, {\n                subscribe: false,\n                forceRefetch: true,\n                [forceQueryFnSymbol]: ()=>({\n                        data: value\n                    })\n            }));\n        };\n    const executeEndpoint = async (arg, { signal, abort, rejectWithValue, fulfillWithValue, dispatch, getState, extra })=>{\n        const endpointDefinition = endpointDefinitions[arg.endpointName];\n        try {\n            let transformResponse = defaultTransformResponse;\n            let result;\n            const baseQueryApi = {\n                signal,\n                abort,\n                dispatch,\n                getState,\n                extra,\n                endpoint: arg.endpointName,\n                type: arg.type,\n                forced: arg.type === \"query\" ? isForcedQuery(arg, getState()) : void 0\n            };\n            const forceQueryFn = arg.type === \"query\" ? arg[forceQueryFnSymbol] : void 0;\n            if (forceQueryFn) {\n                result = forceQueryFn();\n            } else if (endpointDefinition.query) {\n                result = await baseQuery(endpointDefinition.query(arg.originalArgs), baseQueryApi, endpointDefinition.extraOptions);\n                if (endpointDefinition.transformResponse) {\n                    transformResponse = endpointDefinition.transformResponse;\n                }\n            } else {\n                result = await endpointDefinition.queryFn(arg.originalArgs, baseQueryApi, endpointDefinition.extraOptions, (arg2)=>baseQuery(arg2, baseQueryApi, endpointDefinition.extraOptions));\n            }\n            if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n                const what = endpointDefinition.query ? \"`baseQuery`\" : \"`queryFn`\";\n                let err;\n                if (!result) {\n                    err = `${what} did not return anything.`;\n                } else if (typeof result !== \"object\") {\n                    err = `${what} did not return an object.`;\n                } else if (result.error && result.data) {\n                    err = `${what} returned an object containing both \\`error\\` and \\`result\\`.`;\n                } else if (result.error === void 0 && result.data === void 0) {\n                    err = `${what} returned an object containing neither a valid \\`error\\` and \\`result\\`. At least one of them should not be \\`undefined\\``;\n                } else {\n                    for (const key of Object.keys(result)){\n                        if (key !== \"error\" && key !== \"data\" && key !== \"meta\") {\n                            err = `The object returned by ${what} has the unknown property ${key}.`;\n                            break;\n                        }\n                    }\n                }\n                if (err) {\n                    console.error(`Error encountered handling the endpoint ${arg.endpointName}.\n              ${err}\n              It needs to return an object with either the shape \\`{ data: <value> }\\` or \\`{ error: <value> }\\` that may contain an optional \\`meta\\` property.\n              Object returned was:`, result);\n                }\n            }\n            if (result.error) throw new HandledError(result.error, result.meta);\n            return fulfillWithValue(await transformResponse(result.data, result.meta, arg.originalArgs), {\n                fulfilledTimeStamp: Date.now(),\n                baseQueryMeta: result.meta,\n                [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true\n            });\n        } catch (error) {\n            let catchedError = error;\n            if (catchedError instanceof HandledError) {\n                let transformErrorResponse = defaultTransformResponse;\n                if (endpointDefinition.query && endpointDefinition.transformErrorResponse) {\n                    transformErrorResponse = endpointDefinition.transformErrorResponse;\n                }\n                try {\n                    return rejectWithValue(await transformErrorResponse(catchedError.value, catchedError.meta, arg.originalArgs), {\n                        baseQueryMeta: catchedError.meta,\n                        [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true\n                    });\n                } catch (e) {\n                    catchedError = e;\n                }\n            }\n            if (typeof process !== \"undefined\" && \"development\" !== \"production\") {\n                console.error(`An unhandled error occurred processing a request for the endpoint \"${arg.endpointName}\".\nIn the case of an unhandled error, no tags will be \"provided\" or \"invalidated\".`, catchedError);\n            } else {\n                console.error(catchedError);\n            }\n            throw catchedError;\n        }\n    };\n    function isForcedQuery(arg, state) {\n        const requestState = state[reducerPath]?.queries?.[arg.queryCacheKey];\n        const baseFetchOnMountOrArgChange = state[reducerPath]?.config.refetchOnMountOrArgChange;\n        const fulfilledVal = requestState?.fulfilledTimeStamp;\n        const refetchVal = arg.forceRefetch ?? (arg.subscribe && baseFetchOnMountOrArgChange);\n        if (refetchVal) {\n            return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;\n        }\n        return false;\n    }\n    const queryThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAsyncThunk)(`${reducerPath}/executeQuery`, executeEndpoint, {\n        getPendingMeta () {\n            return {\n                startedTimeStamp: Date.now(),\n                [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true\n            };\n        },\n        condition (queryThunkArgs, { getState }) {\n            const state = getState();\n            const requestState = state[reducerPath]?.queries?.[queryThunkArgs.queryCacheKey];\n            const fulfilledVal = requestState?.fulfilledTimeStamp;\n            const currentArg = queryThunkArgs.originalArgs;\n            const previousArg = requestState?.originalArgs;\n            const endpointDefinition = endpointDefinitions[queryThunkArgs.endpointName];\n            if (isUpsertQuery(queryThunkArgs)) {\n                return true;\n            }\n            if (requestState?.status === \"pending\") {\n                return false;\n            }\n            if (isForcedQuery(queryThunkArgs, state)) {\n                return true;\n            }\n            if (isQueryDefinition(endpointDefinition) && endpointDefinition?.forceRefetch?.({\n                currentArg,\n                previousArg,\n                endpointState: requestState,\n                state\n            })) {\n                return true;\n            }\n            if (fulfilledVal) {\n                return false;\n            }\n            return true;\n        },\n        dispatchConditionRejection: true\n    });\n    const mutationThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAsyncThunk)(`${reducerPath}/executeMutation`, executeEndpoint, {\n        getPendingMeta () {\n            return {\n                startedTimeStamp: Date.now(),\n                [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true\n            };\n        }\n    });\n    const hasTheForce = (options)=>\"force\" in options;\n    const hasMaxAge = (options)=>\"ifOlderThan\" in options;\n    const prefetch = (endpointName, arg, options)=>(dispatch, getState)=>{\n            const force = hasTheForce(options) && options.force;\n            const maxAge = hasMaxAge(options) && options.ifOlderThan;\n            const queryAction = (force2 = true)=>api.endpoints[endpointName].initiate(arg, {\n                    forceRefetch: force2\n                });\n            const latestStateValue = api.endpoints[endpointName].select(arg)(getState());\n            if (force) {\n                dispatch(queryAction());\n            } else if (maxAge) {\n                const lastFulfilledTs = latestStateValue?.fulfilledTimeStamp;\n                if (!lastFulfilledTs) {\n                    dispatch(queryAction());\n                    return;\n                }\n                const shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;\n                if (shouldRetrigger) {\n                    dispatch(queryAction());\n                }\n            } else {\n                dispatch(queryAction(false));\n            }\n        };\n    function matchesEndpoint(endpointName) {\n        return (action)=>action?.meta?.arg?.endpointName === endpointName;\n    }\n    function buildMatchThunkActions(thunk, endpointName) {\n        return {\n            matchPending: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAllOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isPending)(thunk), matchesEndpoint(endpointName)),\n            matchFulfilled: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAllOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(thunk), matchesEndpoint(endpointName)),\n            matchRejected: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAllOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejected)(thunk), matchesEndpoint(endpointName))\n        };\n    }\n    return {\n        queryThunk,\n        mutationThunk,\n        prefetch,\n        updateQueryData,\n        upsertQueryData,\n        patchQueryData,\n        buildMatchThunkActions\n    };\n}\nfunction calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {\n    return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(action) ? action.payload : void 0, (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejectedWithValue)(action) ? action.payload : void 0, action.meta.arg.originalArgs, \"baseQueryMeta\" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);\n}\n// src/query/core/buildSlice.ts\n\n\nfunction updateQuerySubstateIfExists(state, queryCacheKey, update) {\n    const substate = state[queryCacheKey];\n    if (substate) {\n        update(substate);\n    }\n}\nfunction getMutationCacheKey(id) {\n    return (\"arg\" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) ?? id.requestId;\n}\nfunction updateMutationSubstateIfExists(state, id, update) {\n    const substate = state[getMutationCacheKey(id)];\n    if (substate) {\n        update(substate);\n    }\n}\nvar initialState = {};\nfunction buildSlice({ reducerPath, queryThunk, mutationThunk, context: { endpointDefinitions: definitions, apiUid, extractRehydrationInfo, hasRehydrationInfo }, assertTagType, config }) {\n    const resetApiState = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(`${reducerPath}/resetApiState`);\n    const querySlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n        name: `${reducerPath}/queries`,\n        initialState,\n        reducers: {\n            removeQueryResult: {\n                reducer (draft, { payload: { queryCacheKey } }) {\n                    delete draft[queryCacheKey];\n                },\n                prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n            },\n            queryResultPatched: {\n                reducer (draft, { payload: { queryCacheKey, patches } }) {\n                    updateQuerySubstateIfExists(draft, queryCacheKey, (substate)=>{\n                        substate.data = (0,immer__WEBPACK_IMPORTED_MODULE_2__.applyPatches)(substate.data, patches.concat());\n                    });\n                },\n                prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n            }\n        },\n        extraReducers (builder) {\n            builder.addCase(queryThunk.pending, (draft, { meta, meta: { arg } })=>{\n                const upserting = isUpsertQuery(arg);\n                draft[arg.queryCacheKey] ??= {\n                    status: \"uninitialized\" /* uninitialized */ ,\n                    endpointName: arg.endpointName\n                };\n                updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate)=>{\n                    substate.status = \"pending\" /* pending */ ;\n                    substate.requestId = upserting && substate.requestId ? // for `upsertQuery` **updates**, keep the current `requestId`\n                    substate.requestId : // for normal queries or `upsertQuery` **inserts** always update the `requestId`\n                    meta.requestId;\n                    if (arg.originalArgs !== void 0) {\n                        substate.originalArgs = arg.originalArgs;\n                    }\n                    substate.startedTimeStamp = meta.startedTimeStamp;\n                });\n            }).addCase(queryThunk.fulfilled, (draft, { meta, payload })=>{\n                updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, (substate)=>{\n                    if (substate.requestId !== meta.requestId && !isUpsertQuery(meta.arg)) return;\n                    const { merge } = definitions[meta.arg.endpointName];\n                    substate.status = \"fulfilled\" /* fulfilled */ ;\n                    if (merge) {\n                        if (substate.data !== void 0) {\n                            const { fulfilledTimeStamp, arg, baseQueryMeta, requestId } = meta;\n                            let newData = (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(substate.data, (draftSubstateData)=>{\n                                return merge(draftSubstateData, payload, {\n                                    arg: arg.originalArgs,\n                                    baseQueryMeta,\n                                    fulfilledTimeStamp,\n                                    requestId\n                                });\n                            });\n                            substate.data = newData;\n                        } else {\n                            substate.data = payload;\n                        }\n                    } else {\n                        substate.data = definitions[meta.arg.endpointName].structuralSharing ?? true ? copyWithStructuralSharing((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(substate.data) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.original)(substate.data) : substate.data, payload) : payload;\n                    }\n                    delete substate.error;\n                    substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n                });\n            }).addCase(queryThunk.rejected, (draft, { meta: { condition, arg, requestId }, error, payload })=>{\n                updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate)=>{\n                    if (condition) {} else {\n                        if (substate.requestId !== requestId) return;\n                        substate.status = \"rejected\" /* rejected */ ;\n                        substate.error = payload ?? error;\n                    }\n                });\n            }).addMatcher(hasRehydrationInfo, (draft, action)=>{\n                const { queries } = extractRehydrationInfo(action);\n                for (const [key, entry] of Object.entries(queries)){\n                    if (// do not rehydrate entries that were currently in flight.\n                    entry?.status === \"fulfilled\" /* fulfilled */  || entry?.status === \"rejected\" /* rejected */ ) {\n                        draft[key] = entry;\n                    }\n                }\n            });\n        }\n    });\n    const mutationSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n        name: `${reducerPath}/mutations`,\n        initialState,\n        reducers: {\n            removeMutationResult: {\n                reducer (draft, { payload }) {\n                    const cacheKey = getMutationCacheKey(payload);\n                    if (cacheKey in draft) {\n                        delete draft[cacheKey];\n                    }\n                },\n                prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n            }\n        },\n        extraReducers (builder) {\n            builder.addCase(mutationThunk.pending, (draft, { meta, meta: { requestId, arg, startedTimeStamp } })=>{\n                if (!arg.track) return;\n                draft[getMutationCacheKey(meta)] = {\n                    requestId,\n                    status: \"pending\" /* pending */ ,\n                    endpointName: arg.endpointName,\n                    startedTimeStamp\n                };\n            }).addCase(mutationThunk.fulfilled, (draft, { payload, meta })=>{\n                if (!meta.arg.track) return;\n                updateMutationSubstateIfExists(draft, meta, (substate)=>{\n                    if (substate.requestId !== meta.requestId) return;\n                    substate.status = \"fulfilled\" /* fulfilled */ ;\n                    substate.data = payload;\n                    substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n                });\n            }).addCase(mutationThunk.rejected, (draft, { payload, error, meta })=>{\n                if (!meta.arg.track) return;\n                updateMutationSubstateIfExists(draft, meta, (substate)=>{\n                    if (substate.requestId !== meta.requestId) return;\n                    substate.status = \"rejected\" /* rejected */ ;\n                    substate.error = payload ?? error;\n                });\n            }).addMatcher(hasRehydrationInfo, (draft, action)=>{\n                const { mutations } = extractRehydrationInfo(action);\n                for (const [key, entry] of Object.entries(mutations)){\n                    if (// do not rehydrate entries that were currently in flight.\n                    (entry?.status === \"fulfilled\" /* fulfilled */  || entry?.status === \"rejected\" /* rejected */ ) && // only rehydrate endpoints that were persisted using a `fixedCacheKey`\n                    key !== entry?.requestId) {\n                        draft[key] = entry;\n                    }\n                }\n            });\n        }\n    });\n    const invalidationSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n        name: `${reducerPath}/invalidation`,\n        initialState,\n        reducers: {\n            updateProvidedBy: {\n                reducer (draft, action) {\n                    const { queryCacheKey, providedTags } = action.payload;\n                    for (const tagTypeSubscriptions of Object.values(draft)){\n                        for (const idSubscriptions of Object.values(tagTypeSubscriptions)){\n                            const foundAt = idSubscriptions.indexOf(queryCacheKey);\n                            if (foundAt !== -1) {\n                                idSubscriptions.splice(foundAt, 1);\n                            }\n                        }\n                    }\n                    for (const { type, id } of providedTags){\n                        const subscribedQueries = (draft[type] ??= {})[id || \"__internal_without_id\"] ??= [];\n                        const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n                        if (!alreadySubscribed) {\n                            subscribedQueries.push(queryCacheKey);\n                        }\n                    }\n                },\n                prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n            }\n        },\n        extraReducers (builder) {\n            builder.addCase(querySlice.actions.removeQueryResult, (draft, { payload: { queryCacheKey } })=>{\n                for (const tagTypeSubscriptions of Object.values(draft)){\n                    for (const idSubscriptions of Object.values(tagTypeSubscriptions)){\n                        const foundAt = idSubscriptions.indexOf(queryCacheKey);\n                        if (foundAt !== -1) {\n                            idSubscriptions.splice(foundAt, 1);\n                        }\n                    }\n                }\n            }).addMatcher(hasRehydrationInfo, (draft, action)=>{\n                const { provided } = extractRehydrationInfo(action);\n                for (const [type, incomingTags] of Object.entries(provided)){\n                    for (const [id, cacheKeys] of Object.entries(incomingTags)){\n                        const subscribedQueries = (draft[type] ??= {})[id || \"__internal_without_id\"] ??= [];\n                        for (const queryCacheKey of cacheKeys){\n                            const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n                            if (!alreadySubscribed) {\n                                subscribedQueries.push(queryCacheKey);\n                            }\n                        }\n                    }\n                }\n            }).addMatcher((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(queryThunk), (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejectedWithValue)(queryThunk)), (draft, action)=>{\n                const providedTags = calculateProvidedByThunk(action, \"providesTags\", definitions, assertTagType);\n                const { queryCacheKey } = action.meta.arg;\n                invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy({\n                    queryCacheKey,\n                    providedTags\n                }));\n            });\n        }\n    });\n    const subscriptionSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n        name: `${reducerPath}/subscriptions`,\n        initialState,\n        reducers: {\n            updateSubscriptionOptions (d, a) {},\n            unsubscribeQueryResult (d, a) {},\n            internal_getRTKQSubscriptions () {}\n        }\n    });\n    const internalSubscriptionsSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n        name: `${reducerPath}/internalSubscriptions`,\n        initialState,\n        reducers: {\n            subscriptionsUpdated: {\n                reducer (state, action) {\n                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.applyPatches)(state, action.payload);\n                },\n                prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n            }\n        }\n    });\n    const configSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n        name: `${reducerPath}/config`,\n        initialState: {\n            online: isOnline(),\n            focused: isDocumentVisible(),\n            middlewareRegistered: false,\n            ...config\n        },\n        reducers: {\n            middlewareRegistered (state, { payload }) {\n                state.middlewareRegistered = state.middlewareRegistered === \"conflict\" || apiUid !== payload ? \"conflict\" : true;\n            }\n        },\n        extraReducers: (builder)=>{\n            builder.addCase(onOnline, (state)=>{\n                state.online = true;\n            }).addCase(onOffline, (state)=>{\n                state.online = false;\n            }).addCase(onFocus, (state)=>{\n                state.focused = true;\n            }).addCase(onFocusLost, (state)=>{\n                state.focused = false;\n            }).addMatcher(hasRehydrationInfo, (draft)=>({\n                    ...draft\n                }));\n        }\n    });\n    const combinedReducer = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.combineReducers)({\n        queries: querySlice.reducer,\n        mutations: mutationSlice.reducer,\n        provided: invalidationSlice.reducer,\n        subscriptions: internalSubscriptionsSlice.reducer,\n        config: configSlice.reducer\n    });\n    const reducer = (state, action)=>combinedReducer(resetApiState.match(action) ? void 0 : state, action);\n    const actions = {\n        ...configSlice.actions,\n        ...querySlice.actions,\n        ...subscriptionSlice.actions,\n        ...internalSubscriptionsSlice.actions,\n        ...mutationSlice.actions,\n        ...invalidationSlice.actions,\n        resetApiState\n    };\n    return {\n        reducer,\n        actions\n    };\n}\n// src/query/core/buildSelectors.ts\nvar skipToken = /* @__PURE__ */ Symbol.for(\"RTKQ/skipToken\");\nvar initialSubState = {\n    status: \"uninitialized\" /* uninitialized */ \n};\nvar defaultQuerySubState = /* @__PURE__ */ (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(initialSubState, ()=>{});\nvar defaultMutationSubState = /* @__PURE__ */ (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(initialSubState, ()=>{});\nfunction buildSelectors({ serializeQueryArgs, reducerPath }) {\n    const selectSkippedQuery = (state)=>defaultQuerySubState;\n    const selectSkippedMutation = (state)=>defaultMutationSubState;\n    return {\n        buildQuerySelector,\n        buildMutationSelector,\n        selectInvalidatedBy,\n        selectCachedArgsForQuery\n    };\n    function withRequestFlags(substate) {\n        return {\n            ...substate,\n            ...getRequestStatusFlags(substate.status)\n        };\n    }\n    function selectInternalState(rootState) {\n        const state = rootState[reducerPath];\n        if (true) {\n            if (!state) {\n                if (selectInternalState.triggered) return state;\n                selectInternalState.triggered = true;\n                console.error(`Error: No data found at \\`state.${reducerPath}\\`. Did you forget to add the reducer to the store?`);\n            }\n        }\n        return state;\n    }\n    function buildQuerySelector(endpointName, endpointDefinition) {\n        return (queryArgs)=>{\n            const serializedArgs = serializeQueryArgs({\n                queryArgs,\n                endpointDefinition,\n                endpointName\n            });\n            const selectQuerySubstate = (state)=>selectInternalState(state)?.queries?.[serializedArgs] ?? defaultQuerySubState;\n            const finalSelectQuerySubState = queryArgs === skipToken ? selectSkippedQuery : selectQuerySubstate;\n            return (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__.createSelector)(finalSelectQuerySubState, withRequestFlags);\n        };\n    }\n    function buildMutationSelector() {\n        return (id)=>{\n            let mutationId;\n            if (typeof id === \"object\") {\n                mutationId = getMutationCacheKey(id) ?? skipToken;\n            } else {\n                mutationId = id;\n            }\n            const selectMutationSubstate = (state)=>selectInternalState(state)?.mutations?.[mutationId] ?? defaultMutationSubState;\n            const finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;\n            return (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__.createSelector)(finalSelectMutationSubstate, withRequestFlags);\n        };\n    }\n    function selectInvalidatedBy(state, tags) {\n        const apiState = state[reducerPath];\n        const toInvalidate = /* @__PURE__ */ new Set();\n        for (const tag of tags.map(expandTagDescription)){\n            const provided = apiState.provided[tag.type];\n            if (!provided) {\n                continue;\n            }\n            let invalidateSubscriptions = (tag.id !== void 0 ? // id given: invalidate all queries that provide this type & id\n            provided[tag.id] : // no id: invalidate all queries that provide this type\n            flatten(Object.values(provided))) ?? [];\n            for (const invalidate of invalidateSubscriptions){\n                toInvalidate.add(invalidate);\n            }\n        }\n        return flatten(Array.from(toInvalidate.values()).map((queryCacheKey)=>{\n            const querySubState = apiState.queries[queryCacheKey];\n            return querySubState ? [\n                {\n                    queryCacheKey,\n                    endpointName: querySubState.endpointName,\n                    originalArgs: querySubState.originalArgs\n                }\n            ] : [];\n        }));\n    }\n    function selectCachedArgsForQuery(state, queryName) {\n        return Object.values(state[reducerPath].queries).filter((entry)=>entry?.endpointName === queryName && entry.status !== \"uninitialized\" /* uninitialized */ ).map((entry)=>entry.originalArgs);\n    }\n}\n// src/query/defaultSerializeQueryArgs.ts\nvar cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;\nvar defaultSerializeQueryArgs = ({ endpointName, queryArgs })=>{\n    let serialized = \"\";\n    const cached = cache?.get(queryArgs);\n    if (typeof cached === \"string\") {\n        serialized = cached;\n    } else {\n        const stringified = JSON.stringify(queryArgs, (key, value)=>(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) ? Object.keys(value).sort().reduce((acc, key2)=>{\n                acc[key2] = value[key2];\n                return acc;\n            }, {}) : value);\n        if ((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(queryArgs)) {\n            cache?.set(queryArgs, stringified);\n        }\n        serialized = stringified;\n    }\n    return `${endpointName}(${serialized})`;\n};\n// src/query/createApi.ts\n\nfunction buildCreateApi(...modules) {\n    return function baseCreateApi(options) {\n        const extractRehydrationInfo = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__.weakMapMemoize)((action)=>options.extractRehydrationInfo?.(action, {\n                reducerPath: options.reducerPath ?? \"api\"\n            }));\n        const optionsWithDefaults = {\n            reducerPath: \"api\",\n            keepUnusedDataFor: 60,\n            refetchOnMountOrArgChange: false,\n            refetchOnFocus: false,\n            refetchOnReconnect: false,\n            invalidationBehavior: \"delayed\",\n            ...options,\n            extractRehydrationInfo,\n            serializeQueryArgs (queryArgsApi) {\n                let finalSerializeQueryArgs = defaultSerializeQueryArgs;\n                if (\"serializeQueryArgs\" in queryArgsApi.endpointDefinition) {\n                    const endpointSQA = queryArgsApi.endpointDefinition.serializeQueryArgs;\n                    finalSerializeQueryArgs = (queryArgsApi2)=>{\n                        const initialResult = endpointSQA(queryArgsApi2);\n                        if (typeof initialResult === \"string\") {\n                            return initialResult;\n                        } else {\n                            return defaultSerializeQueryArgs({\n                                ...queryArgsApi2,\n                                queryArgs: initialResult\n                            });\n                        }\n                    };\n                } else if (options.serializeQueryArgs) {\n                    finalSerializeQueryArgs = options.serializeQueryArgs;\n                }\n                return finalSerializeQueryArgs(queryArgsApi);\n            },\n            tagTypes: [\n                ...options.tagTypes || []\n            ]\n        };\n        const context = {\n            endpointDefinitions: {},\n            batch (fn) {\n                fn();\n            },\n            apiUid: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.nanoid)(),\n            extractRehydrationInfo,\n            hasRehydrationInfo: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_3__.weakMapMemoize)((action)=>extractRehydrationInfo(action) != null)\n        };\n        const api = {\n            injectEndpoints,\n            enhanceEndpoints ({ addTagTypes, endpoints }) {\n                if (addTagTypes) {\n                    for (const eT of addTagTypes){\n                        if (!optionsWithDefaults.tagTypes.includes(eT)) {\n                            ;\n                            optionsWithDefaults.tagTypes.push(eT);\n                        }\n                    }\n                }\n                if (endpoints) {\n                    for (const [endpointName, partialDefinition] of Object.entries(endpoints)){\n                        if (typeof partialDefinition === \"function\") {\n                            partialDefinition(context.endpointDefinitions[endpointName]);\n                        } else {\n                            Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);\n                        }\n                    }\n                }\n                return api;\n            }\n        };\n        const initializedModules = modules.map((m)=>m.init(api, optionsWithDefaults, context));\n        function injectEndpoints(inject) {\n            const evaluatedEndpoints = inject.endpoints({\n                query: (x)=>({\n                        ...x,\n                        type: \"query\" /* query */ \n                    }),\n                mutation: (x)=>({\n                        ...x,\n                        type: \"mutation\" /* mutation */ \n                    })\n            });\n            for (const [endpointName, definition] of Object.entries(evaluatedEndpoints)){\n                if (!inject.overrideExisting && endpointName in context.endpointDefinitions) {\n                    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n                        console.error(`called \\`injectEndpoints\\` to override already-existing endpointName ${endpointName} without specifying \\`overrideExisting: true\\``);\n                    }\n                    continue;\n                }\n                context.endpointDefinitions[endpointName] = definition;\n                for (const m of initializedModules){\n                    m.injectEndpoint(endpointName, definition);\n                }\n            }\n            return api;\n        }\n        return api.injectEndpoints({\n            endpoints: options.endpoints\n        });\n    };\n}\n// src/query/fakeBaseQuery.ts\n\nfunction fakeBaseQuery() {\n    return function() {\n        throw new Error( false ? 0 : \"When using `fakeBaseQuery`, all queries & mutations must use the `queryFn` definition syntax.\");\n    };\n}\n// src/query/core/buildMiddleware/cacheCollection.ts\nfunction isObjectEmpty(obj) {\n    for(let k in obj){\n        return false;\n    }\n    return true;\n}\nvar THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;\nvar buildCacheCollectionHandler = ({ reducerPath, api, context, internalState })=>{\n    const { removeQueryResult, unsubscribeQueryResult } = api.internalActions;\n    function anySubscriptionsRemainingForKey(queryCacheKey) {\n        const subscriptions = internalState.currentSubscriptions[queryCacheKey];\n        return !!subscriptions && !isObjectEmpty(subscriptions);\n    }\n    const currentRemovalTimeouts = {};\n    const handler = (action, mwApi, internalState2)=>{\n        if (unsubscribeQueryResult.match(action)) {\n            const state = mwApi.getState()[reducerPath];\n            const { queryCacheKey } = action.payload;\n            handleUnsubscribe(queryCacheKey, state.queries[queryCacheKey]?.endpointName, mwApi, state.config);\n        }\n        if (api.util.resetApiState.match(action)) {\n            for (const [key, timeout] of Object.entries(currentRemovalTimeouts)){\n                if (timeout) clearTimeout(timeout);\n                delete currentRemovalTimeouts[key];\n            }\n        }\n        if (context.hasRehydrationInfo(action)) {\n            const state = mwApi.getState()[reducerPath];\n            const { queries } = context.extractRehydrationInfo(action);\n            for (const [queryCacheKey, queryState] of Object.entries(queries)){\n                handleUnsubscribe(queryCacheKey, queryState?.endpointName, mwApi, state.config);\n            }\n        }\n    };\n    function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {\n        const endpointDefinition = context.endpointDefinitions[endpointName];\n        const keepUnusedDataFor = endpointDefinition?.keepUnusedDataFor ?? config.keepUnusedDataFor;\n        if (keepUnusedDataFor === Infinity) {\n            return;\n        }\n        const finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));\n        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n            const currentTimeout = currentRemovalTimeouts[queryCacheKey];\n            if (currentTimeout) {\n                clearTimeout(currentTimeout);\n            }\n            currentRemovalTimeouts[queryCacheKey] = setTimeout(()=>{\n                if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n                    api2.dispatch(removeQueryResult({\n                        queryCacheKey\n                    }));\n                }\n                delete currentRemovalTimeouts[queryCacheKey];\n            }, finalKeepUnusedDataFor * 1e3);\n        }\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/invalidationByTags.ts\nvar buildInvalidationByTagsHandler = ({ reducerPath, context, context: { endpointDefinitions }, mutationThunk, queryThunk, api, assertTagType, refetchQuery, internalState })=>{\n    const { removeQueryResult } = api.internalActions;\n    const isThunkActionWithTags = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(mutationThunk), (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejectedWithValue)(mutationThunk));\n    const isQueryEnd = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(mutationThunk, queryThunk), (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejected)(mutationThunk, queryThunk));\n    let pendingTagInvalidations = [];\n    const handler = (action, mwApi)=>{\n        if (isThunkActionWithTags(action)) {\n            invalidateTags(calculateProvidedByThunk(action, \"invalidatesTags\", endpointDefinitions, assertTagType), mwApi);\n        } else if (isQueryEnd(action)) {\n            invalidateTags([], mwApi);\n        } else if (api.util.invalidateTags.match(action)) {\n            invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);\n        }\n    };\n    function hasPendingRequests(state) {\n        for(const key in state.queries){\n            if (state.queries[key]?.status === \"pending\" /* pending */ ) return true;\n        }\n        for(const key in state.mutations){\n            if (state.mutations[key]?.status === \"pending\" /* pending */ ) return true;\n        }\n        return false;\n    }\n    function invalidateTags(newTags, mwApi) {\n        const rootState = mwApi.getState();\n        const state = rootState[reducerPath];\n        pendingTagInvalidations.push(...newTags);\n        if (state.config.invalidationBehavior === \"delayed\" && hasPendingRequests(state)) {\n            return;\n        }\n        const tags = pendingTagInvalidations;\n        pendingTagInvalidations = [];\n        if (tags.length === 0) return;\n        const toInvalidate = api.util.selectInvalidatedBy(rootState, tags);\n        context.batch(()=>{\n            const valuesArray = Array.from(toInvalidate.values());\n            for (const { queryCacheKey } of valuesArray){\n                const querySubState = state.queries[queryCacheKey];\n                const subscriptionSubState = internalState.currentSubscriptions[queryCacheKey] ?? {};\n                if (querySubState) {\n                    if (countObjectKeys(subscriptionSubState) === 0) {\n                        mwApi.dispatch(removeQueryResult({\n                            queryCacheKey\n                        }));\n                    } else if (querySubState.status !== \"uninitialized\" /* uninitialized */ ) {\n                        mwApi.dispatch(refetchQuery(querySubState, queryCacheKey));\n                    }\n                }\n            }\n        });\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/polling.ts\nvar buildPollingHandler = ({ reducerPath, queryThunk, api, refetchQuery, internalState })=>{\n    const currentPolls = {};\n    const handler = (action, mwApi)=>{\n        if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {\n            updatePollingInterval(action.payload, mwApi);\n        }\n        if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {\n            updatePollingInterval(action.meta.arg, mwApi);\n        }\n        if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {\n            startNextPoll(action.meta.arg, mwApi);\n        }\n        if (api.util.resetApiState.match(action)) {\n            clearPolls();\n        }\n    };\n    function startNextPoll({ queryCacheKey }, api2) {\n        const state = api2.getState()[reducerPath];\n        const querySubState = state.queries[queryCacheKey];\n        const subscriptions = internalState.currentSubscriptions[queryCacheKey];\n        if (!querySubState || querySubState.status === \"uninitialized\" /* uninitialized */ ) return;\n        const lowestPollingInterval = findLowestPollingInterval(subscriptions);\n        if (!Number.isFinite(lowestPollingInterval)) return;\n        const currentPoll = currentPolls[queryCacheKey];\n        if (currentPoll?.timeout) {\n            clearTimeout(currentPoll.timeout);\n            currentPoll.timeout = void 0;\n        }\n        const nextPollTimestamp = Date.now() + lowestPollingInterval;\n        const currentInterval = currentPolls[queryCacheKey] = {\n            nextPollTimestamp,\n            pollingInterval: lowestPollingInterval,\n            timeout: setTimeout(()=>{\n                currentInterval.timeout = void 0;\n                api2.dispatch(refetchQuery(querySubState, queryCacheKey));\n            }, lowestPollingInterval)\n        };\n    }\n    function updatePollingInterval({ queryCacheKey }, api2) {\n        const state = api2.getState()[reducerPath];\n        const querySubState = state.queries[queryCacheKey];\n        const subscriptions = internalState.currentSubscriptions[queryCacheKey];\n        if (!querySubState || querySubState.status === \"uninitialized\" /* uninitialized */ ) {\n            return;\n        }\n        const lowestPollingInterval = findLowestPollingInterval(subscriptions);\n        if (!Number.isFinite(lowestPollingInterval)) {\n            cleanupPollForKey(queryCacheKey);\n            return;\n        }\n        const currentPoll = currentPolls[queryCacheKey];\n        const nextPollTimestamp = Date.now() + lowestPollingInterval;\n        if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {\n            startNextPoll({\n                queryCacheKey\n            }, api2);\n        }\n    }\n    function cleanupPollForKey(key) {\n        const existingPoll = currentPolls[key];\n        if (existingPoll?.timeout) {\n            clearTimeout(existingPoll.timeout);\n        }\n        delete currentPolls[key];\n    }\n    function clearPolls() {\n        for (const key of Object.keys(currentPolls)){\n            cleanupPollForKey(key);\n        }\n    }\n    function findLowestPollingInterval(subscribers = {}) {\n        let lowestPollingInterval = Number.POSITIVE_INFINITY;\n        for(let key in subscribers){\n            if (!!subscribers[key].pollingInterval) {\n                lowestPollingInterval = Math.min(subscribers[key].pollingInterval, lowestPollingInterval);\n            }\n        }\n        return lowestPollingInterval;\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/windowEventHandling.ts\nvar buildWindowEventHandler = ({ reducerPath, context, api, refetchQuery, internalState })=>{\n    const { removeQueryResult } = api.internalActions;\n    const handler = (action, mwApi)=>{\n        if (onFocus.match(action)) {\n            refetchValidQueries(mwApi, \"refetchOnFocus\");\n        }\n        if (onOnline.match(action)) {\n            refetchValidQueries(mwApi, \"refetchOnReconnect\");\n        }\n    };\n    function refetchValidQueries(api2, type) {\n        const state = api2.getState()[reducerPath];\n        const queries = state.queries;\n        const subscriptions = internalState.currentSubscriptions;\n        context.batch(()=>{\n            for (const queryCacheKey of Object.keys(subscriptions)){\n                const querySubState = queries[queryCacheKey];\n                const subscriptionSubState = subscriptions[queryCacheKey];\n                if (!subscriptionSubState || !querySubState) continue;\n                const shouldRefetch = Object.values(subscriptionSubState).some((sub)=>sub[type] === true) || Object.values(subscriptionSubState).every((sub)=>sub[type] === void 0) && state.config[type];\n                if (shouldRefetch) {\n                    if (countObjectKeys(subscriptionSubState) === 0) {\n                        api2.dispatch(removeQueryResult({\n                            queryCacheKey\n                        }));\n                    } else if (querySubState.status !== \"uninitialized\" /* uninitialized */ ) {\n                        api2.dispatch(refetchQuery(querySubState, queryCacheKey));\n                    }\n                }\n            }\n        });\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/cacheLifecycle.ts\nvar neverResolvedError = new Error(\"Promise never resolved before cacheEntryRemoved.\");\nvar buildCacheLifecycleHandler = ({ api, reducerPath, context, queryThunk, mutationThunk, internalState })=>{\n    const isQueryThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAsyncThunkAction)(queryThunk);\n    const isMutationThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAsyncThunkAction)(mutationThunk);\n    const isFulfilledThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(queryThunk, mutationThunk);\n    const lifecycleMap = {};\n    const handler = (action, mwApi, stateBefore)=>{\n        const cacheKey = getCacheKey(action);\n        if (queryThunk.pending.match(action)) {\n            const oldState = stateBefore[reducerPath].queries[cacheKey];\n            const state = mwApi.getState()[reducerPath].queries[cacheKey];\n            if (!oldState && state) {\n                handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);\n            }\n        } else if (mutationThunk.pending.match(action)) {\n            const state = mwApi.getState()[reducerPath].mutations[cacheKey];\n            if (state) {\n                handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);\n            }\n        } else if (isFulfilledThunk(action)) {\n            const lifecycle = lifecycleMap[cacheKey];\n            if (lifecycle?.valueResolved) {\n                lifecycle.valueResolved({\n                    data: action.payload,\n                    meta: action.meta.baseQueryMeta\n                });\n                delete lifecycle.valueResolved;\n            }\n        } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {\n            const lifecycle = lifecycleMap[cacheKey];\n            if (lifecycle) {\n                delete lifecycleMap[cacheKey];\n                lifecycle.cacheEntryRemoved();\n            }\n        } else if (api.util.resetApiState.match(action)) {\n            for (const [cacheKey2, lifecycle] of Object.entries(lifecycleMap)){\n                delete lifecycleMap[cacheKey2];\n                lifecycle.cacheEntryRemoved();\n            }\n        }\n    };\n    function getCacheKey(action) {\n        if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;\n        if (isMutationThunk(action)) return action.meta.requestId;\n        if (api.internalActions.removeQueryResult.match(action)) return action.payload.queryCacheKey;\n        if (api.internalActions.removeMutationResult.match(action)) return getMutationCacheKey(action.payload);\n        return \"\";\n    }\n    function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {\n        const endpointDefinition = context.endpointDefinitions[endpointName];\n        const onCacheEntryAdded = endpointDefinition?.onCacheEntryAdded;\n        if (!onCacheEntryAdded) return;\n        let lifecycle = {};\n        const cacheEntryRemoved = new Promise((resolve)=>{\n            lifecycle.cacheEntryRemoved = resolve;\n        });\n        const cacheDataLoaded = Promise.race([\n            new Promise((resolve)=>{\n                lifecycle.valueResolved = resolve;\n            }),\n            cacheEntryRemoved.then(()=>{\n                throw neverResolvedError;\n            })\n        ]);\n        cacheDataLoaded.catch(()=>{});\n        lifecycleMap[queryCacheKey] = lifecycle;\n        const selector = api.endpoints[endpointName].select(endpointDefinition.type === \"query\" /* query */  ? originalArgs : queryCacheKey);\n        const extra = mwApi.dispatch((_, __, extra2)=>extra2);\n        const lifecycleApi = {\n            ...mwApi,\n            getCacheEntry: ()=>selector(mwApi.getState()),\n            requestId,\n            extra,\n            updateCachedData: endpointDefinition.type === \"query\" /* query */  ? (updateRecipe)=>mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\n            cacheDataLoaded,\n            cacheEntryRemoved\n        };\n        const runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);\n        Promise.resolve(runningHandler).catch((e)=>{\n            if (e === neverResolvedError) return;\n            throw e;\n        });\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/queryLifecycle.ts\nvar buildQueryLifecycleHandler = ({ api, context, queryThunk, mutationThunk })=>{\n    const isPendingThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isPending)(queryThunk, mutationThunk);\n    const isRejectedThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejected)(queryThunk, mutationThunk);\n    const isFullfilledThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(queryThunk, mutationThunk);\n    const lifecycleMap = {};\n    const handler = (action, mwApi)=>{\n        if (isPendingThunk(action)) {\n            const { requestId, arg: { endpointName, originalArgs } } = action.meta;\n            const endpointDefinition = context.endpointDefinitions[endpointName];\n            const onQueryStarted = endpointDefinition?.onQueryStarted;\n            if (onQueryStarted) {\n                const lifecycle = {};\n                const queryFulfilled = new Promise((resolve, reject)=>{\n                    lifecycle.resolve = resolve;\n                    lifecycle.reject = reject;\n                });\n                queryFulfilled.catch(()=>{});\n                lifecycleMap[requestId] = lifecycle;\n                const selector = api.endpoints[endpointName].select(endpointDefinition.type === \"query\" /* query */  ? originalArgs : requestId);\n                const extra = mwApi.dispatch((_, __, extra2)=>extra2);\n                const lifecycleApi = {\n                    ...mwApi,\n                    getCacheEntry: ()=>selector(mwApi.getState()),\n                    requestId,\n                    extra,\n                    updateCachedData: endpointDefinition.type === \"query\" /* query */  ? (updateRecipe)=>mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\n                    queryFulfilled\n                };\n                onQueryStarted(originalArgs, lifecycleApi);\n            }\n        } else if (isFullfilledThunk(action)) {\n            const { requestId, baseQueryMeta } = action.meta;\n            lifecycleMap[requestId]?.resolve({\n                data: action.payload,\n                meta: baseQueryMeta\n            });\n            delete lifecycleMap[requestId];\n        } else if (isRejectedThunk(action)) {\n            const { requestId, rejectedWithValue, baseQueryMeta } = action.meta;\n            lifecycleMap[requestId]?.reject({\n                error: action.payload ?? action.error,\n                isUnhandledError: !rejectedWithValue,\n                meta: baseQueryMeta\n            });\n            delete lifecycleMap[requestId];\n        }\n    };\n    return handler;\n};\n// src/query/core/buildMiddleware/devMiddleware.ts\nvar buildDevCheckHandler = ({ api, context: { apiUid }, reducerPath })=>{\n    return (action, mwApi)=>{\n        if (api.util.resetApiState.match(action)) {\n            mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n        }\n        if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n            if (api.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && mwApi.getState()[reducerPath]?.config?.middlewareRegistered === \"conflict\") {\n                console.warn(`There is a mismatch between slice and middleware for the reducerPath \"${reducerPath}\".\nYou can only have one api per reducer path, this will lead to crashes in various situations!${reducerPath === \"api\" ? `\nIf you have multiple apis, you *have* to specify the reducerPath option when using createApi!` : \"\"}`);\n            }\n        }\n    };\n};\n// src/query/core/buildMiddleware/batchActions.ts\n\nvar buildBatchedActionsHandler = ({ api, queryThunk, internalState })=>{\n    const subscriptionsPrefix = `${api.reducerPath}/subscriptions`;\n    let previousSubscriptions = null;\n    let updateSyncTimer = null;\n    const { updateSubscriptionOptions, unsubscribeQueryResult } = api.internalActions;\n    const actuallyMutateSubscriptions = (mutableState, action)=>{\n        if (updateSubscriptionOptions.match(action)) {\n            const { queryCacheKey, requestId, options } = action.payload;\n            if (mutableState?.[queryCacheKey]?.[requestId]) {\n                mutableState[queryCacheKey][requestId] = options;\n            }\n            return true;\n        }\n        if (unsubscribeQueryResult.match(action)) {\n            const { queryCacheKey, requestId } = action.payload;\n            if (mutableState[queryCacheKey]) {\n                delete mutableState[queryCacheKey][requestId];\n            }\n            return true;\n        }\n        if (api.internalActions.removeQueryResult.match(action)) {\n            delete mutableState[action.payload.queryCacheKey];\n            return true;\n        }\n        if (queryThunk.pending.match(action)) {\n            const { meta: { arg, requestId } } = action;\n            const substate = mutableState[arg.queryCacheKey] ??= {};\n            substate[`${requestId}_running`] = {};\n            if (arg.subscribe) {\n                substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};\n            }\n            return true;\n        }\n        let mutated = false;\n        if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action)) {\n            const state = mutableState[action.meta.arg.queryCacheKey] || {};\n            const key = `${action.meta.requestId}_running`;\n            mutated ||= !!state[key];\n            delete state[key];\n        }\n        if (queryThunk.rejected.match(action)) {\n            const { meta: { condition, arg, requestId } } = action;\n            if (condition && arg.subscribe) {\n                const substate = mutableState[arg.queryCacheKey] ??= {};\n                substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};\n                mutated = true;\n            }\n        }\n        return mutated;\n    };\n    const getSubscriptions = ()=>internalState.currentSubscriptions;\n    const getSubscriptionCount = (queryCacheKey)=>{\n        const subscriptions = getSubscriptions();\n        const subscriptionsForQueryArg = subscriptions[queryCacheKey] ?? {};\n        return countObjectKeys(subscriptionsForQueryArg);\n    };\n    const isRequestSubscribed = (queryCacheKey, requestId)=>{\n        const subscriptions = getSubscriptions();\n        return !!subscriptions?.[queryCacheKey]?.[requestId];\n    };\n    const subscriptionSelectors = {\n        getSubscriptions,\n        getSubscriptionCount,\n        isRequestSubscribed\n    };\n    return (action, mwApi)=>{\n        if (!previousSubscriptions) {\n            previousSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));\n        }\n        if (api.util.resetApiState.match(action)) {\n            previousSubscriptions = internalState.currentSubscriptions = {};\n            updateSyncTimer = null;\n            return [\n                true,\n                false\n            ];\n        }\n        if (api.internalActions.internal_getRTKQSubscriptions.match(action)) {\n            return [\n                false,\n                subscriptionSelectors\n            ];\n        }\n        const didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);\n        let actionShouldContinue = true;\n        if (didMutate) {\n            if (!updateSyncTimer) {\n                updateSyncTimer = setTimeout(()=>{\n                    const newSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));\n                    const [, patches] = (0,immer__WEBPACK_IMPORTED_MODULE_2__.produceWithPatches)(previousSubscriptions, ()=>newSubscriptions);\n                    mwApi.next(api.internalActions.subscriptionsUpdated(patches));\n                    previousSubscriptions = newSubscriptions;\n                    updateSyncTimer = null;\n                }, 500);\n            }\n            const isSubscriptionSliceAction = typeof action.type == \"string\" && !!action.type.startsWith(subscriptionsPrefix);\n            const isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;\n            actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;\n        }\n        return [\n            actionShouldContinue,\n            false\n        ];\n    };\n};\n// src/query/core/buildMiddleware/index.ts\nfunction buildMiddleware(input) {\n    const { reducerPath, queryThunk, api, context } = input;\n    const { apiUid } = context;\n    const actions = {\n        invalidateTags: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(`${reducerPath}/invalidateTags`)\n    };\n    const isThisApiSliceAction = (action)=>action.type.startsWith(`${reducerPath}/`);\n    const handlerBuilders = [\n        buildDevCheckHandler,\n        buildCacheCollectionHandler,\n        buildInvalidationByTagsHandler,\n        buildPollingHandler,\n        buildCacheLifecycleHandler,\n        buildQueryLifecycleHandler\n    ];\n    const middleware = (mwApi)=>{\n        let initialized2 = false;\n        let internalState = {\n            currentSubscriptions: {}\n        };\n        const builderArgs = {\n            ...input,\n            internalState,\n            refetchQuery,\n            isThisApiSliceAction\n        };\n        const handlers = handlerBuilders.map((build)=>build(builderArgs));\n        const batchedActionsHandler = buildBatchedActionsHandler(builderArgs);\n        const windowEventsHandler = buildWindowEventHandler(builderArgs);\n        return (next)=>{\n            return (action)=>{\n                if (!(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                    return next(action);\n                }\n                if (!initialized2) {\n                    initialized2 = true;\n                    mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n                }\n                const mwApiWithNext = {\n                    ...mwApi,\n                    next\n                };\n                const stateBefore = mwApi.getState();\n                const [actionShouldContinue, internalProbeResult] = batchedActionsHandler(action, mwApiWithNext, stateBefore);\n                let res;\n                if (actionShouldContinue) {\n                    res = next(action);\n                } else {\n                    res = internalProbeResult;\n                }\n                if (!!mwApi.getState()[reducerPath]) {\n                    windowEventsHandler(action, mwApiWithNext, stateBefore);\n                    if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {\n                        for (let handler of handlers){\n                            handler(action, mwApiWithNext, stateBefore);\n                        }\n                    }\n                }\n                return res;\n            };\n        };\n    };\n    return {\n        middleware,\n        actions\n    };\n    function refetchQuery(querySubState, queryCacheKey, override = {}) {\n        return queryThunk({\n            type: \"query\",\n            endpointName: querySubState.endpointName,\n            originalArgs: querySubState.originalArgs,\n            subscribe: false,\n            forceRefetch: true,\n            queryCacheKey,\n            ...override\n        });\n    }\n}\n// src/query/tsHelpers.ts\nfunction assertCast(v) {}\nfunction safeAssign(target, ...args) {\n    return Object.assign(target, ...args);\n}\n// src/query/core/module.ts\n\nvar coreModuleName = /* @__PURE__ */ Symbol();\nvar coreModule = ()=>({\n        name: coreModuleName,\n        init (api, { baseQuery, tagTypes, reducerPath, serializeQueryArgs, keepUnusedDataFor, refetchOnMountOrArgChange, refetchOnFocus, refetchOnReconnect, invalidationBehavior }, context) {\n            (0,immer__WEBPACK_IMPORTED_MODULE_2__.enablePatches)();\n            assertCast(serializeQueryArgs);\n            const assertTagType = (tag)=>{\n                if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n                    if (!tagTypes.includes(tag.type)) {\n                        console.error(`Tag type '${tag.type}' was used, but not specified in \\`tagTypes\\`!`);\n                    }\n                }\n                return tag;\n            };\n            Object.assign(api, {\n                reducerPath,\n                endpoints: {},\n                internalActions: {\n                    onOnline,\n                    onOffline,\n                    onFocus,\n                    onFocusLost\n                },\n                util: {}\n            });\n            const { queryThunk, mutationThunk, patchQueryData, updateQueryData, upsertQueryData, prefetch, buildMatchThunkActions } = buildThunks({\n                baseQuery,\n                reducerPath,\n                context,\n                api,\n                serializeQueryArgs,\n                assertTagType\n            });\n            const { reducer, actions: sliceActions } = buildSlice({\n                context,\n                queryThunk,\n                mutationThunk,\n                reducerPath,\n                assertTagType,\n                config: {\n                    refetchOnFocus,\n                    refetchOnReconnect,\n                    refetchOnMountOrArgChange,\n                    keepUnusedDataFor,\n                    reducerPath,\n                    invalidationBehavior\n                }\n            });\n            safeAssign(api.util, {\n                patchQueryData,\n                updateQueryData,\n                upsertQueryData,\n                prefetch,\n                resetApiState: sliceActions.resetApiState\n            });\n            safeAssign(api.internalActions, sliceActions);\n            const { middleware, actions: middlewareActions } = buildMiddleware({\n                reducerPath,\n                context,\n                queryThunk,\n                mutationThunk,\n                api,\n                assertTagType\n            });\n            safeAssign(api.util, middlewareActions);\n            safeAssign(api, {\n                reducer,\n                middleware\n            });\n            const { buildQuerySelector, buildMutationSelector, selectInvalidatedBy, selectCachedArgsForQuery } = buildSelectors({\n                serializeQueryArgs,\n                reducerPath\n            });\n            safeAssign(api.util, {\n                selectInvalidatedBy,\n                selectCachedArgsForQuery\n            });\n            const { buildInitiateQuery, buildInitiateMutation, getRunningMutationThunk, getRunningMutationsThunk, getRunningQueriesThunk, getRunningQueryThunk } = buildInitiate({\n                queryThunk,\n                mutationThunk,\n                api,\n                serializeQueryArgs,\n                context\n            });\n            safeAssign(api.util, {\n                getRunningMutationThunk,\n                getRunningMutationsThunk,\n                getRunningQueryThunk,\n                getRunningQueriesThunk\n            });\n            return {\n                name: coreModuleName,\n                injectEndpoint (endpointName, definition) {\n                    const anyApi = api;\n                    anyApi.endpoints[endpointName] ??= {};\n                    if (isQueryDefinition(definition)) {\n                        safeAssign(anyApi.endpoints[endpointName], {\n                            name: endpointName,\n                            select: buildQuerySelector(endpointName, definition),\n                            initiate: buildInitiateQuery(endpointName, definition)\n                        }, buildMatchThunkActions(queryThunk, endpointName));\n                    } else if (isMutationDefinition(definition)) {\n                        safeAssign(anyApi.endpoints[endpointName], {\n                            name: endpointName,\n                            select: buildMutationSelector(),\n                            initiate: buildInitiateMutation(endpointName)\n                        }, buildMatchThunkActions(mutationThunk, endpointName));\n                    }\n                }\n            };\n        }\n    });\n// src/query/core/index.ts\nvar createApi = /* @__PURE__ */ buildCreateApi(coreModule());\n //# sourceMappingURL=rtk-query.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3F1ZXJ5L3J0ay1xdWVyeS5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw2QkFBNkI7QUFDN0IsSUFBSUEsY0FBOEIsYUFBSCxHQUFJLEVBQUNDO0lBQ2xDQSxZQUFZLENBQUMsZ0JBQWdCLEdBQUc7SUFDaENBLFlBQVksQ0FBQyxVQUFVLEdBQUc7SUFDMUJBLFlBQVksQ0FBQyxZQUFZLEdBQUc7SUFDNUJBLFlBQVksQ0FBQyxXQUFXLEdBQUc7SUFDM0IsT0FBT0E7QUFDVCxHQUFHRCxlQUFlLENBQUM7QUFDbkIsU0FBU0Usc0JBQXNCQyxNQUFNO0lBQ25DLE9BQU87UUFDTEE7UUFDQUMsaUJBQWlCRCxXQUFXLGdCQUFnQixpQkFBaUI7UUFDN0RFLFdBQVdGLFdBQVcsVUFBVSxXQUFXO1FBQzNDRyxXQUFXSCxXQUFXLFlBQVksYUFBYTtRQUMvQ0ksU0FBU0osV0FBVyxXQUFXLFlBQVk7SUFDN0M7QUFDRjtBQUVBLG1DQUFtQztBQUNuQyxTQUFTSyxjQUFjQyxHQUFHO0lBQ3hCLE9BQU8sSUFBSUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFQyxJQUFJLENBQUNGO0FBQ3BDO0FBRUEsOEJBQThCO0FBQzlCLElBQUlHLHVCQUF1QixDQUFDSCxNQUFRQSxJQUFJSSxPQUFPLENBQUMsT0FBTztBQUN2RCxJQUFJQyxzQkFBc0IsQ0FBQ0wsTUFBUUEsSUFBSUksT0FBTyxDQUFDLE9BQU87QUFDdEQsU0FBU0UsU0FBU0MsSUFBSSxFQUFFUCxHQUFHO0lBQ3pCLElBQUksQ0FBQ08sTUFBTTtRQUNULE9BQU9QO0lBQ1Q7SUFDQSxJQUFJLENBQUNBLEtBQUs7UUFDUixPQUFPTztJQUNUO0lBQ0EsSUFBSVIsY0FBY0MsTUFBTTtRQUN0QixPQUFPQTtJQUNUO0lBQ0EsTUFBTVEsWUFBWUQsS0FBS0UsUUFBUSxDQUFDLFFBQVEsQ0FBQ1QsSUFBSVUsVUFBVSxDQUFD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a0IsRUFDbEJDLHFCQUFxQixFQUNyQkUsdUJBQXVCLEVBQ3ZCRSx3QkFBd0IsRUFDeEJELHNCQUFzQixFQUN0QkYsb0JBQW9CLEVBQ3JCLEdBQUdkLGNBQWM7Z0JBQ2hCRTtnQkFDQUM7Z0JBQ0F6SDtnQkFDQXVIO2dCQUNBRztZQUNGO1lBQ0FnWSxXQUFXMWYsSUFBSXFNLElBQUksRUFBRTtnQkFDbkJoRTtnQkFDQUU7Z0JBQ0FIO2dCQUNBRTtZQUNGO1lBQ0EsT0FBTztnQkFDTHVJLE1BQU1nUDtnQkFDTnpILGdCQUFlNVAsWUFBWSxFQUFFMFAsVUFBVTtvQkFDckMsTUFBTStILFNBQVNqZ0I7b0JBQ2ZpZ0IsT0FBT2xXLFNBQVMsQ0FBQ3ZCLGFBQWEsS0FBSyxDQUFDO29CQUNwQyxJQUFJckMsa0JBQWtCK1IsYUFBYTt3QkFDakN3SCxXQUFXTyxPQUFPbFcsU0FBUyxDQUFDdkIsYUFBYSxFQUFFOzRCQUN6Q3FJLE1BQU1ySTs0QkFDTndCLFFBQVFvSyxtQkFBbUI1TCxjQUFjMFA7NEJBQ3pDeEwsVUFBVXhFLG1CQUFtQk0sY0FBYzBQO3dCQUM3QyxHQUFHNUksdUJBQXVCOUgsWUFBWWdCO29CQUN4QyxPQUFPLElBQUlwQyxxQkFBcUI4UixhQUFhO3dCQUMzQ3dILFdBQVdPLE9BQU9sVyxTQUFTLENBQUN2QixhQUFhLEVBQUU7NEJBQ3pDcUksTUFBTXJJOzRCQUNOd0IsUUFBUXFLOzRCQUNSM0gsVUFBVXZFLHNCQUFzQks7d0JBQ2xDLEdBQUc4Ryx1QkFBdUI3SCxlQUFlZTtvQkFDM0M7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7QUFFQSwwQkFBMEI7QUFDMUIsSUFBSTBYLFlBQVksYUFBYSxHQUFHM0osZUFBZXVKO0FBYzdDLENBQ0YsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2FnZS5zdG9yZS8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcXVlcnkvcnRrLXF1ZXJ5Lm1vZGVybi5tanM/Nzc5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcXVlcnkvY29yZS9hcGlTdGF0ZS50c1xudmFyIFF1ZXJ5U3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoUXVlcnlTdGF0dXMyKSA9PiB7XG4gIFF1ZXJ5U3RhdHVzMltcInVuaW5pdGlhbGl6ZWRcIl0gPSBcInVuaW5pdGlhbGl6ZWRcIjtcbiAgUXVlcnlTdGF0dXMyW1wicGVuZGluZ1wiXSA9IFwicGVuZGluZ1wiO1xuICBRdWVyeVN0YXR1czJbXCJmdWxmaWxsZWRcIl0gPSBcImZ1bGZpbGxlZFwiO1xuICBRdWVyeVN0YXR1czJbXCJyZWplY3RlZFwiXSA9IFwicmVqZWN0ZWRcIjtcbiAgcmV0dXJuIFF1ZXJ5U3RhdHVzMjtcbn0pKFF1ZXJ5U3RhdHVzIHx8IHt9KTtcbmZ1bmN0aW9uIGdldFJlcXVlc3RTdGF0dXNGbGFncyhzdGF0dXMpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXMsXG4gICAgaXNVbmluaXRpYWxpemVkOiBzdGF0dXMgPT09IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi8sXG4gICAgaXNMb2FkaW5nOiBzdGF0dXMgPT09IFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi8sXG4gICAgaXNTdWNjZXNzOiBzdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIgLyogZnVsZmlsbGVkICovLFxuICAgIGlzRXJyb3I6IHN0YXR1cyA9PT0gXCJyZWplY3RlZFwiIC8qIHJlamVjdGVkICovXG4gIH07XG59XG5cbi8vIHNyYy9xdWVyeS91dGlscy9pc0Fic29sdXRlVXJsLnRzXG5mdW5jdGlvbiBpc0Fic29sdXRlVXJsKHVybCkge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgKF58OikvL2ApLnRlc3QodXJsKTtcbn1cblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2pvaW5VcmxzLnRzXG52YXIgd2l0aG91dFRyYWlsaW5nU2xhc2ggPSAodXJsKSA9PiB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xudmFyIHdpdGhvdXRMZWFkaW5nU2xhc2ggPSAodXJsKSA9PiB1cmwucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuZnVuY3Rpb24gam9pblVybHMoYmFzZSwgdXJsKSB7XG4gIGlmICghYmFzZSkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBpZiAoaXNBYnNvbHV0ZVVybCh1cmwpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBjb25zdCBkZWxpbWl0ZXIgPSBiYXNlLmVuZHNXaXRoKFwiL1wiKSB8fCAhdXJsLnN0YXJ0c1dpdGgoXCI/XCIpID8gXCIvXCIgOiBcIlwiO1xuICBiYXNlID0gd2l0aG91dFRyYWlsaW5nU2xhc2goYmFzZSk7XG4gIHVybCA9IHdpdGhvdXRMZWFkaW5nU2xhc2godXJsKTtcbiAgcmV0dXJuIGAke2Jhc2V9JHtkZWxpbWl0ZXJ9JHt1cmx9YDtcbn1cblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2ZsYXR0ZW4udHNcbnZhciBmbGF0dGVuID0gKGFycikgPT4gW10uY29uY2F0KC4uLmFycik7XG5cbi8vIHNyYy9xdWVyeS91dGlscy9pc09ubGluZS50c1xuZnVuY3Rpb24gaXNPbmxpbmUoKSB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiID8gdHJ1ZSA6IG5hdmlnYXRvci5vbkxpbmUgPT09IHZvaWQgMCA/IHRydWUgOiBuYXZpZ2F0b3Iub25MaW5lO1xufVxuXG4vLyBzcmMvcXVlcnkvdXRpbHMvaXNEb2N1bWVudFZpc2libGUudHNcbmZ1bmN0aW9uIGlzRG9jdW1lbnRWaXNpYmxlKCkge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSAhPT0gXCJoaWRkZW5cIjtcbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvcnRrSW1wb3J0cy50c1xuaW1wb3J0IHsgY3JlYXRlQWN0aW9uLCBjcmVhdGVTbGljZSwgY3JlYXRlU2VsZWN0b3IsIGNyZWF0ZUFzeW5jVGh1bmssIGNvbWJpbmVSZWR1Y2VycywgY3JlYXRlTmV4dFN0YXRlLCBpc0FueU9mLCBpc0FsbE9mLCBpc0FjdGlvbiwgaXNQZW5kaW5nLCBpc1JlamVjdGVkLCBpc0Z1bGZpbGxlZCwgaXNSZWplY3RlZFdpdGhWYWx1ZSwgaXNBc3luY1RodW5rQWN0aW9uLCBwcmVwYXJlQXV0b0JhdGNoZWQsIFNIT1VMRF9BVVRPQkFUQ0gsIGlzUGxhaW5PYmplY3QsIG5hbm9pZCB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5cbi8vIHNyYy9xdWVyeS91dGlscy9jb3B5V2l0aFN0cnVjdHVyYWxTaGFyaW5nLnRzXG52YXIgaXNQbGFpbk9iamVjdDIgPSBpc1BsYWluT2JqZWN0O1xuZnVuY3Rpb24gY29weVdpdGhTdHJ1Y3R1cmFsU2hhcmluZyhvbGRPYmosIG5ld09iaikge1xuICBpZiAob2xkT2JqID09PSBuZXdPYmogfHwgIShpc1BsYWluT2JqZWN0MihvbGRPYmopICYmIGlzUGxhaW5PYmplY3QyKG5ld09iaikgfHwgQXJyYXkuaXNBcnJheShvbGRPYmopICYmIEFycmF5LmlzQXJyYXkobmV3T2JqKSkpIHtcbiAgICByZXR1cm4gbmV3T2JqO1xuICB9XG4gIGNvbnN0IG5ld0tleXMgPSBPYmplY3Qua2V5cyhuZXdPYmopO1xuICBjb25zdCBvbGRLZXlzID0gT2JqZWN0LmtleXMob2xkT2JqKTtcbiAgbGV0IGlzU2FtZU9iamVjdCA9IG5ld0tleXMubGVuZ3RoID09PSBvbGRLZXlzLmxlbmd0aDtcbiAgY29uc3QgbWVyZ2VPYmogPSBBcnJheS5pc0FycmF5KG5ld09iaikgPyBbXSA6IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBuZXdLZXlzKSB7XG4gICAgbWVyZ2VPYmpba2V5XSA9IGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcob2xkT2JqW2tleV0sIG5ld09ialtrZXldKTtcbiAgICBpZiAoaXNTYW1lT2JqZWN0KVxuICAgICAgaXNTYW1lT2JqZWN0ID0gb2xkT2JqW2tleV0gPT09IG1lcmdlT2JqW2tleV07XG4gIH1cbiAgcmV0dXJuIGlzU2FtZU9iamVjdCA/IG9sZE9iaiA6IG1lcmdlT2JqO1xufVxuXG4vLyBzcmMvcXVlcnkvZmV0Y2hCYXNlUXVlcnkudHNcbnZhciBkZWZhdWx0RmV0Y2hGbiA9ICguLi5hcmdzKSA9PiBmZXRjaCguLi5hcmdzKTtcbnZhciBkZWZhdWx0VmFsaWRhdGVTdGF0dXMgPSAocmVzcG9uc2UpID0+IHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDw9IDI5OTtcbnZhciBkZWZhdWx0SXNKc29uQ29udGVudFR5cGUgPSAoaGVhZGVycykgPT4gKFxuICAvKmFwcGxpY2F0Ki9cbiAgL2lvblxcLyh2bmRcXC5hcGlcXCspP2pzb24vLnRlc3QoaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIilcbik7XG5mdW5jdGlvbiBzdHJpcFVuZGVmaW5lZChvYmopIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGNvbnN0IGNvcHkgPSB7XG4gICAgLi4ub2JqXG4gIH07XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGNvcHkpKSB7XG4gICAgaWYgKHYgPT09IHZvaWQgMClcbiAgICAgIGRlbGV0ZSBjb3B5W2tdO1xuICB9XG4gIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gZmV0Y2hCYXNlUXVlcnkoe1xuICBiYXNlVXJsLFxuICBwcmVwYXJlSGVhZGVycyA9ICh4KSA9PiB4LFxuICBmZXRjaEZuID0gZGVmYXVsdEZldGNoRm4sXG4gIHBhcmFtc1NlcmlhbGl6ZXIsXG4gIGlzSnNvbkNvbnRlbnRUeXBlID0gZGVmYXVsdElzSnNvbkNvbnRlbnRUeXBlLFxuICBqc29uQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAganNvblJlcGxhY2VyLFxuICB0aW1lb3V0OiBkZWZhdWx0VGltZW91dCxcbiAgcmVzcG9uc2VIYW5kbGVyOiBnbG9iYWxSZXNwb25zZUhhbmRsZXIsXG4gIHZhbGlkYXRlU3RhdHVzOiBnbG9iYWxWYWxpZGF0ZVN0YXR1cyxcbiAgLi4uYmFzZUZldGNoT3B0aW9uc1xufSA9IHt9KSB7XG4gIGlmICh0eXBlb2YgZmV0Y2ggPT09IFwidW5kZWZpbmVkXCIgJiYgZmV0Y2hGbiA9PT0gZGVmYXVsdEZldGNoRm4pIHtcbiAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBgZmV0Y2hgIGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBzdXBwbHkgYSBjdXN0b20gYGZldGNoRm5gIHByb3BlcnR5IHRvIHVzZSBgZmV0Y2hCYXNlUXVlcnlgIG9uIFNTUiBlbnZpcm9ubWVudHMuXCIpO1xuICB9XG4gIHJldHVybiBhc3luYyAoYXJnLCBhcGkpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBzaWduYWwsXG4gICAgICBnZXRTdGF0ZSxcbiAgICAgIGV4dHJhLFxuICAgICAgZW5kcG9pbnQsXG4gICAgICBmb3JjZWQsXG4gICAgICB0eXBlXG4gICAgfSA9IGFwaTtcbiAgICBsZXQgbWV0YTtcbiAgICBsZXQge1xuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGJhc2VGZXRjaE9wdGlvbnMuaGVhZGVycyksXG4gICAgICBwYXJhbXMgPSB2b2lkIDAsXG4gICAgICByZXNwb25zZUhhbmRsZXIgPSBnbG9iYWxSZXNwb25zZUhhbmRsZXIgPz8gXCJqc29uXCIsXG4gICAgICB2YWxpZGF0ZVN0YXR1cyA9IGdsb2JhbFZhbGlkYXRlU3RhdHVzID8/IGRlZmF1bHRWYWxpZGF0ZVN0YXR1cyxcbiAgICAgIHRpbWVvdXQgPSBkZWZhdWx0VGltZW91dCxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gdHlwZW9mIGFyZyA9PSBcInN0cmluZ1wiID8ge1xuICAgICAgdXJsOiBhcmdcbiAgICB9IDogYXJnO1xuICAgIGxldCBjb25maWcgPSB7XG4gICAgICAuLi5iYXNlRmV0Y2hPcHRpb25zLFxuICAgICAgc2lnbmFsLFxuICAgICAgLi4ucmVzdFxuICAgIH07XG4gICAgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHN0cmlwVW5kZWZpbmVkKGhlYWRlcnMpKTtcbiAgICBjb25maWcuaGVhZGVycyA9IGF3YWl0IHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIHtcbiAgICAgIGdldFN0YXRlLFxuICAgICAgZXh0cmEsXG4gICAgICBlbmRwb2ludCxcbiAgICAgIGZvcmNlZCxcbiAgICAgIHR5cGVcbiAgICB9KSB8fCBoZWFkZXJzO1xuICAgIGNvbnN0IGlzSnNvbmlmaWFibGUgPSAoYm9keSkgPT4gdHlwZW9mIGJvZHkgPT09IFwib2JqZWN0XCIgJiYgKGlzUGxhaW5PYmplY3QoYm9keSkgfHwgQXJyYXkuaXNBcnJheShib2R5KSB8fCB0eXBlb2YgYm9keS50b0pTT04gPT09IFwiZnVuY3Rpb25cIik7XG4gICAgaWYgKCFjb25maWcuaGVhZGVycy5oYXMoXCJjb250ZW50LXR5cGVcIikgJiYgaXNKc29uaWZpYWJsZShjb25maWcuYm9keSkpIHtcbiAgICAgIGNvbmZpZy5oZWFkZXJzLnNldChcImNvbnRlbnQtdHlwZVwiLCBqc29uQ29udGVudFR5cGUpO1xuICAgIH1cbiAgICBpZiAoaXNKc29uaWZpYWJsZShjb25maWcuYm9keSkgJiYgaXNKc29uQ29udGVudFR5cGUoY29uZmlnLmhlYWRlcnMpKSB7XG4gICAgICBjb25maWcuYm9keSA9IEpTT04uc3RyaW5naWZ5KGNvbmZpZy5ib2R5LCBqc29uUmVwbGFjZXIpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICBjb25zdCBkaXZpZGVyID0gfnVybC5pbmRleE9mKFwiP1wiKSA/IFwiJlwiIDogXCI/XCI7XG4gICAgICBjb25zdCBxdWVyeSA9IHBhcmFtc1NlcmlhbGl6ZXIgPyBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcykgOiBuZXcgVVJMU2VhcmNoUGFyYW1zKHN0cmlwVW5kZWZpbmVkKHBhcmFtcykpO1xuICAgICAgdXJsICs9IGRpdmlkZXIgKyBxdWVyeTtcbiAgICB9XG4gICAgdXJsID0gam9pblVybHMoYmFzZVVybCwgdXJsKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCBjb25maWcpO1xuICAgIGNvbnN0IHJlcXVlc3RDbG9uZSA9IG5ldyBSZXF1ZXN0KHVybCwgY29uZmlnKTtcbiAgICBtZXRhID0ge1xuICAgICAgcmVxdWVzdDogcmVxdWVzdENsb25lXG4gICAgfTtcbiAgICBsZXQgcmVzcG9uc2UsIHRpbWVkT3V0ID0gZmFsc2UsIHRpbWVvdXRJZCA9IHRpbWVvdXQgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aW1lZE91dCA9IHRydWU7XG4gICAgICBhcGkuYWJvcnQoKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgICB0cnkge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEZuKHJlcXVlc3QpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgc3RhdHVzOiB0aW1lZE91dCA/IFwiVElNRU9VVF9FUlJPUlwiIDogXCJGRVRDSF9FUlJPUlwiLFxuICAgICAgICAgIGVycm9yOiBTdHJpbmcoZSlcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRpbWVvdXRJZClcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlQ2xvbmUgPSByZXNwb25zZS5jbG9uZSgpO1xuICAgIG1ldGEucmVzcG9uc2UgPSByZXNwb25zZUNsb25lO1xuICAgIGxldCByZXN1bHREYXRhO1xuICAgIGxldCByZXNwb25zZVRleHQgPSBcIlwiO1xuICAgIHRyeSB7XG4gICAgICBsZXQgaGFuZGxlUmVzcG9uc2VFcnJvcjtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UsIHJlc3BvbnNlSGFuZGxlcikudGhlbigocikgPT4gcmVzdWx0RGF0YSA9IHIsIChlKSA9PiBoYW5kbGVSZXNwb25zZUVycm9yID0gZSksXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy82NjUjaXNzdWVjb21tZW50LTUzODk5NTE4MlxuICAgICAgICAvLyB3ZSAqaGF2ZSogdG8gXCJ1c2UgdXBcIiBib3RoIHN0cmVhbXMgYXQgdGhlIHNhbWUgdGltZSBvciB0aGV5IHdpbGwgc3RvcCBydW5uaW5nIGluIG5vZGUtZmV0Y2ggc2NlbmFyaW9zXG4gICAgICAgIHJlc3BvbnNlQ2xvbmUudGV4dCgpLnRoZW4oKHIpID0+IHJlc3BvbnNlVGV4dCA9IHIsICgpID0+IHtcbiAgICAgICAgfSlcbiAgICAgIF0pO1xuICAgICAgaWYgKGhhbmRsZVJlc3BvbnNlRXJyb3IpXG4gICAgICAgIHRocm93IGhhbmRsZVJlc3BvbnNlRXJyb3I7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBzdGF0dXM6IFwiUEFSU0lOR19FUlJPUlwiLFxuICAgICAgICAgIG9yaWdpbmFsU3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgZGF0YTogcmVzcG9uc2VUZXh0LFxuICAgICAgICAgIGVycm9yOiBTdHJpbmcoZSlcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLCByZXN1bHREYXRhKSA/IHtcbiAgICAgIGRhdGE6IHJlc3VsdERhdGEsXG4gICAgICBtZXRhXG4gICAgfSA6IHtcbiAgICAgIGVycm9yOiB7XG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBkYXRhOiByZXN1bHREYXRhXG4gICAgICB9LFxuICAgICAgbWV0YVxuICAgIH07XG4gIH07XG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlLCByZXNwb25zZUhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2VIYW5kbGVyKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlSGFuZGxlciA9PT0gXCJjb250ZW50LXR5cGVcIikge1xuICAgICAgcmVzcG9uc2VIYW5kbGVyID0gaXNKc29uQ29udGVudFR5cGUocmVzcG9uc2UuaGVhZGVycykgPyBcImpzb25cIiA6IFwidGV4dFwiO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2VIYW5kbGVyID09PSBcImpzb25cIikge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aCA/IEpTT04ucGFyc2UodGV4dCkgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG59XG5cbi8vIHNyYy9xdWVyeS9IYW5kbGVkRXJyb3IudHNcbnZhciBIYW5kbGVkRXJyb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBtZXRhID0gdm9pZCAwKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbn07XG5cbi8vIHNyYy9xdWVyeS9yZXRyeS50c1xuYXN5bmMgZnVuY3Rpb24gZGVmYXVsdEJhY2tvZmYoYXR0ZW1wdCA9IDAsIG1heFJldHJpZXMgPSA1KSB7XG4gIGNvbnN0IGF0dGVtcHRzID0gTWF0aC5taW4oYXR0ZW1wdCwgbWF4UmV0cmllcyk7XG4gIGNvbnN0IHRpbWVvdXQgPSB+figoTWF0aC5yYW5kb20oKSArIDAuNCkgKiAoMzAwIDw8IGF0dGVtcHRzKSk7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KChyZXMpID0+IHJlc29sdmUocmVzKSwgdGltZW91dCkpO1xufVxuZnVuY3Rpb24gZmFpbChlKSB7XG4gIHRocm93IE9iamVjdC5hc3NpZ24obmV3IEhhbmRsZWRFcnJvcih7XG4gICAgZXJyb3I6IGVcbiAgfSksIHtcbiAgICB0aHJvd0ltbWVkaWF0ZWx5OiB0cnVlXG4gIH0pO1xufVxudmFyIEVNUFRZX09QVElPTlMgPSB7fTtcbnZhciByZXRyeVdpdGhCYWNrb2ZmID0gKGJhc2VRdWVyeSwgZGVmYXVsdE9wdGlvbnMpID0+IGFzeW5jIChhcmdzLCBhcGksIGV4dHJhT3B0aW9ucykgPT4ge1xuICBjb25zdCBwb3NzaWJsZU1heFJldHJpZXMgPSBbNSwgKGRlZmF1bHRPcHRpb25zIHx8IEVNUFRZX09QVElPTlMpLm1heFJldHJpZXMsIChleHRyYU9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUykubWF4UmV0cmllc10uZmlsdGVyKCh4KSA9PiB4ICE9PSB2b2lkIDApO1xuICBjb25zdCBbbWF4UmV0cmllc10gPSBwb3NzaWJsZU1heFJldHJpZXMuc2xpY2UoLTEpO1xuICBjb25zdCBkZWZhdWx0UmV0cnlDb25kaXRpb24gPSAoXywgX18sIHtcbiAgICBhdHRlbXB0XG4gIH0pID0+IGF0dGVtcHQgPD0gbWF4UmV0cmllcztcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBtYXhSZXRyaWVzLFxuICAgIGJhY2tvZmY6IGRlZmF1bHRCYWNrb2ZmLFxuICAgIHJldHJ5Q29uZGl0aW9uOiBkZWZhdWx0UmV0cnlDb25kaXRpb24sXG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4uZXh0cmFPcHRpb25zXG4gIH07XG4gIGxldCByZXRyeTIgPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBiYXNlUXVlcnkoYXJncywgYXBpLCBleHRyYU9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgSGFuZGxlZEVycm9yKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHJ5MisrO1xuICAgICAgaWYgKGUudGhyb3dJbW1lZGlhdGVseSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEhhbmRsZWRFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEhhbmRsZWRFcnJvciAmJiAhb3B0aW9ucy5yZXRyeUNvbmRpdGlvbihlLnZhbHVlLmVycm9yLCBhcmdzLCB7XG4gICAgICAgIGF0dGVtcHQ6IHJldHJ5MixcbiAgICAgICAgYmFzZVF1ZXJ5QXBpOiBhcGksXG4gICAgICAgIGV4dHJhT3B0aW9uc1xuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuIGUudmFsdWU7XG4gICAgICB9XG4gICAgICBhd2FpdCBvcHRpb25zLmJhY2tvZmYocmV0cnkyLCBvcHRpb25zLm1heFJldHJpZXMpO1xuICAgIH1cbiAgfVxufTtcbnZhciByZXRyeSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKHJldHJ5V2l0aEJhY2tvZmYsIHtcbiAgZmFpbFxufSk7XG5cbi8vIHNyYy9xdWVyeS9jb3JlL3NldHVwTGlzdGVuZXJzLnRzXG52YXIgb25Gb2N1cyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oXCJfX3J0a3EvZm9jdXNlZFwiKTtcbnZhciBvbkZvY3VzTG9zdCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oXCJfX3J0a3EvdW5mb2N1c2VkXCIpO1xudmFyIG9uT25saW5lID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUFjdGlvbihcIl9fcnRrcS9vbmxpbmVcIik7XG52YXIgb25PZmZsaW5lID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUFjdGlvbihcIl9fcnRrcS9vZmZsaW5lXCIpO1xudmFyIGluaXRpYWxpemVkID0gZmFsc2U7XG5mdW5jdGlvbiBzZXR1cExpc3RlbmVycyhkaXNwYXRjaCwgY3VzdG9tSGFuZGxlcikge1xuICBmdW5jdGlvbiBkZWZhdWx0SGFuZGxlcigpIHtcbiAgICBjb25zdCBoYW5kbGVGb2N1cyA9ICgpID0+IGRpc3BhdGNoKG9uRm9jdXMoKSk7XG4gICAgY29uc3QgaGFuZGxlRm9jdXNMb3N0ID0gKCkgPT4gZGlzcGF0Y2gob25Gb2N1c0xvc3QoKSk7XG4gICAgY29uc3QgaGFuZGxlT25saW5lID0gKCkgPT4gZGlzcGF0Y2gob25PbmxpbmUoKSk7XG4gICAgY29uc3QgaGFuZGxlT2ZmbGluZSA9ICgpID0+IGRpc3BhdGNoKG9uT2ZmbGluZSgpKTtcbiAgICBjb25zdCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYgKHdpbmRvdy5kb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgIGhhbmRsZUZvY3VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVGb2N1c0xvc3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgaGFuZGxlRm9jdXMsIGZhbHNlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgaGFuZGxlT25saW5lLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBoYW5kbGVPZmZsaW5lLCBmYWxzZSk7XG4gICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGhhbmRsZUZvY3VzKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZU9ubGluZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgaGFuZGxlT2ZmbGluZSk7XG4gICAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIH07XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9XG4gIHJldHVybiBjdXN0b21IYW5kbGVyID8gY3VzdG9tSGFuZGxlcihkaXNwYXRjaCwge1xuICAgIG9uRm9jdXMsXG4gICAgb25Gb2N1c0xvc3QsXG4gICAgb25PZmZsaW5lLFxuICAgIG9uT25saW5lXG4gIH0pIDogZGVmYXVsdEhhbmRsZXIoKTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2VuZHBvaW50RGVmaW5pdGlvbnMudHNcbmZ1bmN0aW9uIGlzUXVlcnlEZWZpbml0aW9uKGUpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gXCJxdWVyeVwiIC8qIHF1ZXJ5ICovO1xufVxuZnVuY3Rpb24gaXNNdXRhdGlvbkRlZmluaXRpb24oZSkge1xuICByZXR1cm4gZS50eXBlID09PSBcIm11dGF0aW9uXCIgLyogbXV0YXRpb24gKi87XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVQcm92aWRlZEJ5KGRlc2NyaXB0aW9uLCByZXN1bHQsIGVycm9yLCBxdWVyeUFyZywgbWV0YSwgYXNzZXJ0VGFnVHlwZXMpIHtcbiAgaWYgKGlzRnVuY3Rpb24oZGVzY3JpcHRpb24pKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uKHJlc3VsdCwgZXJyb3IsIHF1ZXJ5QXJnLCBtZXRhKS5tYXAoZXhwYW5kVGFnRGVzY3JpcHRpb24pLm1hcChhc3NlcnRUYWdUeXBlcyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVzY3JpcHRpb24pKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uLm1hcChleHBhbmRUYWdEZXNjcmlwdGlvbikubWFwKGFzc2VydFRhZ1R5cGVzKTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBleHBhbmRUYWdEZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGRlc2NyaXB0aW9uID09PSBcInN0cmluZ1wiID8ge1xuICAgIHR5cGU6IGRlc2NyaXB0aW9uXG4gIH0gOiBkZXNjcmlwdGlvbjtcbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRJbml0aWF0ZS50c1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5cbi8vIHNyYy9xdWVyeS91dGlscy9pc05vdE51bGxpc2gudHNcbmZ1bmN0aW9uIGlzTm90TnVsbGlzaCh2KSB7XG4gIHJldHVybiB2ICE9IG51bGw7XG59XG5cbi8vIHNyYy9xdWVyeS91dGlscy9jb3VudE9iamVjdEtleXMudHNcbmZ1bmN0aW9uIGNvdW50T2JqZWN0S2V5cyhvYmopIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChjb25zdCBfa2V5IGluIG9iaikge1xuICAgIGNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZEluaXRpYXRlLnRzXG52YXIgZm9yY2VRdWVyeUZuU3ltYm9sID0gU3ltYm9sKFwiZm9yY2VRdWVyeUZuXCIpO1xudmFyIGlzVXBzZXJ0UXVlcnkgPSAoYXJnKSA9PiB0eXBlb2YgYXJnW2ZvcmNlUXVlcnlGblN5bWJvbF0gPT09IFwiZnVuY3Rpb25cIjtcbmZ1bmN0aW9uIGJ1aWxkSW5pdGlhdGUoe1xuICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gIHF1ZXJ5VGh1bmssXG4gIG11dGF0aW9uVGh1bmssXG4gIGFwaSxcbiAgY29udGV4dFxufSkge1xuICBjb25zdCBydW5uaW5nUXVlcmllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHJ1bm5pbmdNdXRhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB7XG4gICAgdW5zdWJzY3JpYmVRdWVyeVJlc3VsdCxcbiAgICByZW1vdmVNdXRhdGlvblJlc3VsdCxcbiAgICB1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zXG4gIH0gPSBhcGkuaW50ZXJuYWxBY3Rpb25zO1xuICByZXR1cm4ge1xuICAgIGJ1aWxkSW5pdGlhdGVRdWVyeSxcbiAgICBidWlsZEluaXRpYXRlTXV0YXRpb24sXG4gICAgZ2V0UnVubmluZ1F1ZXJ5VGh1bmssXG4gICAgZ2V0UnVubmluZ011dGF0aW9uVGh1bmssXG4gICAgZ2V0UnVubmluZ1F1ZXJpZXNUaHVuayxcbiAgICBnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmtcbiAgfTtcbiAgZnVuY3Rpb24gZ2V0UnVubmluZ1F1ZXJ5VGh1bmsoZW5kcG9pbnROYW1lLCBxdWVyeUFyZ3MpIHtcbiAgICByZXR1cm4gKGRpc3BhdGNoKSA9PiB7XG4gICAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXTtcbiAgICAgIGNvbnN0IHF1ZXJ5Q2FjaGVLZXkgPSBzZXJpYWxpemVRdWVyeUFyZ3Moe1xuICAgICAgICBxdWVyeUFyZ3MsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBydW5uaW5nUXVlcmllcy5nZXQoZGlzcGF0Y2gpPy5bcXVlcnlDYWNoZUtleV07XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSdW5uaW5nTXV0YXRpb25UaHVuayhfZW5kcG9pbnROYW1lLCBmaXhlZENhY2hlS2V5T3JSZXF1ZXN0SWQpIHtcbiAgICByZXR1cm4gKGRpc3BhdGNoKSA9PiB7XG4gICAgICByZXR1cm4gcnVubmluZ011dGF0aW9ucy5nZXQoZGlzcGF0Y2gpPy5bZml4ZWRDYWNoZUtleU9yUmVxdWVzdElkXTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldFJ1bm5pbmdRdWVyaWVzVGh1bmsoKSB7XG4gICAgcmV0dXJuIChkaXNwYXRjaCkgPT4gT2JqZWN0LnZhbHVlcyhydW5uaW5nUXVlcmllcy5nZXQoZGlzcGF0Y2gpIHx8IHt9KS5maWx0ZXIoaXNOb3ROdWxsaXNoKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmsoKSB7XG4gICAgcmV0dXJuIChkaXNwYXRjaCkgPT4gT2JqZWN0LnZhbHVlcyhydW5uaW5nTXV0YXRpb25zLmdldChkaXNwYXRjaCkgfHwge30pLmZpbHRlcihpc05vdE51bGxpc2gpO1xuICB9XG4gIGZ1bmN0aW9uIG1pZGRsZXdhcmVXYXJuaW5nKGRpc3BhdGNoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKG1pZGRsZXdhcmVXYXJuaW5nLnRyaWdnZXJlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgcmV0dXJuZWRWYWx1ZSA9IGRpc3BhdGNoKGFwaS5pbnRlcm5hbEFjdGlvbnMuaW50ZXJuYWxfZ2V0UlRLUVN1YnNjcmlwdGlvbnMoKSk7XG4gICAgICBtaWRkbGV3YXJlV2FybmluZy50cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiByZXR1cm5lZFZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiByZXR1cm5lZFZhbHVlPy50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzNCkgOiBgV2FybmluZzogTWlkZGxld2FyZSBmb3IgUlRLLVF1ZXJ5IEFQSSBhdCByZWR1Y2VyUGF0aCBcIiR7YXBpLnJlZHVjZXJQYXRofVwiIGhhcyBub3QgYmVlbiBhZGRlZCB0byB0aGUgc3RvcmUuXG5Zb3UgbXVzdCBhZGQgdGhlIG1pZGRsZXdhcmUgZm9yIFJUSy1RdWVyeSB0byBmdW5jdGlvbiBjb3JyZWN0bHkhYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkSW5pdGlhdGVRdWVyeShlbmRwb2ludE5hbWUsIGVuZHBvaW50RGVmaW5pdGlvbikge1xuICAgIGNvbnN0IHF1ZXJ5QWN0aW9uID0gKGFyZywge1xuICAgICAgc3Vic2NyaWJlID0gdHJ1ZSxcbiAgICAgIGZvcmNlUmVmZXRjaCxcbiAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnMsXG4gICAgICBbZm9yY2VRdWVyeUZuU3ltYm9sXTogZm9yY2VRdWVyeUZuXG4gICAgfSA9IHt9KSA9PiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBxdWVyeUNhY2hlS2V5ID0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzOiBhcmcsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHRodW5rID0gcXVlcnlUaHVuayh7XG4gICAgICAgIHR5cGU6IFwicXVlcnlcIixcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBmb3JjZVJlZmV0Y2gsXG4gICAgICAgIHN1YnNjcmlwdGlvbk9wdGlvbnMsXG4gICAgICAgIGVuZHBvaW50TmFtZSxcbiAgICAgICAgb3JpZ2luYWxBcmdzOiBhcmcsXG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgIFtmb3JjZVF1ZXJ5Rm5TeW1ib2xdOiBmb3JjZVF1ZXJ5Rm5cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0uc2VsZWN0KGFyZyk7XG4gICAgICBjb25zdCB0aHVua1Jlc3VsdCA9IGRpc3BhdGNoKHRodW5rKTtcbiAgICAgIGNvbnN0IHN0YXRlQWZ0ZXIgPSBzZWxlY3RvcihnZXRTdGF0ZSgpKTtcbiAgICAgIG1pZGRsZXdhcmVXYXJuaW5nKGRpc3BhdGNoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBhYm9ydFxuICAgICAgfSA9IHRodW5rUmVzdWx0O1xuICAgICAgY29uc3Qgc2tpcHBlZFN5bmNocm9ub3VzbHkgPSBzdGF0ZUFmdGVyLnJlcXVlc3RJZCAhPT0gcmVxdWVzdElkO1xuICAgICAgY29uc3QgcnVubmluZ1F1ZXJ5ID0gcnVubmluZ1F1ZXJpZXMuZ2V0KGRpc3BhdGNoKT8uW3F1ZXJ5Q2FjaGVLZXldO1xuICAgICAgY29uc3Qgc2VsZWN0RnJvbVN0YXRlID0gKCkgPT4gc2VsZWN0b3IoZ2V0U3RhdGUoKSk7XG4gICAgICBjb25zdCBzdGF0ZVByb21pc2UgPSBPYmplY3QuYXNzaWduKGZvcmNlUXVlcnlGbiA/IChcbiAgICAgICAgLy8gYSBxdWVyeSBoYXMgYmVlbiBmb3JjZWQgKHVwc2VydFF1ZXJ5RGF0YSlcbiAgICAgICAgLy8gLT4gd2Ugd2FudCB0byByZXNvbHZlIGl0IG9uY2UgZGF0YSBoYXMgYmVlbiB3cml0dGVuIHdpdGggdGhlIGRhdGEgdGhhdCB3aWxsIGJlIHdyaXR0ZW5cbiAgICAgICAgdGh1bmtSZXN1bHQudGhlbihzZWxlY3RGcm9tU3RhdGUpXG4gICAgICApIDogc2tpcHBlZFN5bmNocm9ub3VzbHkgJiYgIXJ1bm5pbmdRdWVyeSA/IChcbiAgICAgICAgLy8gYSBxdWVyeSBoYXMgYmVlbiBza2lwcGVkIGR1ZSB0byBhIGNvbmRpdGlvbiBhbmQgd2UgZG8gbm90IGhhdmUgYW55IGN1cnJlbnRseSBydW5uaW5nIHF1ZXJ5XG4gICAgICAgIC8vIC0+IHdlIHdhbnQgdG8gcmVzb2x2ZSBpdCBpbW1lZGlhdGVseSB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHN0YXRlQWZ0ZXIpXG4gICAgICApIDogKFxuICAgICAgICAvLyBxdWVyeSBqdXN0IHN0YXJ0ZWQgb3Igb25lIGlzIGFscmVhZHkgaW4gZmxpZ2h0XG4gICAgICAgIC8vIC0+IHdhaXQgZm9yIHRoZSBydW5uaW5nIHF1ZXJ5LCB0aGVuIHJlc29sdmUgd2l0aCBkYXRhIGZyb20gYWZ0ZXIgdGhhdFxuICAgICAgICBQcm9taXNlLmFsbChbcnVubmluZ1F1ZXJ5LCB0aHVua1Jlc3VsdF0pLnRoZW4oc2VsZWN0RnJvbVN0YXRlKVxuICAgICAgKSwge1xuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9ucyxcbiAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgYWJvcnQsXG4gICAgICAgIGFzeW5jIHVud3JhcCgpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdGF0ZVByb21pc2U7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc0Vycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVmZXRjaDogKCkgPT4gZGlzcGF0Y2gocXVlcnlBY3Rpb24oYXJnLCB7XG4gICAgICAgICAgc3Vic2NyaWJlOiBmYWxzZSxcbiAgICAgICAgICBmb3JjZVJlZmV0Y2g6IHRydWVcbiAgICAgICAgfSkpLFxuICAgICAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgICBpZiAoc3Vic2NyaWJlKVxuICAgICAgICAgICAgZGlzcGF0Y2godW5zdWJzY3JpYmVRdWVyeVJlc3VsdCh7XG4gICAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgICBzdGF0ZVByb21pc2Uuc3Vic2NyaXB0aW9uT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgZGlzcGF0Y2godXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyh7XG4gICAgICAgICAgICBlbmRwb2ludE5hbWUsXG4gICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJ1bm5pbmdRdWVyeSAmJiAhc2tpcHBlZFN5bmNocm9ub3VzbHkgJiYgIWZvcmNlUXVlcnlGbikge1xuICAgICAgICBjb25zdCBydW5uaW5nID0gcnVubmluZ1F1ZXJpZXMuZ2V0KGRpc3BhdGNoKSB8fCB7fTtcbiAgICAgICAgcnVubmluZ1txdWVyeUNhY2hlS2V5XSA9IHN0YXRlUHJvbWlzZTtcbiAgICAgICAgcnVubmluZ1F1ZXJpZXMuc2V0KGRpc3BhdGNoLCBydW5uaW5nKTtcbiAgICAgICAgc3RhdGVQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGRlbGV0ZSBydW5uaW5nW3F1ZXJ5Q2FjaGVLZXldO1xuICAgICAgICAgIGlmICghY291bnRPYmplY3RLZXlzKHJ1bm5pbmcpKSB7XG4gICAgICAgICAgICBydW5uaW5nUXVlcmllcy5kZWxldGUoZGlzcGF0Y2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGVQcm9taXNlO1xuICAgIH07XG4gICAgcmV0dXJuIHF1ZXJ5QWN0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkSW5pdGlhdGVNdXRhdGlvbihlbmRwb2ludE5hbWUpIHtcbiAgICByZXR1cm4gKGFyZywge1xuICAgICAgdHJhY2sgPSB0cnVlLFxuICAgICAgZml4ZWRDYWNoZUtleVxuICAgIH0gPSB7fSkgPT4gKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgdGh1bmsgPSBtdXRhdGlvblRodW5rKHtcbiAgICAgICAgdHlwZTogXCJtdXRhdGlvblwiLFxuICAgICAgICBlbmRwb2ludE5hbWUsXG4gICAgICAgIG9yaWdpbmFsQXJnczogYXJnLFxuICAgICAgICB0cmFjayxcbiAgICAgICAgZml4ZWRDYWNoZUtleVxuICAgICAgfSk7XG4gICAgICBjb25zdCB0aHVua1Jlc3VsdCA9IGRpc3BhdGNoKHRodW5rKTtcbiAgICAgIG1pZGRsZXdhcmVXYXJuaW5nKGRpc3BhdGNoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgdW53cmFwXG4gICAgICB9ID0gdGh1bmtSZXN1bHQ7XG4gICAgICBjb25zdCByZXR1cm5WYWx1ZVByb21pc2UgPSB0aHVua1Jlc3VsdC51bndyYXAoKS50aGVuKChkYXRhKSA9PiAoe1xuICAgICAgICBkYXRhXG4gICAgICB9KSkuY2F0Y2goKGVycm9yKSA9PiAoe1xuICAgICAgICBlcnJvclxuICAgICAgfSkpO1xuICAgICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKHJlbW92ZU11dGF0aW9uUmVzdWx0KHtcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgZml4ZWRDYWNoZUtleVxuICAgICAgICB9KSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmV0ID0gT2JqZWN0LmFzc2lnbihyZXR1cm5WYWx1ZVByb21pc2UsIHtcbiAgICAgICAgYXJnOiB0aHVua1Jlc3VsdC5hcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgYWJvcnQsXG4gICAgICAgIHVud3JhcCxcbiAgICAgICAgcmVzZXRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcnVubmluZyA9IHJ1bm5pbmdNdXRhdGlvbnMuZ2V0KGRpc3BhdGNoKSB8fCB7fTtcbiAgICAgIHJ1bm5pbmdNdXRhdGlvbnMuc2V0KGRpc3BhdGNoLCBydW5uaW5nKTtcbiAgICAgIHJ1bm5pbmdbcmVxdWVzdElkXSA9IHJldDtcbiAgICAgIHJldC50aGVuKCgpID0+IHtcbiAgICAgICAgZGVsZXRlIHJ1bm5pbmdbcmVxdWVzdElkXTtcbiAgICAgICAgaWYgKCFjb3VudE9iamVjdEtleXMocnVubmluZykpIHtcbiAgICAgICAgICBydW5uaW5nTXV0YXRpb25zLmRlbGV0ZShkaXNwYXRjaCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGZpeGVkQ2FjaGVLZXkpIHtcbiAgICAgICAgcnVubmluZ1tmaXhlZENhY2hlS2V5XSA9IHJldDtcbiAgICAgICAgcmV0LnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGlmIChydW5uaW5nW2ZpeGVkQ2FjaGVLZXldID09PSByZXQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBydW5uaW5nW2ZpeGVkQ2FjaGVLZXldO1xuICAgICAgICAgICAgaWYgKCFjb3VudE9iamVjdEtleXMocnVubmluZykpIHtcbiAgICAgICAgICAgICAgcnVubmluZ011dGF0aW9ucy5kZWxldGUoZGlzcGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRUaHVua3MudHNcbmltcG9ydCB7IGlzRHJhZnRhYmxlLCBwcm9kdWNlV2l0aFBhdGNoZXMgfSBmcm9tIFwiaW1tZXJcIjtcbmZ1bmN0aW9uIGRlZmF1bHRUcmFuc2Zvcm1SZXNwb25zZShiYXNlUXVlcnlSZXR1cm5WYWx1ZSkge1xuICByZXR1cm4gYmFzZVF1ZXJ5UmV0dXJuVmFsdWU7XG59XG5mdW5jdGlvbiBidWlsZFRodW5rcyh7XG4gIHJlZHVjZXJQYXRoLFxuICBiYXNlUXVlcnksXG4gIGNvbnRleHQ6IHtcbiAgICBlbmRwb2ludERlZmluaXRpb25zXG4gIH0sXG4gIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgYXBpLFxuICBhc3NlcnRUYWdUeXBlXG59KSB7XG4gIGNvbnN0IHBhdGNoUXVlcnlEYXRhID0gKGVuZHBvaW50TmFtZSwgYXJncywgcGF0Y2hlcywgdXBkYXRlUHJvdmlkZWQpID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBlbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV07XG4gICAgY29uc3QgcXVlcnlDYWNoZUtleSA9IHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICBxdWVyeUFyZ3M6IGFyZ3MsXG4gICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICBlbmRwb2ludE5hbWVcbiAgICB9KTtcbiAgICBkaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLnF1ZXJ5UmVzdWx0UGF0Y2hlZCh7XG4gICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgcGF0Y2hlc1xuICAgIH0pKTtcbiAgICBpZiAoIXVwZGF0ZVByb3ZpZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld1ZhbHVlID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLnNlbGVjdChhcmdzKShcbiAgICAgIC8vIFdvcmsgYXJvdW5kIFRTIDQuMSBtaXNtYXRjaFxuICAgICAgZ2V0U3RhdGUoKVxuICAgICk7XG4gICAgY29uc3QgcHJvdmlkZWRUYWdzID0gY2FsY3VsYXRlUHJvdmlkZWRCeShlbmRwb2ludERlZmluaXRpb24ucHJvdmlkZXNUYWdzLCBuZXdWYWx1ZS5kYXRhLCB2b2lkIDAsIGFyZ3MsIHt9LCBhc3NlcnRUYWdUeXBlKTtcbiAgICBkaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLnVwZGF0ZVByb3ZpZGVkQnkoe1xuICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgIHByb3ZpZGVkVGFnc1xuICAgIH0pKTtcbiAgfTtcbiAgY29uc3QgdXBkYXRlUXVlcnlEYXRhID0gKGVuZHBvaW50TmFtZSwgYXJncywgdXBkYXRlUmVjaXBlLCB1cGRhdGVQcm92aWRlZCA9IHRydWUpID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV07XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gZW5kcG9pbnREZWZpbml0aW9uLnNlbGVjdChhcmdzKShcbiAgICAgIC8vIFdvcmsgYXJvdW5kIFRTIDQuMSBtaXNtYXRjaFxuICAgICAgZ2V0U3RhdGUoKVxuICAgICk7XG4gICAgbGV0IHJldCA9IHtcbiAgICAgIHBhdGNoZXM6IFtdLFxuICAgICAgaW52ZXJzZVBhdGNoZXM6IFtdLFxuICAgICAgdW5kbzogKCkgPT4gZGlzcGF0Y2goYXBpLnV0aWwucGF0Y2hRdWVyeURhdGEoZW5kcG9pbnROYW1lLCBhcmdzLCByZXQuaW52ZXJzZVBhdGNoZXMsIHVwZGF0ZVByb3ZpZGVkKSlcbiAgICB9O1xuICAgIGlmIChjdXJyZW50U3RhdGUuc3RhdHVzID09PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBsZXQgbmV3VmFsdWU7XG4gICAgaWYgKFwiZGF0YVwiIGluIGN1cnJlbnRTdGF0ZSkge1xuICAgICAgaWYgKGlzRHJhZnRhYmxlKGN1cnJlbnRTdGF0ZS5kYXRhKSkge1xuICAgICAgICBjb25zdCBbdmFsdWUsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzXSA9IHByb2R1Y2VXaXRoUGF0Y2hlcyhjdXJyZW50U3RhdGUuZGF0YSwgdXBkYXRlUmVjaXBlKTtcbiAgICAgICAgcmV0LnBhdGNoZXMucHVzaCguLi5wYXRjaGVzKTtcbiAgICAgICAgcmV0LmludmVyc2VQYXRjaGVzLnB1c2goLi4uaW52ZXJzZVBhdGNoZXMpO1xuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSB1cGRhdGVSZWNpcGUoY3VycmVudFN0YXRlLmRhdGEpO1xuICAgICAgICByZXQucGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgcGF0aDogW10sXG4gICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXQuaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgIHBhdGg6IFtdLFxuICAgICAgICAgIHZhbHVlOiBjdXJyZW50U3RhdGUuZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGlzcGF0Y2goYXBpLnV0aWwucGF0Y2hRdWVyeURhdGEoZW5kcG9pbnROYW1lLCBhcmdzLCByZXQucGF0Y2hlcywgdXBkYXRlUHJvdmlkZWQpKTtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICBjb25zdCB1cHNlcnRRdWVyeURhdGEgPSAoZW5kcG9pbnROYW1lLCBhcmdzLCB2YWx1ZSkgPT4gKGRpc3BhdGNoKSA9PiB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5pbml0aWF0ZShhcmdzLCB7XG4gICAgICBzdWJzY3JpYmU6IGZhbHNlLFxuICAgICAgZm9yY2VSZWZldGNoOiB0cnVlLFxuICAgICAgW2ZvcmNlUXVlcnlGblN5bWJvbF06ICgpID0+ICh7XG4gICAgICAgIGRhdGE6IHZhbHVlXG4gICAgICB9KVxuICAgIH0pKTtcbiAgfTtcbiAgY29uc3QgZXhlY3V0ZUVuZHBvaW50ID0gYXN5bmMgKGFyZywge1xuICAgIHNpZ25hbCxcbiAgICBhYm9ydCxcbiAgICByZWplY3RXaXRoVmFsdWUsXG4gICAgZnVsZmlsbFdpdGhWYWx1ZSxcbiAgICBkaXNwYXRjaCxcbiAgICBnZXRTdGF0ZSxcbiAgICBleHRyYVxuICB9KSA9PiB7XG4gICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gZW5kcG9pbnREZWZpbml0aW9uc1thcmcuZW5kcG9pbnROYW1lXTtcbiAgICB0cnkge1xuICAgICAgbGV0IHRyYW5zZm9ybVJlc3BvbnNlID0gZGVmYXVsdFRyYW5zZm9ybVJlc3BvbnNlO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGNvbnN0IGJhc2VRdWVyeUFwaSA9IHtcbiAgICAgICAgc2lnbmFsLFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgIGdldFN0YXRlLFxuICAgICAgICBleHRyYSxcbiAgICAgICAgZW5kcG9pbnQ6IGFyZy5lbmRwb2ludE5hbWUsXG4gICAgICAgIHR5cGU6IGFyZy50eXBlLFxuICAgICAgICBmb3JjZWQ6IGFyZy50eXBlID09PSBcInF1ZXJ5XCIgPyBpc0ZvcmNlZFF1ZXJ5KGFyZywgZ2V0U3RhdGUoKSkgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgICBjb25zdCBmb3JjZVF1ZXJ5Rm4gPSBhcmcudHlwZSA9PT0gXCJxdWVyeVwiID8gYXJnW2ZvcmNlUXVlcnlGblN5bWJvbF0gOiB2b2lkIDA7XG4gICAgICBpZiAoZm9yY2VRdWVyeUZuKSB7XG4gICAgICAgIHJlc3VsdCA9IGZvcmNlUXVlcnlGbigpO1xuICAgICAgfSBlbHNlIGlmIChlbmRwb2ludERlZmluaXRpb24ucXVlcnkpIHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgYmFzZVF1ZXJ5KGVuZHBvaW50RGVmaW5pdGlvbi5xdWVyeShhcmcub3JpZ2luYWxBcmdzKSwgYmFzZVF1ZXJ5QXBpLCBlbmRwb2ludERlZmluaXRpb24uZXh0cmFPcHRpb25zKTtcbiAgICAgICAgaWYgKGVuZHBvaW50RGVmaW5pdGlvbi50cmFuc2Zvcm1SZXNwb25zZSkge1xuICAgICAgICAgIHRyYW5zZm9ybVJlc3BvbnNlID0gZW5kcG9pbnREZWZpbml0aW9uLnRyYW5zZm9ybVJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBlbmRwb2ludERlZmluaXRpb24ucXVlcnlGbihhcmcub3JpZ2luYWxBcmdzLCBiYXNlUXVlcnlBcGksIGVuZHBvaW50RGVmaW5pdGlvbi5leHRyYU9wdGlvbnMsIChhcmcyKSA9PiBiYXNlUXVlcnkoYXJnMiwgYmFzZVF1ZXJ5QXBpLCBlbmRwb2ludERlZmluaXRpb24uZXh0cmFPcHRpb25zKSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICBjb25zdCB3aGF0ID0gZW5kcG9pbnREZWZpbml0aW9uLnF1ZXJ5ID8gXCJgYmFzZVF1ZXJ5YFwiIDogXCJgcXVlcnlGbmBcIjtcbiAgICAgICAgbGV0IGVycjtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICBlcnIgPSBgJHt3aGF0fSBkaWQgbm90IHJldHVybiBhbnl0aGluZy5gO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBlcnIgPSBgJHt3aGF0fSBkaWQgbm90IHJldHVybiBhbiBvYmplY3QuYDtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuZXJyb3IgJiYgcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICBlcnIgPSBgJHt3aGF0fSByZXR1cm5lZCBhbiBvYmplY3QgY29udGFpbmluZyBib3RoIFxcYGVycm9yXFxgIGFuZCBcXGByZXN1bHRcXGAuYDtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuZXJyb3IgPT09IHZvaWQgMCAmJiByZXN1bHQuZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZXJyID0gYCR7d2hhdH0gcmV0dXJuZWQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmVpdGhlciBhIHZhbGlkIFxcYGVycm9yXFxgIGFuZCBcXGByZXN1bHRcXGAuIEF0IGxlYXN0IG9uZSBvZiB0aGVtIHNob3VsZCBub3QgYmUgXFxgdW5kZWZpbmVkXFxgYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBcImVycm9yXCIgJiYga2V5ICE9PSBcImRhdGFcIiAmJiBrZXkgIT09IFwibWV0YVwiKSB7XG4gICAgICAgICAgICAgIGVyciA9IGBUaGUgb2JqZWN0IHJldHVybmVkIGJ5ICR7d2hhdH0gaGFzIHRoZSB1bmtub3duIHByb3BlcnR5ICR7a2V5fS5gO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGVuY291bnRlcmVkIGhhbmRsaW5nIHRoZSBlbmRwb2ludCAke2FyZy5lbmRwb2ludE5hbWV9LlxuICAgICAgICAgICAgICAke2Vycn1cbiAgICAgICAgICAgICAgSXQgbmVlZHMgdG8gcmV0dXJuIGFuIG9iamVjdCB3aXRoIGVpdGhlciB0aGUgc2hhcGUgXFxgeyBkYXRhOiA8dmFsdWU+IH1cXGAgb3IgXFxgeyBlcnJvcjogPHZhbHVlPiB9XFxgIHRoYXQgbWF5IGNvbnRhaW4gYW4gb3B0aW9uYWwgXFxgbWV0YVxcYCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgT2JqZWN0IHJldHVybmVkIHdhczpgLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmVycm9yKVxuICAgICAgICB0aHJvdyBuZXcgSGFuZGxlZEVycm9yKHJlc3VsdC5lcnJvciwgcmVzdWx0Lm1ldGEpO1xuICAgICAgcmV0dXJuIGZ1bGZpbGxXaXRoVmFsdWUoYXdhaXQgdHJhbnNmb3JtUmVzcG9uc2UocmVzdWx0LmRhdGEsIHJlc3VsdC5tZXRhLCBhcmcub3JpZ2luYWxBcmdzKSwge1xuICAgICAgICBmdWxmaWxsZWRUaW1lU3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIGJhc2VRdWVyeU1ldGE6IHJlc3VsdC5tZXRhLFxuICAgICAgICBbU0hPVUxEX0FVVE9CQVRDSF06IHRydWVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsZXQgY2F0Y2hlZEVycm9yID0gZXJyb3I7XG4gICAgICBpZiAoY2F0Y2hlZEVycm9yIGluc3RhbmNlb2YgSGFuZGxlZEVycm9yKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1FcnJvclJlc3BvbnNlID0gZGVmYXVsdFRyYW5zZm9ybVJlc3BvbnNlO1xuICAgICAgICBpZiAoZW5kcG9pbnREZWZpbml0aW9uLnF1ZXJ5ICYmIGVuZHBvaW50RGVmaW5pdGlvbi50cmFuc2Zvcm1FcnJvclJlc3BvbnNlKSB7XG4gICAgICAgICAgdHJhbnNmb3JtRXJyb3JSZXNwb25zZSA9IGVuZHBvaW50RGVmaW5pdGlvbi50cmFuc2Zvcm1FcnJvclJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdFdpdGhWYWx1ZShhd2FpdCB0cmFuc2Zvcm1FcnJvclJlc3BvbnNlKGNhdGNoZWRFcnJvci52YWx1ZSwgY2F0Y2hlZEVycm9yLm1ldGEsIGFyZy5vcmlnaW5hbEFyZ3MpLCB7XG4gICAgICAgICAgICBiYXNlUXVlcnlNZXRhOiBjYXRjaGVkRXJyb3IubWV0YSxcbiAgICAgICAgICAgIFtTSE9VTERfQVVUT0JBVENIXTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY2F0Y2hlZEVycm9yID0gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBBbiB1bmhhbmRsZWQgZXJyb3Igb2NjdXJyZWQgcHJvY2Vzc2luZyBhIHJlcXVlc3QgZm9yIHRoZSBlbmRwb2ludCBcIiR7YXJnLmVuZHBvaW50TmFtZX1cIi5cbkluIHRoZSBjYXNlIG9mIGFuIHVuaGFuZGxlZCBlcnJvciwgbm8gdGFncyB3aWxsIGJlIFwicHJvdmlkZWRcIiBvciBcImludmFsaWRhdGVkXCIuYCwgY2F0Y2hlZEVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoY2F0Y2hlZEVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGNhdGNoZWRFcnJvcjtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGlzRm9yY2VkUXVlcnkoYXJnLCBzdGF0ZSkge1xuICAgIGNvbnN0IHJlcXVlc3RTdGF0ZSA9IHN0YXRlW3JlZHVjZXJQYXRoXT8ucXVlcmllcz8uW2FyZy5xdWVyeUNhY2hlS2V5XTtcbiAgICBjb25zdCBiYXNlRmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UgPSBzdGF0ZVtyZWR1Y2VyUGF0aF0/LmNvbmZpZy5yZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlO1xuICAgIGNvbnN0IGZ1bGZpbGxlZFZhbCA9IHJlcXVlc3RTdGF0ZT8uZnVsZmlsbGVkVGltZVN0YW1wO1xuICAgIGNvbnN0IHJlZmV0Y2hWYWwgPSBhcmcuZm9yY2VSZWZldGNoID8/IChhcmcuc3Vic2NyaWJlICYmIGJhc2VGZXRjaE9uTW91bnRPckFyZ0NoYW5nZSk7XG4gICAgaWYgKHJlZmV0Y2hWYWwpIHtcbiAgICAgIHJldHVybiByZWZldGNoVmFsID09PSB0cnVlIHx8IChOdW1iZXIoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpIC0gTnVtYmVyKGZ1bGZpbGxlZFZhbCkpIC8gMWUzID49IHJlZmV0Y2hWYWw7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBxdWVyeVRodW5rID0gY3JlYXRlQXN5bmNUaHVuayhgJHtyZWR1Y2VyUGF0aH0vZXhlY3V0ZVF1ZXJ5YCwgZXhlY3V0ZUVuZHBvaW50LCB7XG4gICAgZ2V0UGVuZGluZ01ldGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydGVkVGltZVN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBbU0hPVUxEX0FVVE9CQVRDSF06IHRydWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBjb25kaXRpb24ocXVlcnlUaHVua0FyZ3MsIHtcbiAgICAgIGdldFN0YXRlXG4gICAgfSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgY29uc3QgcmVxdWVzdFN0YXRlID0gc3RhdGVbcmVkdWNlclBhdGhdPy5xdWVyaWVzPy5bcXVlcnlUaHVua0FyZ3MucXVlcnlDYWNoZUtleV07XG4gICAgICBjb25zdCBmdWxmaWxsZWRWYWwgPSByZXF1ZXN0U3RhdGU/LmZ1bGZpbGxlZFRpbWVTdGFtcDtcbiAgICAgIGNvbnN0IGN1cnJlbnRBcmcgPSBxdWVyeVRodW5rQXJncy5vcmlnaW5hbEFyZ3M7XG4gICAgICBjb25zdCBwcmV2aW91c0FyZyA9IHJlcXVlc3RTdGF0ZT8ub3JpZ2luYWxBcmdzO1xuICAgICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gZW5kcG9pbnREZWZpbml0aW9uc1txdWVyeVRodW5rQXJncy5lbmRwb2ludE5hbWVdO1xuICAgICAgaWYgKGlzVXBzZXJ0UXVlcnkocXVlcnlUaHVua0FyZ3MpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3RTdGF0ZT8uc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNGb3JjZWRRdWVyeShxdWVyeVRodW5rQXJncywgc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzUXVlcnlEZWZpbml0aW9uKGVuZHBvaW50RGVmaW5pdGlvbikgJiYgZW5kcG9pbnREZWZpbml0aW9uPy5mb3JjZVJlZmV0Y2g/Lih7XG4gICAgICAgIGN1cnJlbnRBcmcsXG4gICAgICAgIHByZXZpb3VzQXJnLFxuICAgICAgICBlbmRwb2ludFN0YXRlOiByZXF1ZXN0U3RhdGUsXG4gICAgICAgIHN0YXRlXG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChmdWxmaWxsZWRWYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBkaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbjogdHJ1ZVxuICB9KTtcbiAgY29uc3QgbXV0YXRpb25UaHVuayA9IGNyZWF0ZUFzeW5jVGh1bmsoYCR7cmVkdWNlclBhdGh9L2V4ZWN1dGVNdXRhdGlvbmAsIGV4ZWN1dGVFbmRwb2ludCwge1xuICAgIGdldFBlbmRpbmdNZXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRlZFRpbWVTdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgW1NIT1VMRF9BVVRPQkFUQ0hdOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGhhc1RoZUZvcmNlID0gKG9wdGlvbnMpID0+IFwiZm9yY2VcIiBpbiBvcHRpb25zO1xuICBjb25zdCBoYXNNYXhBZ2UgPSAob3B0aW9ucykgPT4gXCJpZk9sZGVyVGhhblwiIGluIG9wdGlvbnM7XG4gIGNvbnN0IHByZWZldGNoID0gKGVuZHBvaW50TmFtZSwgYXJnLCBvcHRpb25zKSA9PiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgY29uc3QgZm9yY2UgPSBoYXNUaGVGb3JjZShvcHRpb25zKSAmJiBvcHRpb25zLmZvcmNlO1xuICAgIGNvbnN0IG1heEFnZSA9IGhhc01heEFnZShvcHRpb25zKSAmJiBvcHRpb25zLmlmT2xkZXJUaGFuO1xuICAgIGNvbnN0IHF1ZXJ5QWN0aW9uID0gKGZvcmNlMiA9IHRydWUpID0+IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5pbml0aWF0ZShhcmcsIHtcbiAgICAgIGZvcmNlUmVmZXRjaDogZm9yY2UyXG4gICAgfSk7XG4gICAgY29uc3QgbGF0ZXN0U3RhdGVWYWx1ZSA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5zZWxlY3QoYXJnKShnZXRTdGF0ZSgpKTtcbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIGRpc3BhdGNoKHF1ZXJ5QWN0aW9uKCkpO1xuICAgIH0gZWxzZSBpZiAobWF4QWdlKSB7XG4gICAgICBjb25zdCBsYXN0RnVsZmlsbGVkVHMgPSBsYXRlc3RTdGF0ZVZhbHVlPy5mdWxmaWxsZWRUaW1lU3RhbXA7XG4gICAgICBpZiAoIWxhc3RGdWxmaWxsZWRUcykge1xuICAgICAgICBkaXNwYXRjaChxdWVyeUFjdGlvbigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hvdWxkUmV0cmlnZ2VyID0gKE51bWJlcigvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkgLSBOdW1iZXIobmV3IERhdGUobGFzdEZ1bGZpbGxlZFRzKSkpIC8gMWUzID49IG1heEFnZTtcbiAgICAgIGlmIChzaG91bGRSZXRyaWdnZXIpIHtcbiAgICAgICAgZGlzcGF0Y2gocXVlcnlBY3Rpb24oKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3BhdGNoKHF1ZXJ5QWN0aW9uKGZhbHNlKSk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBtYXRjaGVzRW5kcG9pbnQoZW5kcG9pbnROYW1lKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGFjdGlvbj8ubWV0YT8uYXJnPy5lbmRwb2ludE5hbWUgPT09IGVuZHBvaW50TmFtZTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZE1hdGNoVGh1bmtBY3Rpb25zKHRodW5rLCBlbmRwb2ludE5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2hQZW5kaW5nOiBpc0FsbE9mKGlzUGVuZGluZyh0aHVuayksIG1hdGNoZXNFbmRwb2ludChlbmRwb2ludE5hbWUpKSxcbiAgICAgIG1hdGNoRnVsZmlsbGVkOiBpc0FsbE9mKGlzRnVsZmlsbGVkKHRodW5rKSwgbWF0Y2hlc0VuZHBvaW50KGVuZHBvaW50TmFtZSkpLFxuICAgICAgbWF0Y2hSZWplY3RlZDogaXNBbGxPZihpc1JlamVjdGVkKHRodW5rKSwgbWF0Y2hlc0VuZHBvaW50KGVuZHBvaW50TmFtZSkpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHF1ZXJ5VGh1bmssXG4gICAgbXV0YXRpb25UaHVuayxcbiAgICBwcmVmZXRjaCxcbiAgICB1cGRhdGVRdWVyeURhdGEsXG4gICAgdXBzZXJ0UXVlcnlEYXRhLFxuICAgIHBhdGNoUXVlcnlEYXRhLFxuICAgIGJ1aWxkTWF0Y2hUaHVua0FjdGlvbnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVByb3ZpZGVkQnlUaHVuayhhY3Rpb24sIHR5cGUsIGVuZHBvaW50RGVmaW5pdGlvbnMsIGFzc2VydFRhZ1R5cGUpIHtcbiAgcmV0dXJuIGNhbGN1bGF0ZVByb3ZpZGVkQnkoZW5kcG9pbnREZWZpbml0aW9uc1thY3Rpb24ubWV0YS5hcmcuZW5kcG9pbnROYW1lXVt0eXBlXSwgaXNGdWxmaWxsZWQoYWN0aW9uKSA/IGFjdGlvbi5wYXlsb2FkIDogdm9pZCAwLCBpc1JlamVjdGVkV2l0aFZhbHVlKGFjdGlvbikgPyBhY3Rpb24ucGF5bG9hZCA6IHZvaWQgMCwgYWN0aW9uLm1ldGEuYXJnLm9yaWdpbmFsQXJncywgXCJiYXNlUXVlcnlNZXRhXCIgaW4gYWN0aW9uLm1ldGEgPyBhY3Rpb24ubWV0YS5iYXNlUXVlcnlNZXRhIDogdm9pZCAwLCBhc3NlcnRUYWdUeXBlKTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRTbGljZS50c1xuaW1wb3J0IHsgaXNEcmFmdCB9IGZyb20gXCJpbW1lclwiO1xuaW1wb3J0IHsgYXBwbHlQYXRjaGVzLCBvcmlnaW5hbCB9IGZyb20gXCJpbW1lclwiO1xuZnVuY3Rpb24gdXBkYXRlUXVlcnlTdWJzdGF0ZUlmRXhpc3RzKHN0YXRlLCBxdWVyeUNhY2hlS2V5LCB1cGRhdGUpIHtcbiAgY29uc3Qgc3Vic3RhdGUgPSBzdGF0ZVtxdWVyeUNhY2hlS2V5XTtcbiAgaWYgKHN1YnN0YXRlKSB7XG4gICAgdXBkYXRlKHN1YnN0YXRlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TXV0YXRpb25DYWNoZUtleShpZCkge1xuICByZXR1cm4gKFwiYXJnXCIgaW4gaWQgPyBpZC5hcmcuZml4ZWRDYWNoZUtleSA6IGlkLmZpeGVkQ2FjaGVLZXkpID8/IGlkLnJlcXVlc3RJZDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU11dGF0aW9uU3Vic3RhdGVJZkV4aXN0cyhzdGF0ZSwgaWQsIHVwZGF0ZSkge1xuICBjb25zdCBzdWJzdGF0ZSA9IHN0YXRlW2dldE11dGF0aW9uQ2FjaGVLZXkoaWQpXTtcbiAgaWYgKHN1YnN0YXRlKSB7XG4gICAgdXBkYXRlKHN1YnN0YXRlKTtcbiAgfVxufVxudmFyIGluaXRpYWxTdGF0ZSA9IHt9O1xuZnVuY3Rpb24gYnVpbGRTbGljZSh7XG4gIHJlZHVjZXJQYXRoLFxuICBxdWVyeVRodW5rLFxuICBtdXRhdGlvblRodW5rLFxuICBjb250ZXh0OiB7XG4gICAgZW5kcG9pbnREZWZpbml0aW9uczogZGVmaW5pdGlvbnMsXG4gICAgYXBpVWlkLFxuICAgIGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8sXG4gICAgaGFzUmVoeWRyYXRpb25JbmZvXG4gIH0sXG4gIGFzc2VydFRhZ1R5cGUsXG4gIGNvbmZpZ1xufSkge1xuICBjb25zdCByZXNldEFwaVN0YXRlID0gY3JlYXRlQWN0aW9uKGAke3JlZHVjZXJQYXRofS9yZXNldEFwaVN0YXRlYCk7XG4gIGNvbnN0IHF1ZXJ5U2xpY2UgPSBjcmVhdGVTbGljZSh7XG4gICAgbmFtZTogYCR7cmVkdWNlclBhdGh9L3F1ZXJpZXNgLFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICByZWR1Y2Vyczoge1xuICAgICAgcmVtb3ZlUXVlcnlSZXN1bHQ6IHtcbiAgICAgICAgcmVkdWNlcihkcmFmdCwge1xuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgICB9XG4gICAgICAgIH0pIHtcbiAgICAgICAgICBkZWxldGUgZHJhZnRbcXVlcnlDYWNoZUtleV07XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcmU6IHByZXBhcmVBdXRvQmF0Y2hlZCgpXG4gICAgICB9LFxuICAgICAgcXVlcnlSZXN1bHRQYXRjaGVkOiB7XG4gICAgICAgIHJlZHVjZXIoZHJhZnQsIHtcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgICAgICAgcGF0Y2hlc1xuICAgICAgICAgIH1cbiAgICAgICAgfSkge1xuICAgICAgICAgIHVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgcXVlcnlDYWNoZUtleSwgKHN1YnN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzdWJzdGF0ZS5kYXRhID0gYXBwbHlQYXRjaGVzKHN1YnN0YXRlLmRhdGEsIHBhdGNoZXMuY29uY2F0KCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJlOiBwcmVwYXJlQXV0b0JhdGNoZWQoKVxuICAgICAgfVxuICAgIH0sXG4gICAgZXh0cmFSZWR1Y2VycyhidWlsZGVyKSB7XG4gICAgICBidWlsZGVyLmFkZENhc2UocXVlcnlUaHVuay5wZW5kaW5nLCAoZHJhZnQsIHtcbiAgICAgICAgbWV0YSxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIGFyZ1xuICAgICAgICB9XG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHVwc2VydGluZyA9IGlzVXBzZXJ0UXVlcnkoYXJnKTtcbiAgICAgICAgZHJhZnRbYXJnLnF1ZXJ5Q2FjaGVLZXldID8/PSB7XG4gICAgICAgICAgc3RhdHVzOiBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovLFxuICAgICAgICAgIGVuZHBvaW50TmFtZTogYXJnLmVuZHBvaW50TmFtZVxuICAgICAgICB9O1xuICAgICAgICB1cGRhdGVRdWVyeVN1YnN0YXRlSWZFeGlzdHMoZHJhZnQsIGFyZy5xdWVyeUNhY2hlS2V5LCAoc3Vic3RhdGUpID0+IHtcbiAgICAgICAgICBzdWJzdGF0ZS5zdGF0dXMgPSBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovO1xuICAgICAgICAgIHN1YnN0YXRlLnJlcXVlc3RJZCA9IHVwc2VydGluZyAmJiBzdWJzdGF0ZS5yZXF1ZXN0SWQgPyAoXG4gICAgICAgICAgICAvLyBmb3IgYHVwc2VydFF1ZXJ5YCAqKnVwZGF0ZXMqKiwga2VlcCB0aGUgY3VycmVudCBgcmVxdWVzdElkYFxuICAgICAgICAgICAgc3Vic3RhdGUucmVxdWVzdElkXG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIC8vIGZvciBub3JtYWwgcXVlcmllcyBvciBgdXBzZXJ0UXVlcnlgICoqaW5zZXJ0cyoqIGFsd2F5cyB1cGRhdGUgdGhlIGByZXF1ZXN0SWRgXG4gICAgICAgICAgICBtZXRhLnJlcXVlc3RJZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGFyZy5vcmlnaW5hbEFyZ3MgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc3Vic3RhdGUub3JpZ2luYWxBcmdzID0gYXJnLm9yaWdpbmFsQXJncztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3Vic3RhdGUuc3RhcnRlZFRpbWVTdGFtcCA9IG1ldGEuc3RhcnRlZFRpbWVTdGFtcDtcbiAgICAgICAgfSk7XG4gICAgICB9KS5hZGRDYXNlKHF1ZXJ5VGh1bmsuZnVsZmlsbGVkLCAoZHJhZnQsIHtcbiAgICAgICAgbWV0YSxcbiAgICAgICAgcGF5bG9hZFxuICAgICAgfSkgPT4ge1xuICAgICAgICB1cGRhdGVRdWVyeVN1YnN0YXRlSWZFeGlzdHMoZHJhZnQsIG1ldGEuYXJnLnF1ZXJ5Q2FjaGVLZXksIChzdWJzdGF0ZSkgPT4ge1xuICAgICAgICAgIGlmIChzdWJzdGF0ZS5yZXF1ZXN0SWQgIT09IG1ldGEucmVxdWVzdElkICYmICFpc1Vwc2VydFF1ZXJ5KG1ldGEuYXJnKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBtZXJnZVxuICAgICAgICAgIH0gPSBkZWZpbml0aW9uc1ttZXRhLmFyZy5lbmRwb2ludE5hbWVdO1xuICAgICAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIgLyogZnVsZmlsbGVkICovO1xuICAgICAgICAgIGlmIChtZXJnZSkge1xuICAgICAgICAgICAgaWYgKHN1YnN0YXRlLmRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZnVsZmlsbGVkVGltZVN0YW1wLFxuICAgICAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgICAgICBiYXNlUXVlcnlNZXRhLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICAgICAgICB9ID0gbWV0YTtcbiAgICAgICAgICAgICAgbGV0IG5ld0RhdGEgPSBjcmVhdGVOZXh0U3RhdGUoc3Vic3RhdGUuZGF0YSwgKGRyYWZ0U3Vic3RhdGVEYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlKGRyYWZ0U3Vic3RhdGVEYXRhLCBwYXlsb2FkLCB7XG4gICAgICAgICAgICAgICAgICBhcmc6IGFyZy5vcmlnaW5hbEFyZ3MsXG4gICAgICAgICAgICAgICAgICBiYXNlUXVlcnlNZXRhLFxuICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkVGltZVN0YW1wLFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzdWJzdGF0ZS5kYXRhID0gbmV3RGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1YnN0YXRlLmRhdGEgPSBwYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzdGF0ZS5kYXRhID0gZGVmaW5pdGlvbnNbbWV0YS5hcmcuZW5kcG9pbnROYW1lXS5zdHJ1Y3R1cmFsU2hhcmluZyA/PyB0cnVlID8gY29weVdpdGhTdHJ1Y3R1cmFsU2hhcmluZyhpc0RyYWZ0KHN1YnN0YXRlLmRhdGEpID8gb3JpZ2luYWwoc3Vic3RhdGUuZGF0YSkgOiBzdWJzdGF0ZS5kYXRhLCBwYXlsb2FkKSA6IHBheWxvYWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBzdWJzdGF0ZS5lcnJvcjtcbiAgICAgICAgICBzdWJzdGF0ZS5mdWxmaWxsZWRUaW1lU3RhbXAgPSBtZXRhLmZ1bGZpbGxlZFRpbWVTdGFtcDtcbiAgICAgICAgfSk7XG4gICAgICB9KS5hZGRDYXNlKHF1ZXJ5VGh1bmsucmVqZWN0ZWQsIChkcmFmdCwge1xuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgIGFyZyxcbiAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHBheWxvYWRcbiAgICAgIH0pID0+IHtcbiAgICAgICAgdXBkYXRlUXVlcnlTdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBhcmcucXVlcnlDYWNoZUtleSwgKHN1YnN0YXRlKSA9PiB7XG4gICAgICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSByZXF1ZXN0SWQpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIiAvKiByZWplY3RlZCAqLztcbiAgICAgICAgICAgIHN1YnN0YXRlLmVycm9yID0gcGF5bG9hZCA/PyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSkuYWRkTWF0Y2hlcihoYXNSZWh5ZHJhdGlvbkluZm8sIChkcmFmdCwgYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBxdWVyaWVzXG4gICAgICAgIH0gPSBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbik7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJpZXMpKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gZG8gbm90IHJlaHlkcmF0ZSBlbnRyaWVzIHRoYXQgd2VyZSBjdXJyZW50bHkgaW4gZmxpZ2h0LlxuICAgICAgICAgICAgZW50cnk/LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIiAvKiBmdWxmaWxsZWQgKi8gfHwgZW50cnk/LnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiIC8qIHJlamVjdGVkICovXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkcmFmdFtrZXldID0gZW50cnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBtdXRhdGlvblNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6IGAke3JlZHVjZXJQYXRofS9tdXRhdGlvbnNgLFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICByZWR1Y2Vyczoge1xuICAgICAgcmVtb3ZlTXV0YXRpb25SZXN1bHQ6IHtcbiAgICAgICAgcmVkdWNlcihkcmFmdCwge1xuICAgICAgICAgIHBheWxvYWRcbiAgICAgICAgfSkge1xuICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0TXV0YXRpb25DYWNoZUtleShwYXlsb2FkKTtcbiAgICAgICAgICBpZiAoY2FjaGVLZXkgaW4gZHJhZnQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkcmFmdFtjYWNoZUtleV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJlOiBwcmVwYXJlQXV0b0JhdGNoZWQoKVxuICAgICAgfVxuICAgIH0sXG4gICAgZXh0cmFSZWR1Y2VycyhidWlsZGVyKSB7XG4gICAgICBidWlsZGVyLmFkZENhc2UobXV0YXRpb25UaHVuay5wZW5kaW5nLCAoZHJhZnQsIHtcbiAgICAgICAgbWV0YSxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgc3RhcnRlZFRpbWVTdGFtcFxuICAgICAgICB9XG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmICghYXJnLnRyYWNrKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZHJhZnRbZ2V0TXV0YXRpb25DYWNoZUtleShtZXRhKV0gPSB7XG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIgLyogcGVuZGluZyAqLyxcbiAgICAgICAgICBlbmRwb2ludE5hbWU6IGFyZy5lbmRwb2ludE5hbWUsXG4gICAgICAgICAgc3RhcnRlZFRpbWVTdGFtcFxuICAgICAgICB9O1xuICAgICAgfSkuYWRkQ2FzZShtdXRhdGlvblRodW5rLmZ1bGZpbGxlZCwgKGRyYWZ0LCB7XG4gICAgICAgIHBheWxvYWQsXG4gICAgICAgIG1ldGFcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKCFtZXRhLmFyZy50cmFjaylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHVwZGF0ZU11dGF0aW9uU3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgbWV0YSwgKHN1YnN0YXRlKSA9PiB7XG4gICAgICAgICAgaWYgKHN1YnN0YXRlLnJlcXVlc3RJZCAhPT0gbWV0YS5yZXF1ZXN0SWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgc3Vic3RhdGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIiAvKiBmdWxmaWxsZWQgKi87XG4gICAgICAgICAgc3Vic3RhdGUuZGF0YSA9IHBheWxvYWQ7XG4gICAgICAgICAgc3Vic3RhdGUuZnVsZmlsbGVkVGltZVN0YW1wID0gbWV0YS5mdWxmaWxsZWRUaW1lU3RhbXA7XG4gICAgICAgIH0pO1xuICAgICAgfSkuYWRkQ2FzZShtdXRhdGlvblRodW5rLnJlamVjdGVkLCAoZHJhZnQsIHtcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIG1ldGFcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKCFtZXRhLmFyZy50cmFjaylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHVwZGF0ZU11dGF0aW9uU3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgbWV0YSwgKHN1YnN0YXRlKSA9PiB7XG4gICAgICAgICAgaWYgKHN1YnN0YXRlLnJlcXVlc3RJZCAhPT0gbWV0YS5yZXF1ZXN0SWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgc3Vic3RhdGUuc3RhdHVzID0gXCJyZWplY3RlZFwiIC8qIHJlamVjdGVkICovO1xuICAgICAgICAgIHN1YnN0YXRlLmVycm9yID0gcGF5bG9hZCA/PyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICB9KS5hZGRNYXRjaGVyKGhhc1JlaHlkcmF0aW9uSW5mbywgKGRyYWZ0LCBhY3Rpb24pID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG11dGF0aW9uc1xuICAgICAgICB9ID0gZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyhhY3Rpb24pO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGVudHJ5XSBvZiBPYmplY3QuZW50cmllcyhtdXRhdGlvbnMpKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gZG8gbm90IHJlaHlkcmF0ZSBlbnRyaWVzIHRoYXQgd2VyZSBjdXJyZW50bHkgaW4gZmxpZ2h0LlxuICAgICAgICAgICAgKGVudHJ5Py5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIgLyogZnVsZmlsbGVkICovIHx8IGVudHJ5Py5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIiAvKiByZWplY3RlZCAqLykgJiYgLy8gb25seSByZWh5ZHJhdGUgZW5kcG9pbnRzIHRoYXQgd2VyZSBwZXJzaXN0ZWQgdXNpbmcgYSBgZml4ZWRDYWNoZUtleWBcbiAgICAgICAgICAgIGtleSAhPT0gZW50cnk/LnJlcXVlc3RJZFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZHJhZnRba2V5XSA9IGVudHJ5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgaW52YWxpZGF0aW9uU2xpY2UgPSBjcmVhdGVTbGljZSh7XG4gICAgbmFtZTogYCR7cmVkdWNlclBhdGh9L2ludmFsaWRhdGlvbmAsXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIHJlZHVjZXJzOiB7XG4gICAgICB1cGRhdGVQcm92aWRlZEJ5OiB7XG4gICAgICAgIHJlZHVjZXIoZHJhZnQsIGFjdGlvbikge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgICAgICBwcm92aWRlZFRhZ3NcbiAgICAgICAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgICAgZm9yIChjb25zdCB0YWdUeXBlU3Vic2NyaXB0aW9ucyBvZiBPYmplY3QudmFsdWVzKGRyYWZ0KSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZFN1YnNjcmlwdGlvbnMgb2YgT2JqZWN0LnZhbHVlcyh0YWdUeXBlU3Vic2NyaXB0aW9ucykpIHtcbiAgICAgICAgICAgICAgY29uc3QgZm91bmRBdCA9IGlkU3Vic2NyaXB0aW9ucy5pbmRleE9mKHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgICAgICAgICBpZiAoZm91bmRBdCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZFN1YnNjcmlwdGlvbnMuc3BsaWNlKGZvdW5kQXQsIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgfSBvZiBwcm92aWRlZFRhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZWRRdWVyaWVzID0gKGRyYWZ0W3R5cGVdID8/PSB7fSlbaWQgfHwgXCJfX2ludGVybmFsX3dpdGhvdXRfaWRcIl0gPz89IFtdO1xuICAgICAgICAgICAgY29uc3QgYWxyZWFkeVN1YnNjcmliZWQgPSBzdWJzY3JpYmVkUXVlcmllcy5pbmNsdWRlcyhxdWVyeUNhY2hlS2V5KTtcbiAgICAgICAgICAgIGlmICghYWxyZWFkeVN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgc3Vic2NyaWJlZFF1ZXJpZXMucHVzaChxdWVyeUNhY2hlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcmU6IHByZXBhcmVBdXRvQmF0Y2hlZCgpXG4gICAgICB9XG4gICAgfSxcbiAgICBleHRyYVJlZHVjZXJzKGJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkQ2FzZShxdWVyeVNsaWNlLmFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQsIChkcmFmdCwge1xuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgICB9XG4gICAgICB9KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgdGFnVHlwZVN1YnNjcmlwdGlvbnMgb2YgT2JqZWN0LnZhbHVlcyhkcmFmdCkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGlkU3Vic2NyaXB0aW9ucyBvZiBPYmplY3QudmFsdWVzKHRhZ1R5cGVTdWJzY3JpcHRpb25zKSkge1xuICAgICAgICAgICAgY29uc3QgZm91bmRBdCA9IGlkU3Vic2NyaXB0aW9ucy5pbmRleE9mKHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgICAgICAgaWYgKGZvdW5kQXQgIT09IC0xKSB7XG4gICAgICAgICAgICAgIGlkU3Vic2NyaXB0aW9ucy5zcGxpY2UoZm91bmRBdCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KS5hZGRNYXRjaGVyKGhhc1JlaHlkcmF0aW9uSW5mbywgKGRyYWZ0LCBhY3Rpb24pID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHByb3ZpZGVkXG4gICAgICAgIH0gPSBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbik7XG4gICAgICAgIGZvciAoY29uc3QgW3R5cGUsIGluY29taW5nVGFnc10gb2YgT2JqZWN0LmVudHJpZXMocHJvdmlkZWQpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbaWQsIGNhY2hlS2V5c10gb2YgT2JqZWN0LmVudHJpZXMoaW5jb21pbmdUYWdzKSkge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlZFF1ZXJpZXMgPSAoZHJhZnRbdHlwZV0gPz89IHt9KVtpZCB8fCBcIl9faW50ZXJuYWxfd2l0aG91dF9pZFwiXSA/Pz0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHF1ZXJ5Q2FjaGVLZXkgb2YgY2FjaGVLZXlzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFscmVhZHlTdWJzY3JpYmVkID0gc3Vic2NyaWJlZFF1ZXJpZXMuaW5jbHVkZXMocXVlcnlDYWNoZUtleSk7XG4gICAgICAgICAgICAgIGlmICghYWxyZWFkeVN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVkUXVlcmllcy5wdXNoKHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KS5hZGRNYXRjaGVyKGlzQW55T2YoaXNGdWxmaWxsZWQocXVlcnlUaHVuayksIGlzUmVqZWN0ZWRXaXRoVmFsdWUocXVlcnlUaHVuaykpLCAoZHJhZnQsIGFjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBwcm92aWRlZFRhZ3MgPSBjYWxjdWxhdGVQcm92aWRlZEJ5VGh1bmsoYWN0aW9uLCBcInByb3ZpZGVzVGFnc1wiLCBkZWZpbml0aW9ucywgYXNzZXJ0VGFnVHlwZSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICAgIH0gPSBhY3Rpb24ubWV0YS5hcmc7XG4gICAgICAgIGludmFsaWRhdGlvblNsaWNlLmNhc2VSZWR1Y2Vycy51cGRhdGVQcm92aWRlZEJ5KGRyYWZ0LCBpbnZhbGlkYXRpb25TbGljZS5hY3Rpb25zLnVwZGF0ZVByb3ZpZGVkQnkoe1xuICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgICAgcHJvdmlkZWRUYWdzXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHN1YnNjcmlwdGlvblNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6IGAke3JlZHVjZXJQYXRofS9zdWJzY3JpcHRpb25zYCxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgcmVkdWNlcnM6IHtcbiAgICAgIHVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMoZCwgYSkge1xuICAgICAgfSxcbiAgICAgIHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQoZCwgYSkge1xuICAgICAgfSxcbiAgICAgIGludGVybmFsX2dldFJUS1FTdWJzY3JpcHRpb25zKCkge1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGludGVybmFsU3Vic2NyaXB0aW9uc1NsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6IGAke3JlZHVjZXJQYXRofS9pbnRlcm5hbFN1YnNjcmlwdGlvbnNgLFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICByZWR1Y2Vyczoge1xuICAgICAgc3Vic2NyaXB0aW9uc1VwZGF0ZWQ6IHtcbiAgICAgICAgcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGFwcGx5UGF0Y2hlcyhzdGF0ZSwgYWN0aW9uLnBheWxvYWQpO1xuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJlOiBwcmVwYXJlQXV0b0JhdGNoZWQoKVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGNvbmZpZ1NsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6IGAke3JlZHVjZXJQYXRofS9jb25maWdgLFxuICAgIGluaXRpYWxTdGF0ZToge1xuICAgICAgb25saW5lOiBpc09ubGluZSgpLFxuICAgICAgZm9jdXNlZDogaXNEb2N1bWVudFZpc2libGUoKSxcbiAgICAgIG1pZGRsZXdhcmVSZWdpc3RlcmVkOiBmYWxzZSxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH0sXG4gICAgcmVkdWNlcnM6IHtcbiAgICAgIG1pZGRsZXdhcmVSZWdpc3RlcmVkKHN0YXRlLCB7XG4gICAgICAgIHBheWxvYWRcbiAgICAgIH0pIHtcbiAgICAgICAgc3RhdGUubWlkZGxld2FyZVJlZ2lzdGVyZWQgPSBzdGF0ZS5taWRkbGV3YXJlUmVnaXN0ZXJlZCA9PT0gXCJjb25mbGljdFwiIHx8IGFwaVVpZCAhPT0gcGF5bG9hZCA/IFwiY29uZmxpY3RcIiA6IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBleHRyYVJlZHVjZXJzOiAoYnVpbGRlcikgPT4ge1xuICAgICAgYnVpbGRlci5hZGRDYXNlKG9uT25saW5lLCAoc3RhdGUpID0+IHtcbiAgICAgICAgc3RhdGUub25saW5lID0gdHJ1ZTtcbiAgICAgIH0pLmFkZENhc2Uob25PZmZsaW5lLCAoc3RhdGUpID0+IHtcbiAgICAgICAgc3RhdGUub25saW5lID0gZmFsc2U7XG4gICAgICB9KS5hZGRDYXNlKG9uRm9jdXMsIChzdGF0ZSkgPT4ge1xuICAgICAgICBzdGF0ZS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgIH0pLmFkZENhc2Uob25Gb2N1c0xvc3QsIChzdGF0ZSkgPT4ge1xuICAgICAgICBzdGF0ZS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICB9KS5hZGRNYXRjaGVyKGhhc1JlaHlkcmF0aW9uSW5mbywgKGRyYWZ0KSA9PiAoe1xuICAgICAgICAuLi5kcmFmdFxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGNvbWJpbmVkUmVkdWNlciA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gICAgcXVlcmllczogcXVlcnlTbGljZS5yZWR1Y2VyLFxuICAgIG11dGF0aW9uczogbXV0YXRpb25TbGljZS5yZWR1Y2VyLFxuICAgIHByb3ZpZGVkOiBpbnZhbGlkYXRpb25TbGljZS5yZWR1Y2VyLFxuICAgIHN1YnNjcmlwdGlvbnM6IGludGVybmFsU3Vic2NyaXB0aW9uc1NsaWNlLnJlZHVjZXIsXG4gICAgY29uZmlnOiBjb25maWdTbGljZS5yZWR1Y2VyXG4gIH0pO1xuICBjb25zdCByZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IGNvbWJpbmVkUmVkdWNlcihyZXNldEFwaVN0YXRlLm1hdGNoKGFjdGlvbikgPyB2b2lkIDAgOiBzdGF0ZSwgYWN0aW9uKTtcbiAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAuLi5jb25maWdTbGljZS5hY3Rpb25zLFxuICAgIC4uLnF1ZXJ5U2xpY2UuYWN0aW9ucyxcbiAgICAuLi5zdWJzY3JpcHRpb25TbGljZS5hY3Rpb25zLFxuICAgIC4uLmludGVybmFsU3Vic2NyaXB0aW9uc1NsaWNlLmFjdGlvbnMsXG4gICAgLi4ubXV0YXRpb25TbGljZS5hY3Rpb25zLFxuICAgIC4uLmludmFsaWRhdGlvblNsaWNlLmFjdGlvbnMsXG4gICAgcmVzZXRBcGlTdGF0ZVxuICB9O1xuICByZXR1cm4ge1xuICAgIHJlZHVjZXIsXG4gICAgYWN0aW9uc1xuICB9O1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZFNlbGVjdG9ycy50c1xudmFyIHNraXBUb2tlbiA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiUlRLUS9za2lwVG9rZW5cIik7XG52YXIgaW5pdGlhbFN1YlN0YXRlID0ge1xuICBzdGF0dXM6IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi9cbn07XG52YXIgZGVmYXVsdFF1ZXJ5U3ViU3RhdGUgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlTmV4dFN0YXRlKGluaXRpYWxTdWJTdGF0ZSwgKCkgPT4ge1xufSk7XG52YXIgZGVmYXVsdE11dGF0aW9uU3ViU3RhdGUgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlTmV4dFN0YXRlKGluaXRpYWxTdWJTdGF0ZSwgKCkgPT4ge1xufSk7XG5mdW5jdGlvbiBidWlsZFNlbGVjdG9ycyh7XG4gIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgcmVkdWNlclBhdGhcbn0pIHtcbiAgY29uc3Qgc2VsZWN0U2tpcHBlZFF1ZXJ5ID0gKHN0YXRlKSA9PiBkZWZhdWx0UXVlcnlTdWJTdGF0ZTtcbiAgY29uc3Qgc2VsZWN0U2tpcHBlZE11dGF0aW9uID0gKHN0YXRlKSA9PiBkZWZhdWx0TXV0YXRpb25TdWJTdGF0ZTtcbiAgcmV0dXJuIHtcbiAgICBidWlsZFF1ZXJ5U2VsZWN0b3IsXG4gICAgYnVpbGRNdXRhdGlvblNlbGVjdG9yLFxuICAgIHNlbGVjdEludmFsaWRhdGVkQnksXG4gICAgc2VsZWN0Q2FjaGVkQXJnc0ZvclF1ZXJ5XG4gIH07XG4gIGZ1bmN0aW9uIHdpdGhSZXF1ZXN0RmxhZ3Moc3Vic3RhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3Vic3RhdGUsXG4gICAgICAuLi5nZXRSZXF1ZXN0U3RhdHVzRmxhZ3Moc3Vic3RhdGUuc3RhdHVzKVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0SW50ZXJuYWxTdGF0ZShyb290U3RhdGUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHJvb3RTdGF0ZVtyZWR1Y2VyUGF0aF07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICBpZiAoc2VsZWN0SW50ZXJuYWxTdGF0ZS50cmlnZ2VyZWQpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICBzZWxlY3RJbnRlcm5hbFN0YXRlLnRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yOiBObyBkYXRhIGZvdW5kIGF0IFxcYHN0YXRlLiR7cmVkdWNlclBhdGh9XFxgLiBEaWQgeW91IGZvcmdldCB0byBhZGQgdGhlIHJlZHVjZXIgdG8gdGhlIHN0b3JlP2ApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRRdWVyeVNlbGVjdG9yKGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uKSB7XG4gICAgcmV0dXJuIChxdWVyeUFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRBcmdzID0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzLFxuICAgICAgICBlbmRwb2ludERlZmluaXRpb24sXG4gICAgICAgIGVuZHBvaW50TmFtZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBzZWxlY3RRdWVyeVN1YnN0YXRlID0gKHN0YXRlKSA9PiBzZWxlY3RJbnRlcm5hbFN0YXRlKHN0YXRlKT8ucXVlcmllcz8uW3NlcmlhbGl6ZWRBcmdzXSA/PyBkZWZhdWx0UXVlcnlTdWJTdGF0ZTtcbiAgICAgIGNvbnN0IGZpbmFsU2VsZWN0UXVlcnlTdWJTdGF0ZSA9IHF1ZXJ5QXJncyA9PT0gc2tpcFRva2VuID8gc2VsZWN0U2tpcHBlZFF1ZXJ5IDogc2VsZWN0UXVlcnlTdWJzdGF0ZTtcbiAgICAgIHJldHVybiBjcmVhdGVTZWxlY3RvcihmaW5hbFNlbGVjdFF1ZXJ5U3ViU3RhdGUsIHdpdGhSZXF1ZXN0RmxhZ3MpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRNdXRhdGlvblNlbGVjdG9yKCkge1xuICAgIHJldHVybiAoaWQpID0+IHtcbiAgICAgIGxldCBtdXRhdGlvbklkO1xuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBtdXRhdGlvbklkID0gZ2V0TXV0YXRpb25DYWNoZUtleShpZCkgPz8gc2tpcFRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXV0YXRpb25JZCA9IGlkO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0TXV0YXRpb25TdWJzdGF0ZSA9IChzdGF0ZSkgPT4gc2VsZWN0SW50ZXJuYWxTdGF0ZShzdGF0ZSk/Lm11dGF0aW9ucz8uW211dGF0aW9uSWRdID8/IGRlZmF1bHRNdXRhdGlvblN1YlN0YXRlO1xuICAgICAgY29uc3QgZmluYWxTZWxlY3RNdXRhdGlvblN1YnN0YXRlID0gbXV0YXRpb25JZCA9PT0gc2tpcFRva2VuID8gc2VsZWN0U2tpcHBlZE11dGF0aW9uIDogc2VsZWN0TXV0YXRpb25TdWJzdGF0ZTtcbiAgICAgIHJldHVybiBjcmVhdGVTZWxlY3RvcihmaW5hbFNlbGVjdE11dGF0aW9uU3Vic3RhdGUsIHdpdGhSZXF1ZXN0RmxhZ3MpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0SW52YWxpZGF0ZWRCeShzdGF0ZSwgdGFncykge1xuICAgIGNvbnN0IGFwaVN0YXRlID0gc3RhdGVbcmVkdWNlclBhdGhdO1xuICAgIGNvbnN0IHRvSW52YWxpZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGFncy5tYXAoZXhwYW5kVGFnRGVzY3JpcHRpb24pKSB7XG4gICAgICBjb25zdCBwcm92aWRlZCA9IGFwaVN0YXRlLnByb3ZpZGVkW3RhZy50eXBlXTtcbiAgICAgIGlmICghcHJvdmlkZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgaW52YWxpZGF0ZVN1YnNjcmlwdGlvbnMgPSAodGFnLmlkICE9PSB2b2lkIDAgPyAoXG4gICAgICAgIC8vIGlkIGdpdmVuOiBpbnZhbGlkYXRlIGFsbCBxdWVyaWVzIHRoYXQgcHJvdmlkZSB0aGlzIHR5cGUgJiBpZFxuICAgICAgICBwcm92aWRlZFt0YWcuaWRdXG4gICAgICApIDogKFxuICAgICAgICAvLyBubyBpZDogaW52YWxpZGF0ZSBhbGwgcXVlcmllcyB0aGF0IHByb3ZpZGUgdGhpcyB0eXBlXG4gICAgICAgIGZsYXR0ZW4oT2JqZWN0LnZhbHVlcyhwcm92aWRlZCkpXG4gICAgICApKSA/PyBbXTtcbiAgICAgIGZvciAoY29uc3QgaW52YWxpZGF0ZSBvZiBpbnZhbGlkYXRlU3Vic2NyaXB0aW9ucykge1xuICAgICAgICB0b0ludmFsaWRhdGUuYWRkKGludmFsaWRhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmxhdHRlbihBcnJheS5mcm9tKHRvSW52YWxpZGF0ZS52YWx1ZXMoKSkubWFwKChxdWVyeUNhY2hlS2V5KSA9PiB7XG4gICAgICBjb25zdCBxdWVyeVN1YlN0YXRlID0gYXBpU3RhdGUucXVlcmllc1txdWVyeUNhY2hlS2V5XTtcbiAgICAgIHJldHVybiBxdWVyeVN1YlN0YXRlID8gW3tcbiAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgZW5kcG9pbnROYW1lOiBxdWVyeVN1YlN0YXRlLmVuZHBvaW50TmFtZSxcbiAgICAgICAgb3JpZ2luYWxBcmdzOiBxdWVyeVN1YlN0YXRlLm9yaWdpbmFsQXJnc1xuICAgICAgfV0gOiBbXTtcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gc2VsZWN0Q2FjaGVkQXJnc0ZvclF1ZXJ5KHN0YXRlLCBxdWVyeU5hbWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzdGF0ZVtyZWR1Y2VyUGF0aF0ucXVlcmllcykuZmlsdGVyKChlbnRyeSkgPT4gZW50cnk/LmVuZHBvaW50TmFtZSA9PT0gcXVlcnlOYW1lICYmIGVudHJ5LnN0YXR1cyAhPT0gXCJ1bmluaXRpYWxpemVkXCIgLyogdW5pbml0aWFsaXplZCAqLykubWFwKChlbnRyeSkgPT4gZW50cnkub3JpZ2luYWxBcmdzKTtcbiAgfVxufVxuXG4vLyBzcmMvcXVlcnkvZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncy50c1xudmFyIGNhY2hlID0gV2Vha01hcCA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpIDogdm9pZCAwO1xudmFyIGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MgPSAoe1xuICBlbmRwb2ludE5hbWUsXG4gIHF1ZXJ5QXJnc1xufSkgPT4ge1xuICBsZXQgc2VyaWFsaXplZCA9IFwiXCI7XG4gIGNvbnN0IGNhY2hlZCA9IGNhY2hlPy5nZXQocXVlcnlBcmdzKTtcbiAgaWYgKHR5cGVvZiBjYWNoZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBzZXJpYWxpemVkID0gY2FjaGVkO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0cmluZ2lmaWVkID0gSlNPTi5zdHJpbmdpZnkocXVlcnlBcmdzLCAoa2V5LCB2YWx1ZSkgPT4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyBPYmplY3Qua2V5cyh2YWx1ZSkuc29ydCgpLnJlZHVjZSgoYWNjLCBrZXkyKSA9PiB7XG4gICAgICBhY2Nba2V5Ml0gPSB2YWx1ZVtrZXkyXTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pIDogdmFsdWUpO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHF1ZXJ5QXJncykpIHtcbiAgICAgIGNhY2hlPy5zZXQocXVlcnlBcmdzLCBzdHJpbmdpZmllZCk7XG4gICAgfVxuICAgIHNlcmlhbGl6ZWQgPSBzdHJpbmdpZmllZDtcbiAgfVxuICByZXR1cm4gYCR7ZW5kcG9pbnROYW1lfSgke3NlcmlhbGl6ZWR9KWA7XG59O1xuXG4vLyBzcmMvcXVlcnkvY3JlYXRlQXBpLnRzXG5pbXBvcnQgeyB3ZWFrTWFwTWVtb2l6ZSB9IGZyb20gXCJyZXNlbGVjdFwiO1xuZnVuY3Rpb24gYnVpbGRDcmVhdGVBcGkoLi4ubW9kdWxlcykge1xuICByZXR1cm4gZnVuY3Rpb24gYmFzZUNyZWF0ZUFwaShvcHRpb25zKSB7XG4gICAgY29uc3QgZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyA9IHdlYWtNYXBNZW1vaXplKChhY3Rpb24pID0+IG9wdGlvbnMuZXh0cmFjdFJlaHlkcmF0aW9uSW5mbz8uKGFjdGlvbiwge1xuICAgICAgcmVkdWNlclBhdGg6IG9wdGlvbnMucmVkdWNlclBhdGggPz8gXCJhcGlcIlxuICAgIH0pKTtcbiAgICBjb25zdCBvcHRpb25zV2l0aERlZmF1bHRzID0ge1xuICAgICAgcmVkdWNlclBhdGg6IFwiYXBpXCIsXG4gICAgICBrZWVwVW51c2VkRGF0YUZvcjogNjAsXG4gICAgICByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlOiBmYWxzZSxcbiAgICAgIHJlZmV0Y2hPbkZvY3VzOiBmYWxzZSxcbiAgICAgIHJlZmV0Y2hPblJlY29ubmVjdDogZmFsc2UsXG4gICAgICBpbnZhbGlkYXRpb25CZWhhdmlvcjogXCJkZWxheWVkXCIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyxcbiAgICAgIHNlcmlhbGl6ZVF1ZXJ5QXJncyhxdWVyeUFyZ3NBcGkpIHtcbiAgICAgICAgbGV0IGZpbmFsU2VyaWFsaXplUXVlcnlBcmdzID0gZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncztcbiAgICAgICAgaWYgKFwic2VyaWFsaXplUXVlcnlBcmdzXCIgaW4gcXVlcnlBcmdzQXBpLmVuZHBvaW50RGVmaW5pdGlvbikge1xuICAgICAgICAgIGNvbnN0IGVuZHBvaW50U1FBID0gcXVlcnlBcmdzQXBpLmVuZHBvaW50RGVmaW5pdGlvbi5zZXJpYWxpemVRdWVyeUFyZ3M7XG4gICAgICAgICAgZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MgPSAocXVlcnlBcmdzQXBpMikgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFJlc3VsdCA9IGVuZHBvaW50U1FBKHF1ZXJ5QXJnc0FwaTIpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsUmVzdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbml0aWFsUmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3Moe1xuICAgICAgICAgICAgICAgIC4uLnF1ZXJ5QXJnc0FwaTIsXG4gICAgICAgICAgICAgICAgcXVlcnlBcmdzOiBpbml0aWFsUmVzdWx0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJpYWxpemVRdWVyeUFyZ3MpIHtcbiAgICAgICAgICBmaW5hbFNlcmlhbGl6ZVF1ZXJ5QXJncyA9IG9wdGlvbnMuc2VyaWFsaXplUXVlcnlBcmdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5hbFNlcmlhbGl6ZVF1ZXJ5QXJncyhxdWVyeUFyZ3NBcGkpO1xuICAgICAgfSxcbiAgICAgIHRhZ1R5cGVzOiBbLi4ub3B0aW9ucy50YWdUeXBlcyB8fCBbXV1cbiAgICB9O1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBlbmRwb2ludERlZmluaXRpb25zOiB7fSxcbiAgICAgIGJhdGNoKGZuKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9LFxuICAgICAgYXBpVWlkOiBuYW5vaWQoKSxcbiAgICAgIGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8sXG4gICAgICBoYXNSZWh5ZHJhdGlvbkluZm86IHdlYWtNYXBNZW1vaXplKChhY3Rpb24pID0+IGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8oYWN0aW9uKSAhPSBudWxsKVxuICAgIH07XG4gICAgY29uc3QgYXBpID0ge1xuICAgICAgaW5qZWN0RW5kcG9pbnRzLFxuICAgICAgZW5oYW5jZUVuZHBvaW50cyh7XG4gICAgICAgIGFkZFRhZ1R5cGVzLFxuICAgICAgICBlbmRwb2ludHNcbiAgICAgIH0pIHtcbiAgICAgICAgaWYgKGFkZFRhZ1R5cGVzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBlVCBvZiBhZGRUYWdUeXBlcykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zV2l0aERlZmF1bHRzLnRhZ1R5cGVzLmluY2x1ZGVzKGVUKSkge1xuICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgIG9wdGlvbnNXaXRoRGVmYXVsdHMudGFnVHlwZXMucHVzaChlVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRwb2ludHMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtlbmRwb2ludE5hbWUsIHBhcnRpYWxEZWZpbml0aW9uXSBvZiBPYmplY3QuZW50cmllcyhlbmRwb2ludHMpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnRpYWxEZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgcGFydGlhbERlZmluaXRpb24oY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXSB8fCB7fSwgcGFydGlhbERlZmluaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5pdGlhbGl6ZWRNb2R1bGVzID0gbW9kdWxlcy5tYXAoKG0pID0+IG0uaW5pdChhcGksIG9wdGlvbnNXaXRoRGVmYXVsdHMsIGNvbnRleHQpKTtcbiAgICBmdW5jdGlvbiBpbmplY3RFbmRwb2ludHMoaW5qZWN0KSB7XG4gICAgICBjb25zdCBldmFsdWF0ZWRFbmRwb2ludHMgPSBpbmplY3QuZW5kcG9pbnRzKHtcbiAgICAgICAgcXVlcnk6ICh4KSA9PiAoe1xuICAgICAgICAgIC4uLngsXG4gICAgICAgICAgdHlwZTogXCJxdWVyeVwiIC8qIHF1ZXJ5ICovXG4gICAgICAgIH0pLFxuICAgICAgICBtdXRhdGlvbjogKHgpID0+ICh7XG4gICAgICAgICAgLi4ueCxcbiAgICAgICAgICB0eXBlOiBcIm11dGF0aW9uXCIgLyogbXV0YXRpb24gKi9cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCBbZW5kcG9pbnROYW1lLCBkZWZpbml0aW9uXSBvZiBPYmplY3QuZW50cmllcyhldmFsdWF0ZWRFbmRwb2ludHMpKSB7XG4gICAgICAgIGlmICghaW5qZWN0Lm92ZXJyaWRlRXhpc3RpbmcgJiYgZW5kcG9pbnROYW1lIGluIGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9ucykge1xuICAgICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBjYWxsZWQgXFxgaW5qZWN0RW5kcG9pbnRzXFxgIHRvIG92ZXJyaWRlIGFscmVhZHktZXhpc3RpbmcgZW5kcG9pbnROYW1lICR7ZW5kcG9pbnROYW1lfSB3aXRob3V0IHNwZWNpZnlpbmcgXFxgb3ZlcnJpZGVFeGlzdGluZzogdHJ1ZVxcYGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXSA9IGRlZmluaXRpb247XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiBpbml0aWFsaXplZE1vZHVsZXMpIHtcbiAgICAgICAgICBtLmluamVjdEVuZHBvaW50KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcGk7XG4gICAgfVxuICAgIHJldHVybiBhcGkuaW5qZWN0RW5kcG9pbnRzKHtcbiAgICAgIGVuZHBvaW50czogb3B0aW9ucy5lbmRwb2ludHNcbiAgICB9KTtcbiAgfTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2Zha2VCYXNlUXVlcnkudHNcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcbmZ1bmN0aW9uIGZha2VCYXNlUXVlcnkoKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDMzKSA6IFwiV2hlbiB1c2luZyBgZmFrZUJhc2VRdWVyeWAsIGFsbCBxdWVyaWVzICYgbXV0YXRpb25zIG11c3QgdXNlIHRoZSBgcXVlcnlGbmAgZGVmaW5pdGlvbiBzeW50YXguXCIpO1xuICB9O1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvY2FjaGVDb2xsZWN0aW9uLnRzXG5mdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICBmb3IgKGxldCBrIGluIG9iaikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbnZhciBUSElSVFlfVFdPX0JJVF9NQVhfVElNRVJfU0VDT05EUyA9IDIxNDc0ODM2NDcgLyAxZTMgLSAxO1xudmFyIGJ1aWxkQ2FjaGVDb2xsZWN0aW9uSGFuZGxlciA9ICh7XG4gIHJlZHVjZXJQYXRoLFxuICBhcGksXG4gIGNvbnRleHQsXG4gIGludGVybmFsU3RhdGVcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIHJlbW92ZVF1ZXJ5UmVzdWx0LFxuICAgIHVuc3Vic2NyaWJlUXVlcnlSZXN1bHRcbiAgfSA9IGFwaS5pbnRlcm5hbEFjdGlvbnM7XG4gIGZ1bmN0aW9uIGFueVN1YnNjcmlwdGlvbnNSZW1haW5pbmdGb3JLZXkocXVlcnlDYWNoZUtleSkge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldO1xuICAgIHJldHVybiAhIXN1YnNjcmlwdGlvbnMgJiYgIWlzT2JqZWN0RW1wdHkoc3Vic2NyaXB0aW9ucyk7XG4gIH1cbiAgY29uc3QgY3VycmVudFJlbW92YWxUaW1lb3V0cyA9IHt9O1xuICBjb25zdCBoYW5kbGVyID0gKGFjdGlvbiwgbXdBcGksIGludGVybmFsU3RhdGUyKSA9PiB7XG4gICAgaWYgKHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgaGFuZGxlVW5zdWJzY3JpYmUocXVlcnlDYWNoZUtleSwgc3RhdGUucXVlcmllc1txdWVyeUNhY2hlS2V5XT8uZW5kcG9pbnROYW1lLCBtd0FwaSwgc3RhdGUuY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB0aW1lb3V0XSBvZiBPYmplY3QuZW50cmllcyhjdXJyZW50UmVtb3ZhbFRpbWVvdXRzKSkge1xuICAgICAgICBpZiAodGltZW91dClcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIGRlbGV0ZSBjdXJyZW50UmVtb3ZhbFRpbWVvdXRzW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0Lmhhc1JlaHlkcmF0aW9uSW5mbyhhY3Rpb24pKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IG13QXBpLmdldFN0YXRlKClbcmVkdWNlclBhdGhdO1xuICAgICAgY29uc3Qge1xuICAgICAgICBxdWVyaWVzXG4gICAgICB9ID0gY29udGV4dC5leHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbik7XG4gICAgICBmb3IgKGNvbnN0IFtxdWVyeUNhY2hlS2V5LCBxdWVyeVN0YXRlXSBvZiBPYmplY3QuZW50cmllcyhxdWVyaWVzKSkge1xuICAgICAgICBoYW5kbGVVbnN1YnNjcmliZShxdWVyeUNhY2hlS2V5LCBxdWVyeVN0YXRlPy5lbmRwb2ludE5hbWUsIG13QXBpLCBzdGF0ZS5jb25maWcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gaGFuZGxlVW5zdWJzY3JpYmUocXVlcnlDYWNoZUtleSwgZW5kcG9pbnROYW1lLCBhcGkyLCBjb25maWcpIHtcbiAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXTtcbiAgICBjb25zdCBrZWVwVW51c2VkRGF0YUZvciA9IGVuZHBvaW50RGVmaW5pdGlvbj8ua2VlcFVudXNlZERhdGFGb3IgPz8gY29uZmlnLmtlZXBVbnVzZWREYXRhRm9yO1xuICAgIGlmIChrZWVwVW51c2VkRGF0YUZvciA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZmluYWxLZWVwVW51c2VkRGF0YUZvciA9IE1hdGgubWF4KDAsIE1hdGgubWluKGtlZXBVbnVzZWREYXRhRm9yLCBUSElSVFlfVFdPX0JJVF9NQVhfVElNRVJfU0VDT05EUykpO1xuICAgIGlmICghYW55U3Vic2NyaXB0aW9uc1JlbWFpbmluZ0ZvcktleShxdWVyeUNhY2hlS2V5KSkge1xuICAgICAgY29uc3QgY3VycmVudFRpbWVvdXQgPSBjdXJyZW50UmVtb3ZhbFRpbWVvdXRzW3F1ZXJ5Q2FjaGVLZXldO1xuICAgICAgaWYgKGN1cnJlbnRUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChjdXJyZW50VGltZW91dCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50UmVtb3ZhbFRpbWVvdXRzW3F1ZXJ5Q2FjaGVLZXldID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghYW55U3Vic2NyaXB0aW9uc1JlbWFpbmluZ0ZvcktleShxdWVyeUNhY2hlS2V5KSkge1xuICAgICAgICAgIGFwaTIuZGlzcGF0Y2gocmVtb3ZlUXVlcnlSZXN1bHQoe1xuICAgICAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgY3VycmVudFJlbW92YWxUaW1lb3V0c1txdWVyeUNhY2hlS2V5XTtcbiAgICAgIH0sIGZpbmFsS2VlcFVudXNlZERhdGFGb3IgKiAxZTMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGFuZGxlcjtcbn07XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9pbnZhbGlkYXRpb25CeVRhZ3MudHNcbnZhciBidWlsZEludmFsaWRhdGlvbkJ5VGFnc0hhbmRsZXIgPSAoe1xuICByZWR1Y2VyUGF0aCxcbiAgY29udGV4dCxcbiAgY29udGV4dDoge1xuICAgIGVuZHBvaW50RGVmaW5pdGlvbnNcbiAgfSxcbiAgbXV0YXRpb25UaHVuayxcbiAgcXVlcnlUaHVuayxcbiAgYXBpLFxuICBhc3NlcnRUYWdUeXBlLFxuICByZWZldGNoUXVlcnksXG4gIGludGVybmFsU3RhdGVcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIHJlbW92ZVF1ZXJ5UmVzdWx0XG4gIH0gPSBhcGkuaW50ZXJuYWxBY3Rpb25zO1xuICBjb25zdCBpc1RodW5rQWN0aW9uV2l0aFRhZ3MgPSBpc0FueU9mKGlzRnVsZmlsbGVkKG11dGF0aW9uVGh1bmspLCBpc1JlamVjdGVkV2l0aFZhbHVlKG11dGF0aW9uVGh1bmspKTtcbiAgY29uc3QgaXNRdWVyeUVuZCA9IGlzQW55T2YoaXNGdWxmaWxsZWQobXV0YXRpb25UaHVuaywgcXVlcnlUaHVuayksIGlzUmVqZWN0ZWQobXV0YXRpb25UaHVuaywgcXVlcnlUaHVuaykpO1xuICBsZXQgcGVuZGluZ1RhZ0ludmFsaWRhdGlvbnMgPSBbXTtcbiAgY29uc3QgaGFuZGxlciA9IChhY3Rpb24sIG13QXBpKSA9PiB7XG4gICAgaWYgKGlzVGh1bmtBY3Rpb25XaXRoVGFncyhhY3Rpb24pKSB7XG4gICAgICBpbnZhbGlkYXRlVGFncyhjYWxjdWxhdGVQcm92aWRlZEJ5VGh1bmsoYWN0aW9uLCBcImludmFsaWRhdGVzVGFnc1wiLCBlbmRwb2ludERlZmluaXRpb25zLCBhc3NlcnRUYWdUeXBlKSwgbXdBcGkpO1xuICAgIH0gZWxzZSBpZiAoaXNRdWVyeUVuZChhY3Rpb24pKSB7XG4gICAgICBpbnZhbGlkYXRlVGFncyhbXSwgbXdBcGkpO1xuICAgIH0gZWxzZSBpZiAoYXBpLnV0aWwuaW52YWxpZGF0ZVRhZ3MubWF0Y2goYWN0aW9uKSkge1xuICAgICAgaW52YWxpZGF0ZVRhZ3MoY2FsY3VsYXRlUHJvdmlkZWRCeShhY3Rpb24ucGF5bG9hZCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBhc3NlcnRUYWdUeXBlKSwgbXdBcGkpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gaGFzUGVuZGluZ1JlcXVlc3RzKHN0YXRlKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3RhdGUucXVlcmllcykge1xuICAgICAgaWYgKHN0YXRlLnF1ZXJpZXNba2V5XT8uc3RhdHVzID09PSBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3RhdGUubXV0YXRpb25zKSB7XG4gICAgICBpZiAoc3RhdGUubXV0YXRpb25zW2tleV0/LnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIgLyogcGVuZGluZyAqLylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBpbnZhbGlkYXRlVGFncyhuZXdUYWdzLCBtd0FwaSkge1xuICAgIGNvbnN0IHJvb3RTdGF0ZSA9IG13QXBpLmdldFN0YXRlKCk7XG4gICAgY29uc3Qgc3RhdGUgPSByb290U3RhdGVbcmVkdWNlclBhdGhdO1xuICAgIHBlbmRpbmdUYWdJbnZhbGlkYXRpb25zLnB1c2goLi4ubmV3VGFncyk7XG4gICAgaWYgKHN0YXRlLmNvbmZpZy5pbnZhbGlkYXRpb25CZWhhdmlvciA9PT0gXCJkZWxheWVkXCIgJiYgaGFzUGVuZGluZ1JlcXVlc3RzKHN0YXRlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YWdzID0gcGVuZGluZ1RhZ0ludmFsaWRhdGlvbnM7XG4gICAgcGVuZGluZ1RhZ0ludmFsaWRhdGlvbnMgPSBbXTtcbiAgICBpZiAodGFncy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdG9JbnZhbGlkYXRlID0gYXBpLnV0aWwuc2VsZWN0SW52YWxpZGF0ZWRCeShyb290U3RhdGUsIHRhZ3MpO1xuICAgIGNvbnRleHQuYmF0Y2goKCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzQXJyYXkgPSBBcnJheS5mcm9tKHRvSW52YWxpZGF0ZS52YWx1ZXMoKSk7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgfSBvZiB2YWx1ZXNBcnJheSkge1xuICAgICAgICBjb25zdCBxdWVyeVN1YlN0YXRlID0gc3RhdGUucXVlcmllc1txdWVyeUNhY2hlS2V5XTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU3ViU3RhdGUgPSBpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldID8/IHt9O1xuICAgICAgICBpZiAocXVlcnlTdWJTdGF0ZSkge1xuICAgICAgICAgIGlmIChjb3VudE9iamVjdEtleXMoc3Vic2NyaXB0aW9uU3ViU3RhdGUpID09PSAwKSB7XG4gICAgICAgICAgICBtd0FwaS5kaXNwYXRjaChyZW1vdmVRdWVyeVJlc3VsdCh7XG4gICAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHF1ZXJ5U3ViU3RhdGUuc3RhdHVzICE9PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovKSB7XG4gICAgICAgICAgICBtd0FwaS5kaXNwYXRjaChyZWZldGNoUXVlcnkocXVlcnlTdWJTdGF0ZSwgcXVlcnlDYWNoZUtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL3BvbGxpbmcudHNcbnZhciBidWlsZFBvbGxpbmdIYW5kbGVyID0gKHtcbiAgcmVkdWNlclBhdGgsXG4gIHF1ZXJ5VGh1bmssXG4gIGFwaSxcbiAgcmVmZXRjaFF1ZXJ5LFxuICBpbnRlcm5hbFN0YXRlXG59KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRQb2xscyA9IHt9O1xuICBjb25zdCBoYW5kbGVyID0gKGFjdGlvbiwgbXdBcGkpID0+IHtcbiAgICBpZiAoYXBpLmludGVybmFsQWN0aW9ucy51cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zLm1hdGNoKGFjdGlvbikgfHwgYXBpLmludGVybmFsQWN0aW9ucy51bnN1YnNjcmliZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHVwZGF0ZVBvbGxpbmdJbnRlcnZhbChhY3Rpb24ucGF5bG9hZCwgbXdBcGkpO1xuICAgIH1cbiAgICBpZiAocXVlcnlUaHVuay5wZW5kaW5nLm1hdGNoKGFjdGlvbikgfHwgcXVlcnlUaHVuay5yZWplY3RlZC5tYXRjaChhY3Rpb24pICYmIGFjdGlvbi5tZXRhLmNvbmRpdGlvbikge1xuICAgICAgdXBkYXRlUG9sbGluZ0ludGVydmFsKGFjdGlvbi5tZXRhLmFyZywgbXdBcGkpO1xuICAgIH1cbiAgICBpZiAocXVlcnlUaHVuay5mdWxmaWxsZWQubWF0Y2goYWN0aW9uKSB8fCBxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikgJiYgIWFjdGlvbi5tZXRhLmNvbmRpdGlvbikge1xuICAgICAgc3RhcnROZXh0UG9sbChhY3Rpb24ubWV0YS5hcmcsIG13QXBpKTtcbiAgICB9XG4gICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY2xlYXJQb2xscygpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gc3RhcnROZXh0UG9sbCh7XG4gICAgcXVlcnlDYWNoZUtleVxuICB9LCBhcGkyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBhcGkyLmdldFN0YXRlKClbcmVkdWNlclBhdGhdO1xuICAgIGNvbnN0IHF1ZXJ5U3ViU3RhdGUgPSBzdGF0ZS5xdWVyaWVzW3F1ZXJ5Q2FjaGVLZXldO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldO1xuICAgIGlmICghcXVlcnlTdWJTdGF0ZSB8fCBxdWVyeVN1YlN0YXRlLnN0YXR1cyA9PT0gXCJ1bmluaXRpYWxpemVkXCIgLyogdW5pbml0aWFsaXplZCAqLylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwgPSBmaW5kTG93ZXN0UG9sbGluZ0ludGVydmFsKHN1YnNjcmlwdGlvbnMpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGxvd2VzdFBvbGxpbmdJbnRlcnZhbCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY3VycmVudFBvbGwgPSBjdXJyZW50UG9sbHNbcXVlcnlDYWNoZUtleV07XG4gICAgaWYgKGN1cnJlbnRQb2xsPy50aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoY3VycmVudFBvbGwudGltZW91dCk7XG4gICAgICBjdXJyZW50UG9sbC50aW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBuZXh0UG9sbFRpbWVzdGFtcCA9IERhdGUubm93KCkgKyBsb3dlc3RQb2xsaW5nSW50ZXJ2YWw7XG4gICAgY29uc3QgY3VycmVudEludGVydmFsID0gY3VycmVudFBvbGxzW3F1ZXJ5Q2FjaGVLZXldID0ge1xuICAgICAgbmV4dFBvbGxUaW1lc3RhbXAsXG4gICAgICBwb2xsaW5nSW50ZXJ2YWw6IGxvd2VzdFBvbGxpbmdJbnRlcnZhbCxcbiAgICAgIHRpbWVvdXQ6IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjdXJyZW50SW50ZXJ2YWwudGltZW91dCA9IHZvaWQgMDtcbiAgICAgICAgYXBpMi5kaXNwYXRjaChyZWZldGNoUXVlcnkocXVlcnlTdWJTdGF0ZSwgcXVlcnlDYWNoZUtleSkpO1xuICAgICAgfSwgbG93ZXN0UG9sbGluZ0ludGVydmFsKVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUG9sbGluZ0ludGVydmFsKHtcbiAgICBxdWVyeUNhY2hlS2V5XG4gIH0sIGFwaTIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGFwaTIuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF07XG4gICAgY29uc3QgcXVlcnlTdWJTdGF0ZSA9IHN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnNbcXVlcnlDYWNoZUtleV07XG4gICAgaWYgKCFxdWVyeVN1YlN0YXRlIHx8IHF1ZXJ5U3ViU3RhdGUuc3RhdHVzID09PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxvd2VzdFBvbGxpbmdJbnRlcnZhbCA9IGZpbmRMb3dlc3RQb2xsaW5nSW50ZXJ2YWwoc3Vic2NyaXB0aW9ucyk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobG93ZXN0UG9sbGluZ0ludGVydmFsKSkge1xuICAgICAgY2xlYW51cFBvbGxGb3JLZXkocXVlcnlDYWNoZUtleSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRQb2xsID0gY3VycmVudFBvbGxzW3F1ZXJ5Q2FjaGVLZXldO1xuICAgIGNvbnN0IG5leHRQb2xsVGltZXN0YW1wID0gRGF0ZS5ub3coKSArIGxvd2VzdFBvbGxpbmdJbnRlcnZhbDtcbiAgICBpZiAoIWN1cnJlbnRQb2xsIHx8IG5leHRQb2xsVGltZXN0YW1wIDwgY3VycmVudFBvbGwubmV4dFBvbGxUaW1lc3RhbXApIHtcbiAgICAgIHN0YXJ0TmV4dFBvbGwoe1xuICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICB9LCBhcGkyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2xlYW51cFBvbGxGb3JLZXkoa2V5KSB7XG4gICAgY29uc3QgZXhpc3RpbmdQb2xsID0gY3VycmVudFBvbGxzW2tleV07XG4gICAgaWYgKGV4aXN0aW5nUG9sbD8udGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGV4aXN0aW5nUG9sbC50aW1lb3V0KTtcbiAgICB9XG4gICAgZGVsZXRlIGN1cnJlbnRQb2xsc1trZXldO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyUG9sbHMoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY3VycmVudFBvbGxzKSkge1xuICAgICAgY2xlYW51cFBvbGxGb3JLZXkoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZmluZExvd2VzdFBvbGxpbmdJbnRlcnZhbChzdWJzY3JpYmVycyA9IHt9KSB7XG4gICAgbGV0IGxvd2VzdFBvbGxpbmdJbnRlcnZhbCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBmb3IgKGxldCBrZXkgaW4gc3Vic2NyaWJlcnMpIHtcbiAgICAgIGlmICghIXN1YnNjcmliZXJzW2tleV0ucG9sbGluZ0ludGVydmFsKSB7XG4gICAgICAgIGxvd2VzdFBvbGxpbmdJbnRlcnZhbCA9IE1hdGgubWluKHN1YnNjcmliZXJzW2tleV0ucG9sbGluZ0ludGVydmFsLCBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG93ZXN0UG9sbGluZ0ludGVydmFsO1xuICB9XG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL3dpbmRvd0V2ZW50SGFuZGxpbmcudHNcbnZhciBidWlsZFdpbmRvd0V2ZW50SGFuZGxlciA9ICh7XG4gIHJlZHVjZXJQYXRoLFxuICBjb250ZXh0LFxuICBhcGksXG4gIHJlZmV0Y2hRdWVyeSxcbiAgaW50ZXJuYWxTdGF0ZVxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmVtb3ZlUXVlcnlSZXN1bHRcbiAgfSA9IGFwaS5pbnRlcm5hbEFjdGlvbnM7XG4gIGNvbnN0IGhhbmRsZXIgPSAoYWN0aW9uLCBtd0FwaSkgPT4ge1xuICAgIGlmIChvbkZvY3VzLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJlZmV0Y2hWYWxpZFF1ZXJpZXMobXdBcGksIFwicmVmZXRjaE9uRm9jdXNcIik7XG4gICAgfVxuICAgIGlmIChvbk9ubGluZS5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZWZldGNoVmFsaWRRdWVyaWVzKG13QXBpLCBcInJlZmV0Y2hPblJlY29ubmVjdFwiKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIHJlZmV0Y2hWYWxpZFF1ZXJpZXMoYXBpMiwgdHlwZSkge1xuICAgIGNvbnN0IHN0YXRlID0gYXBpMi5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXTtcbiAgICBjb25zdCBxdWVyaWVzID0gc3RhdGUucXVlcmllcztcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucztcbiAgICBjb250ZXh0LmJhdGNoKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgcXVlcnlDYWNoZUtleSBvZiBPYmplY3Qua2V5cyhzdWJzY3JpcHRpb25zKSkge1xuICAgICAgICBjb25zdCBxdWVyeVN1YlN0YXRlID0gcXVlcmllc1txdWVyeUNhY2hlS2V5XTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU3ViU3RhdGUgPSBzdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldO1xuICAgICAgICBpZiAoIXN1YnNjcmlwdGlvblN1YlN0YXRlIHx8ICFxdWVyeVN1YlN0YXRlKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBzaG91bGRSZWZldGNoID0gT2JqZWN0LnZhbHVlcyhzdWJzY3JpcHRpb25TdWJTdGF0ZSkuc29tZSgoc3ViKSA9PiBzdWJbdHlwZV0gPT09IHRydWUpIHx8IE9iamVjdC52YWx1ZXMoc3Vic2NyaXB0aW9uU3ViU3RhdGUpLmV2ZXJ5KChzdWIpID0+IHN1Ylt0eXBlXSA9PT0gdm9pZCAwKSAmJiBzdGF0ZS5jb25maWdbdHlwZV07XG4gICAgICAgIGlmIChzaG91bGRSZWZldGNoKSB7XG4gICAgICAgICAgaWYgKGNvdW50T2JqZWN0S2V5cyhzdWJzY3JpcHRpb25TdWJTdGF0ZSkgPT09IDApIHtcbiAgICAgICAgICAgIGFwaTIuZGlzcGF0Y2gocmVtb3ZlUXVlcnlSZXN1bHQoe1xuICAgICAgICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChxdWVyeVN1YlN0YXRlLnN0YXR1cyAhPT0gXCJ1bmluaXRpYWxpemVkXCIgLyogdW5pbml0aWFsaXplZCAqLykge1xuICAgICAgICAgICAgYXBpMi5kaXNwYXRjaChyZWZldGNoUXVlcnkocXVlcnlTdWJTdGF0ZSwgcXVlcnlDYWNoZUtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2NhY2hlTGlmZWN5Y2xlLnRzXG52YXIgbmV2ZXJSZXNvbHZlZEVycm9yID0gbmV3IEVycm9yKFwiUHJvbWlzZSBuZXZlciByZXNvbHZlZCBiZWZvcmUgY2FjaGVFbnRyeVJlbW92ZWQuXCIpO1xudmFyIGJ1aWxkQ2FjaGVMaWZlY3ljbGVIYW5kbGVyID0gKHtcbiAgYXBpLFxuICByZWR1Y2VyUGF0aCxcbiAgY29udGV4dCxcbiAgcXVlcnlUaHVuayxcbiAgbXV0YXRpb25UaHVuayxcbiAgaW50ZXJuYWxTdGF0ZVxufSkgPT4ge1xuICBjb25zdCBpc1F1ZXJ5VGh1bmsgPSBpc0FzeW5jVGh1bmtBY3Rpb24ocXVlcnlUaHVuayk7XG4gIGNvbnN0IGlzTXV0YXRpb25UaHVuayA9IGlzQXN5bmNUaHVua0FjdGlvbihtdXRhdGlvblRodW5rKTtcbiAgY29uc3QgaXNGdWxmaWxsZWRUaHVuayA9IGlzRnVsZmlsbGVkKHF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmspO1xuICBjb25zdCBsaWZlY3ljbGVNYXAgPSB7fTtcbiAgY29uc3QgaGFuZGxlciA9IChhY3Rpb24sIG13QXBpLCBzdGF0ZUJlZm9yZSkgPT4ge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoYWN0aW9uKTtcbiAgICBpZiAocXVlcnlUaHVuay5wZW5kaW5nLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IG9sZFN0YXRlID0gc3RhdGVCZWZvcmVbcmVkdWNlclBhdGhdLnF1ZXJpZXNbY2FjaGVLZXldO1xuICAgICAgY29uc3Qgc3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXS5xdWVyaWVzW2NhY2hlS2V5XTtcbiAgICAgIGlmICghb2xkU3RhdGUgJiYgc3RhdGUpIHtcbiAgICAgICAgaGFuZGxlTmV3S2V5KGFjdGlvbi5tZXRhLmFyZy5lbmRwb2ludE5hbWUsIGFjdGlvbi5tZXRhLmFyZy5vcmlnaW5hbEFyZ3MsIGNhY2hlS2V5LCBtd0FwaSwgYWN0aW9uLm1ldGEucmVxdWVzdElkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG11dGF0aW9uVGh1bmsucGVuZGluZy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IG13QXBpLmdldFN0YXRlKClbcmVkdWNlclBhdGhdLm11dGF0aW9uc1tjYWNoZUtleV07XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgaGFuZGxlTmV3S2V5KGFjdGlvbi5tZXRhLmFyZy5lbmRwb2ludE5hbWUsIGFjdGlvbi5tZXRhLmFyZy5vcmlnaW5hbEFyZ3MsIGNhY2hlS2V5LCBtd0FwaSwgYWN0aW9uLm1ldGEucmVxdWVzdElkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRnVsZmlsbGVkVGh1bmsoYWN0aW9uKSkge1xuICAgICAgY29uc3QgbGlmZWN5Y2xlID0gbGlmZWN5Y2xlTWFwW2NhY2hlS2V5XTtcbiAgICAgIGlmIChsaWZlY3ljbGU/LnZhbHVlUmVzb2x2ZWQpIHtcbiAgICAgICAgbGlmZWN5Y2xlLnZhbHVlUmVzb2x2ZWQoe1xuICAgICAgICAgIGRhdGE6IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgICAgIG1ldGE6IGFjdGlvbi5tZXRhLmJhc2VRdWVyeU1ldGFcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBsaWZlY3ljbGUudmFsdWVSZXNvbHZlZDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSB8fCBhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZU11dGF0aW9uUmVzdWx0Lm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IGxpZmVjeWNsZSA9IGxpZmVjeWNsZU1hcFtjYWNoZUtleV07XG4gICAgICBpZiAobGlmZWN5Y2xlKSB7XG4gICAgICAgIGRlbGV0ZSBsaWZlY3ljbGVNYXBbY2FjaGVLZXldO1xuICAgICAgICBsaWZlY3ljbGUuY2FjaGVFbnRyeVJlbW92ZWQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgZm9yIChjb25zdCBbY2FjaGVLZXkyLCBsaWZlY3ljbGVdIG9mIE9iamVjdC5lbnRyaWVzKGxpZmVjeWNsZU1hcCkpIHtcbiAgICAgICAgZGVsZXRlIGxpZmVjeWNsZU1hcFtjYWNoZUtleTJdO1xuICAgICAgICBsaWZlY3ljbGUuY2FjaGVFbnRyeVJlbW92ZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGdldENhY2hlS2V5KGFjdGlvbikge1xuICAgIGlmIChpc1F1ZXJ5VGh1bmsoYWN0aW9uKSlcbiAgICAgIHJldHVybiBhY3Rpb24ubWV0YS5hcmcucXVlcnlDYWNoZUtleTtcbiAgICBpZiAoaXNNdXRhdGlvblRodW5rKGFjdGlvbikpXG4gICAgICByZXR1cm4gYWN0aW9uLm1ldGEucmVxdWVzdElkO1xuICAgIGlmIChhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikpXG4gICAgICByZXR1cm4gYWN0aW9uLnBheWxvYWQucXVlcnlDYWNoZUtleTtcbiAgICBpZiAoYXBpLmludGVybmFsQWN0aW9ucy5yZW1vdmVNdXRhdGlvblJlc3VsdC5tYXRjaChhY3Rpb24pKVxuICAgICAgcmV0dXJuIGdldE11dGF0aW9uQ2FjaGVLZXkoYWN0aW9uLnBheWxvYWQpO1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5ld0tleShlbmRwb2ludE5hbWUsIG9yaWdpbmFsQXJncywgcXVlcnlDYWNoZUtleSwgbXdBcGksIHJlcXVlc3RJZCkge1xuICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgIGNvbnN0IG9uQ2FjaGVFbnRyeUFkZGVkID0gZW5kcG9pbnREZWZpbml0aW9uPy5vbkNhY2hlRW50cnlBZGRlZDtcbiAgICBpZiAoIW9uQ2FjaGVFbnRyeUFkZGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBsaWZlY3ljbGUgPSB7fTtcbiAgICBjb25zdCBjYWNoZUVudHJ5UmVtb3ZlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBsaWZlY3ljbGUuY2FjaGVFbnRyeVJlbW92ZWQgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGNvbnN0IGNhY2hlRGF0YUxvYWRlZCA9IFByb21pc2UucmFjZShbbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxpZmVjeWNsZS52YWx1ZVJlc29sdmVkID0gcmVzb2x2ZTtcbiAgICB9KSwgY2FjaGVFbnRyeVJlbW92ZWQudGhlbigoKSA9PiB7XG4gICAgICB0aHJvdyBuZXZlclJlc29sdmVkRXJyb3I7XG4gICAgfSldKTtcbiAgICBjYWNoZURhdGFMb2FkZWQuY2F0Y2goKCkgPT4ge1xuICAgIH0pO1xuICAgIGxpZmVjeWNsZU1hcFtxdWVyeUNhY2hlS2V5XSA9IGxpZmVjeWNsZTtcbiAgICBjb25zdCBzZWxlY3RvciA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5zZWxlY3QoZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IFwicXVlcnlcIiAvKiBxdWVyeSAqLyA/IG9yaWdpbmFsQXJncyA6IHF1ZXJ5Q2FjaGVLZXkpO1xuICAgIGNvbnN0IGV4dHJhID0gbXdBcGkuZGlzcGF0Y2goKF8sIF9fLCBleHRyYTIpID0+IGV4dHJhMik7XG4gICAgY29uc3QgbGlmZWN5Y2xlQXBpID0ge1xuICAgICAgLi4ubXdBcGksXG4gICAgICBnZXRDYWNoZUVudHJ5OiAoKSA9PiBzZWxlY3Rvcihtd0FwaS5nZXRTdGF0ZSgpKSxcbiAgICAgIHJlcXVlc3RJZCxcbiAgICAgIGV4dHJhLFxuICAgICAgdXBkYXRlQ2FjaGVkRGF0YTogZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IFwicXVlcnlcIiAvKiBxdWVyeSAqLyA/ICh1cGRhdGVSZWNpcGUpID0+IG13QXBpLmRpc3BhdGNoKGFwaS51dGlsLnVwZGF0ZVF1ZXJ5RGF0YShlbmRwb2ludE5hbWUsIG9yaWdpbmFsQXJncywgdXBkYXRlUmVjaXBlKSkgOiB2b2lkIDAsXG4gICAgICBjYWNoZURhdGFMb2FkZWQsXG4gICAgICBjYWNoZUVudHJ5UmVtb3ZlZFxuICAgIH07XG4gICAgY29uc3QgcnVubmluZ0hhbmRsZXIgPSBvbkNhY2hlRW50cnlBZGRlZChvcmlnaW5hbEFyZ3MsIGxpZmVjeWNsZUFwaSk7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHJ1bm5pbmdIYW5kbGVyKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgaWYgKGUgPT09IG5ldmVyUmVzb2x2ZWRFcnJvcilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaGFuZGxlcjtcbn07XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9xdWVyeUxpZmVjeWNsZS50c1xudmFyIGJ1aWxkUXVlcnlMaWZlY3ljbGVIYW5kbGVyID0gKHtcbiAgYXBpLFxuICBjb250ZXh0LFxuICBxdWVyeVRodW5rLFxuICBtdXRhdGlvblRodW5rXG59KSA9PiB7XG4gIGNvbnN0IGlzUGVuZGluZ1RodW5rID0gaXNQZW5kaW5nKHF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmspO1xuICBjb25zdCBpc1JlamVjdGVkVGh1bmsgPSBpc1JlamVjdGVkKHF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmspO1xuICBjb25zdCBpc0Z1bGxmaWxsZWRUaHVuayA9IGlzRnVsZmlsbGVkKHF1ZXJ5VGh1bmssIG11dGF0aW9uVGh1bmspO1xuICBjb25zdCBsaWZlY3ljbGVNYXAgPSB7fTtcbiAgY29uc3QgaGFuZGxlciA9IChhY3Rpb24sIG13QXBpKSA9PiB7XG4gICAgaWYgKGlzUGVuZGluZ1RodW5rKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBhcmc6IHtcbiAgICAgICAgICBlbmRwb2ludE5hbWUsXG4gICAgICAgICAgb3JpZ2luYWxBcmdzXG4gICAgICAgIH1cbiAgICAgIH0gPSBhY3Rpb24ubWV0YTtcbiAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgICAgY29uc3Qgb25RdWVyeVN0YXJ0ZWQgPSBlbmRwb2ludERlZmluaXRpb24/Lm9uUXVlcnlTdGFydGVkO1xuICAgICAgaWYgKG9uUXVlcnlTdGFydGVkKSB7XG4gICAgICAgIGNvbnN0IGxpZmVjeWNsZSA9IHt9O1xuICAgICAgICBjb25zdCBxdWVyeUZ1bGZpbGxlZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBsaWZlY3ljbGUucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgbGlmZWN5Y2xlLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHF1ZXJ5RnVsZmlsbGVkLmNhdGNoKCgpID0+IHtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpZmVjeWNsZU1hcFtyZXF1ZXN0SWRdID0gbGlmZWN5Y2xlO1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5zZWxlY3QoZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IFwicXVlcnlcIiAvKiBxdWVyeSAqLyA/IG9yaWdpbmFsQXJncyA6IHJlcXVlc3RJZCk7XG4gICAgICAgIGNvbnN0IGV4dHJhID0gbXdBcGkuZGlzcGF0Y2goKF8sIF9fLCBleHRyYTIpID0+IGV4dHJhMik7XG4gICAgICAgIGNvbnN0IGxpZmVjeWNsZUFwaSA9IHtcbiAgICAgICAgICAuLi5td0FwaSxcbiAgICAgICAgICBnZXRDYWNoZUVudHJ5OiAoKSA9PiBzZWxlY3Rvcihtd0FwaS5nZXRTdGF0ZSgpKSxcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgdXBkYXRlQ2FjaGVkRGF0YTogZW5kcG9pbnREZWZpbml0aW9uLnR5cGUgPT09IFwicXVlcnlcIiAvKiBxdWVyeSAqLyA/ICh1cGRhdGVSZWNpcGUpID0+IG13QXBpLmRpc3BhdGNoKGFwaS51dGlsLnVwZGF0ZVF1ZXJ5RGF0YShlbmRwb2ludE5hbWUsIG9yaWdpbmFsQXJncywgdXBkYXRlUmVjaXBlKSkgOiB2b2lkIDAsXG4gICAgICAgICAgcXVlcnlGdWxmaWxsZWRcbiAgICAgICAgfTtcbiAgICAgICAgb25RdWVyeVN0YXJ0ZWQob3JpZ2luYWxBcmdzLCBsaWZlY3ljbGVBcGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNGdWxsZmlsbGVkVGh1bmsoYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIGJhc2VRdWVyeU1ldGFcbiAgICAgIH0gPSBhY3Rpb24ubWV0YTtcbiAgICAgIGxpZmVjeWNsZU1hcFtyZXF1ZXN0SWRdPy5yZXNvbHZlKHtcbiAgICAgICAgZGF0YTogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgIG1ldGE6IGJhc2VRdWVyeU1ldGFcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIGxpZmVjeWNsZU1hcFtyZXF1ZXN0SWRdO1xuICAgIH0gZWxzZSBpZiAoaXNSZWplY3RlZFRodW5rKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZWplY3RlZFdpdGhWYWx1ZSxcbiAgICAgICAgYmFzZVF1ZXJ5TWV0YVxuICAgICAgfSA9IGFjdGlvbi5tZXRhO1xuICAgICAgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF0/LnJlamVjdCh7XG4gICAgICAgIGVycm9yOiBhY3Rpb24ucGF5bG9hZCA/PyBhY3Rpb24uZXJyb3IsXG4gICAgICAgIGlzVW5oYW5kbGVkRXJyb3I6ICFyZWplY3RlZFdpdGhWYWx1ZSxcbiAgICAgICAgbWV0YTogYmFzZVF1ZXJ5TWV0YVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGFuZGxlcjtcbn07XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9kZXZNaWRkbGV3YXJlLnRzXG52YXIgYnVpbGREZXZDaGVja0hhbmRsZXIgPSAoe1xuICBhcGksXG4gIGNvbnRleHQ6IHtcbiAgICBhcGlVaWRcbiAgfSxcbiAgcmVkdWNlclBhdGhcbn0pID0+IHtcbiAgcmV0dXJuIChhY3Rpb24sIG13QXBpKSA9PiB7XG4gICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgbXdBcGkuZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5taWRkbGV3YXJlUmVnaXN0ZXJlZChhcGlVaWQpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgIGlmIChhcGkuaW50ZXJuYWxBY3Rpb25zLm1pZGRsZXdhcmVSZWdpc3RlcmVkLm1hdGNoKGFjdGlvbikgJiYgYWN0aW9uLnBheWxvYWQgPT09IGFwaVVpZCAmJiBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXT8uY29uZmlnPy5taWRkbGV3YXJlUmVnaXN0ZXJlZCA9PT0gXCJjb25mbGljdFwiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVGhlcmUgaXMgYSBtaXNtYXRjaCBiZXR3ZWVuIHNsaWNlIGFuZCBtaWRkbGV3YXJlIGZvciB0aGUgcmVkdWNlclBhdGggXCIke3JlZHVjZXJQYXRofVwiLlxuWW91IGNhbiBvbmx5IGhhdmUgb25lIGFwaSBwZXIgcmVkdWNlciBwYXRoLCB0aGlzIHdpbGwgbGVhZCB0byBjcmFzaGVzIGluIHZhcmlvdXMgc2l0dWF0aW9ucyEke3JlZHVjZXJQYXRoID09PSBcImFwaVwiID8gYFxuSWYgeW91IGhhdmUgbXVsdGlwbGUgYXBpcywgeW91ICpoYXZlKiB0byBzcGVjaWZ5IHRoZSByZWR1Y2VyUGF0aCBvcHRpb24gd2hlbiB1c2luZyBjcmVhdGVBcGkhYCA6IFwiXCJ9YCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2JhdGNoQWN0aW9ucy50c1xuaW1wb3J0IHsgcHJvZHVjZVdpdGhQYXRjaGVzIGFzIHByb2R1Y2VXaXRoUGF0Y2hlczIgfSBmcm9tIFwiaW1tZXJcIjtcbnZhciBidWlsZEJhdGNoZWRBY3Rpb25zSGFuZGxlciA9ICh7XG4gIGFwaSxcbiAgcXVlcnlUaHVuayxcbiAgaW50ZXJuYWxTdGF0ZVxufSkgPT4ge1xuICBjb25zdCBzdWJzY3JpcHRpb25zUHJlZml4ID0gYCR7YXBpLnJlZHVjZXJQYXRofS9zdWJzY3JpcHRpb25zYDtcbiAgbGV0IHByZXZpb3VzU3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gIGxldCB1cGRhdGVTeW5jVGltZXIgPSBudWxsO1xuICBjb25zdCB7XG4gICAgdXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyxcbiAgICB1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0XG4gIH0gPSBhcGkuaW50ZXJuYWxBY3Rpb25zO1xuICBjb25zdCBhY3R1YWxseU11dGF0ZVN1YnNjcmlwdGlvbnMgPSAobXV0YWJsZVN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICBpZiAodXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgaWYgKG11dGFibGVTdGF0ZT8uW3F1ZXJ5Q2FjaGVLZXldPy5bcmVxdWVzdElkXSkge1xuICAgICAgICBtdXRhYmxlU3RhdGVbcXVlcnlDYWNoZUtleV1bcmVxdWVzdElkXSA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHVuc3Vic2NyaWJlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgICByZXF1ZXN0SWRcbiAgICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgIGlmIChtdXRhYmxlU3RhdGVbcXVlcnlDYWNoZUtleV0pIHtcbiAgICAgICAgZGVsZXRlIG11dGFibGVTdGF0ZVtxdWVyeUNhY2hlS2V5XVtyZXF1ZXN0SWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGRlbGV0ZSBtdXRhYmxlU3RhdGVbYWN0aW9uLnBheWxvYWQucXVlcnlDYWNoZUtleV07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5VGh1bmsucGVuZGluZy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgIH1cbiAgICAgIH0gPSBhY3Rpb247XG4gICAgICBjb25zdCBzdWJzdGF0ZSA9IG11dGFibGVTdGF0ZVthcmcucXVlcnlDYWNoZUtleV0gPz89IHt9O1xuICAgICAgc3Vic3RhdGVbYCR7cmVxdWVzdElkfV9ydW5uaW5nYF0gPSB7fTtcbiAgICAgIGlmIChhcmcuc3Vic2NyaWJlKSB7XG4gICAgICAgIHN1YnN0YXRlW3JlcXVlc3RJZF0gPSBhcmcuc3Vic2NyaXB0aW9uT3B0aW9ucyA/PyBzdWJzdGF0ZVtyZXF1ZXN0SWRdID8/IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBtdXRhdGVkID0gZmFsc2U7XG4gICAgaWYgKHF1ZXJ5VGh1bmsuZnVsZmlsbGVkLm1hdGNoKGFjdGlvbikgfHwgcXVlcnlUaHVuay5yZWplY3RlZC5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IG11dGFibGVTdGF0ZVthY3Rpb24ubWV0YS5hcmcucXVlcnlDYWNoZUtleV0gfHwge307XG4gICAgICBjb25zdCBrZXkgPSBgJHthY3Rpb24ubWV0YS5yZXF1ZXN0SWR9X3J1bm5pbmdgO1xuICAgICAgbXV0YXRlZCB8fD0gISFzdGF0ZVtrZXldO1xuICAgICAgZGVsZXRlIHN0YXRlW2tleV07XG4gICAgfVxuICAgIGlmIChxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgIH1cbiAgICAgIH0gPSBhY3Rpb247XG4gICAgICBpZiAoY29uZGl0aW9uICYmIGFyZy5zdWJzY3JpYmUpIHtcbiAgICAgICAgY29uc3Qgc3Vic3RhdGUgPSBtdXRhYmxlU3RhdGVbYXJnLnF1ZXJ5Q2FjaGVLZXldID8/PSB7fTtcbiAgICAgICAgc3Vic3RhdGVbcmVxdWVzdElkXSA9IGFyZy5zdWJzY3JpcHRpb25PcHRpb25zID8/IHN1YnN0YXRlW3JlcXVlc3RJZF0gPz8ge307XG4gICAgICAgIG11dGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbXV0YXRlZDtcbiAgfTtcbiAgY29uc3QgZ2V0U3Vic2NyaXB0aW9ucyA9ICgpID0+IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnM7XG4gIGNvbnN0IGdldFN1YnNjcmlwdGlvbkNvdW50ID0gKHF1ZXJ5Q2FjaGVLZXkpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gZ2V0U3Vic2NyaXB0aW9ucygpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnNGb3JRdWVyeUFyZyA9IHN1YnNjcmlwdGlvbnNbcXVlcnlDYWNoZUtleV0gPz8ge307XG4gICAgcmV0dXJuIGNvdW50T2JqZWN0S2V5cyhzdWJzY3JpcHRpb25zRm9yUXVlcnlBcmcpO1xuICB9O1xuICBjb25zdCBpc1JlcXVlc3RTdWJzY3JpYmVkID0gKHF1ZXJ5Q2FjaGVLZXksIHJlcXVlc3RJZCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBnZXRTdWJzY3JpcHRpb25zKCk7XG4gICAgcmV0dXJuICEhc3Vic2NyaXB0aW9ucz8uW3F1ZXJ5Q2FjaGVLZXldPy5bcmVxdWVzdElkXTtcbiAgfTtcbiAgY29uc3Qgc3Vic2NyaXB0aW9uU2VsZWN0b3JzID0ge1xuICAgIGdldFN1YnNjcmlwdGlvbnMsXG4gICAgZ2V0U3Vic2NyaXB0aW9uQ291bnQsXG4gICAgaXNSZXF1ZXN0U3Vic2NyaWJlZFxuICB9O1xuICByZXR1cm4gKGFjdGlvbiwgbXdBcGkpID0+IHtcbiAgICBpZiAoIXByZXZpb3VzU3Vic2NyaXB0aW9ucykge1xuICAgICAgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChhcGkudXRpbC5yZXNldEFwaVN0YXRlLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHByZXZpb3VzU3Vic2NyaXB0aW9ucyA9IGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICAgIHVwZGF0ZVN5bmNUaW1lciA9IG51bGw7XG4gICAgICByZXR1cm4gW3RydWUsIGZhbHNlXTtcbiAgICB9XG4gICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMuaW50ZXJuYWxfZ2V0UlRLUVN1YnNjcmlwdGlvbnMubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIFtmYWxzZSwgc3Vic2NyaXB0aW9uU2VsZWN0b3JzXTtcbiAgICB9XG4gICAgY29uc3QgZGlkTXV0YXRlID0gYWN0dWFsbHlNdXRhdGVTdWJzY3JpcHRpb25zKGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnMsIGFjdGlvbik7XG4gICAgbGV0IGFjdGlvblNob3VsZENvbnRpbnVlID0gdHJ1ZTtcbiAgICBpZiAoZGlkTXV0YXRlKSB7XG4gICAgICBpZiAoIXVwZGF0ZVN5bmNUaW1lcikge1xuICAgICAgICB1cGRhdGVTeW5jVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdTdWJzY3JpcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zKSk7XG4gICAgICAgICAgY29uc3QgWywgcGF0Y2hlc10gPSBwcm9kdWNlV2l0aFBhdGNoZXMyKHByZXZpb3VzU3Vic2NyaXB0aW9ucywgKCkgPT4gbmV3U3Vic2NyaXB0aW9ucyk7XG4gICAgICAgICAgbXdBcGkubmV4dChhcGkuaW50ZXJuYWxBY3Rpb25zLnN1YnNjcmlwdGlvbnNVcGRhdGVkKHBhdGNoZXMpKTtcbiAgICAgICAgICBwcmV2aW91c1N1YnNjcmlwdGlvbnMgPSBuZXdTdWJzY3JpcHRpb25zO1xuICAgICAgICAgIHVwZGF0ZVN5bmNUaW1lciA9IG51bGw7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1N1YnNjcmlwdGlvblNsaWNlQWN0aW9uID0gdHlwZW9mIGFjdGlvbi50eXBlID09IFwic3RyaW5nXCIgJiYgISFhY3Rpb24udHlwZS5zdGFydHNXaXRoKHN1YnNjcmlwdGlvbnNQcmVmaXgpO1xuICAgICAgY29uc3QgaXNBZGRpdGlvbmFsU3Vic2NyaXB0aW9uQWN0aW9uID0gcXVlcnlUaHVuay5yZWplY3RlZC5tYXRjaChhY3Rpb24pICYmIGFjdGlvbi5tZXRhLmNvbmRpdGlvbiAmJiAhIWFjdGlvbi5tZXRhLmFyZy5zdWJzY3JpYmU7XG4gICAgICBhY3Rpb25TaG91bGRDb250aW51ZSA9ICFpc1N1YnNjcmlwdGlvblNsaWNlQWN0aW9uICYmICFpc0FkZGl0aW9uYWxTdWJzY3JpcHRpb25BY3Rpb247XG4gICAgfVxuICAgIHJldHVybiBbYWN0aW9uU2hvdWxkQ29udGludWUsIGZhbHNlXTtcbiAgfTtcbn07XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9pbmRleC50c1xuZnVuY3Rpb24gYnVpbGRNaWRkbGV3YXJlKGlucHV0KSB7XG4gIGNvbnN0IHtcbiAgICByZWR1Y2VyUGF0aCxcbiAgICBxdWVyeVRodW5rLFxuICAgIGFwaSxcbiAgICBjb250ZXh0XG4gIH0gPSBpbnB1dDtcbiAgY29uc3Qge1xuICAgIGFwaVVpZFxuICB9ID0gY29udGV4dDtcbiAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICBpbnZhbGlkYXRlVGFnczogY3JlYXRlQWN0aW9uKGAke3JlZHVjZXJQYXRofS9pbnZhbGlkYXRlVGFnc2ApXG4gIH07XG4gIGNvbnN0IGlzVGhpc0FwaVNsaWNlQWN0aW9uID0gKGFjdGlvbikgPT4gYWN0aW9uLnR5cGUuc3RhcnRzV2l0aChgJHtyZWR1Y2VyUGF0aH0vYCk7XG4gIGNvbnN0IGhhbmRsZXJCdWlsZGVycyA9IFtidWlsZERldkNoZWNrSGFuZGxlciwgYnVpbGRDYWNoZUNvbGxlY3Rpb25IYW5kbGVyLCBidWlsZEludmFsaWRhdGlvbkJ5VGFnc0hhbmRsZXIsIGJ1aWxkUG9sbGluZ0hhbmRsZXIsIGJ1aWxkQ2FjaGVMaWZlY3ljbGVIYW5kbGVyLCBidWlsZFF1ZXJ5TGlmZWN5Y2xlSGFuZGxlcl07XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAobXdBcGkpID0+IHtcbiAgICBsZXQgaW5pdGlhbGl6ZWQyID0gZmFsc2U7XG4gICAgbGV0IGludGVybmFsU3RhdGUgPSB7XG4gICAgICBjdXJyZW50U3Vic2NyaXB0aW9uczoge31cbiAgICB9O1xuICAgIGNvbnN0IGJ1aWxkZXJBcmdzID0ge1xuICAgICAgLi4uaW5wdXQsXG4gICAgICBpbnRlcm5hbFN0YXRlLFxuICAgICAgcmVmZXRjaFF1ZXJ5LFxuICAgICAgaXNUaGlzQXBpU2xpY2VBY3Rpb25cbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXJzID0gaGFuZGxlckJ1aWxkZXJzLm1hcCgoYnVpbGQpID0+IGJ1aWxkKGJ1aWxkZXJBcmdzKSk7XG4gICAgY29uc3QgYmF0Y2hlZEFjdGlvbnNIYW5kbGVyID0gYnVpbGRCYXRjaGVkQWN0aW9uc0hhbmRsZXIoYnVpbGRlckFyZ3MpO1xuICAgIGNvbnN0IHdpbmRvd0V2ZW50c0hhbmRsZXIgPSBidWlsZFdpbmRvd0V2ZW50SGFuZGxlcihidWlsZGVyQXJncyk7XG4gICAgcmV0dXJuIChuZXh0KSA9PiB7XG4gICAgICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgICAgICBpZiAoIWlzQWN0aW9uKGFjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5pdGlhbGl6ZWQyKSB7XG4gICAgICAgICAgaW5pdGlhbGl6ZWQyID0gdHJ1ZTtcbiAgICAgICAgICBtd0FwaS5kaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLm1pZGRsZXdhcmVSZWdpc3RlcmVkKGFwaVVpZCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG13QXBpV2l0aE5leHQgPSB7XG4gICAgICAgICAgLi4ubXdBcGksXG4gICAgICAgICAgbmV4dFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdGF0ZUJlZm9yZSA9IG13QXBpLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IFthY3Rpb25TaG91bGRDb250aW51ZSwgaW50ZXJuYWxQcm9iZVJlc3VsdF0gPSBiYXRjaGVkQWN0aW9uc0hhbmRsZXIoYWN0aW9uLCBtd0FwaVdpdGhOZXh0LCBzdGF0ZUJlZm9yZSk7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGlmIChhY3Rpb25TaG91bGRDb250aW51ZSkge1xuICAgICAgICAgIHJlcyA9IG5leHQoYWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSBpbnRlcm5hbFByb2JlUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghIW13QXBpLmdldFN0YXRlKClbcmVkdWNlclBhdGhdKSB7XG4gICAgICAgICAgd2luZG93RXZlbnRzSGFuZGxlcihhY3Rpb24sIG13QXBpV2l0aE5leHQsIHN0YXRlQmVmb3JlKTtcbiAgICAgICAgICBpZiAoaXNUaGlzQXBpU2xpY2VBY3Rpb24oYWN0aW9uKSB8fCBjb250ZXh0Lmhhc1JlaHlkcmF0aW9uSW5mbyhhY3Rpb24pKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgIGhhbmRsZXIoYWN0aW9uLCBtd0FwaVdpdGhOZXh0LCBzdGF0ZUJlZm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZSxcbiAgICBhY3Rpb25zXG4gIH07XG4gIGZ1bmN0aW9uIHJlZmV0Y2hRdWVyeShxdWVyeVN1YlN0YXRlLCBxdWVyeUNhY2hlS2V5LCBvdmVycmlkZSA9IHt9KSB7XG4gICAgcmV0dXJuIHF1ZXJ5VGh1bmsoe1xuICAgICAgdHlwZTogXCJxdWVyeVwiLFxuICAgICAgZW5kcG9pbnROYW1lOiBxdWVyeVN1YlN0YXRlLmVuZHBvaW50TmFtZSxcbiAgICAgIG9yaWdpbmFsQXJnczogcXVlcnlTdWJTdGF0ZS5vcmlnaW5hbEFyZ3MsXG4gICAgICBzdWJzY3JpYmU6IGZhbHNlLFxuICAgICAgZm9yY2VSZWZldGNoOiB0cnVlLFxuICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgIC4uLm92ZXJyaWRlXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL3F1ZXJ5L3RzSGVscGVycy50c1xuZnVuY3Rpb24gYXNzZXJ0Q2FzdCh2KSB7XG59XG5mdW5jdGlvbiBzYWZlQXNzaWduKHRhcmdldCwgLi4uYXJncykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0YXJnZXQsIC4uLmFyZ3MpO1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9tb2R1bGUudHNcbmltcG9ydCB7IGVuYWJsZVBhdGNoZXMgfSBmcm9tIFwiaW1tZXJcIjtcbnZhciBjb3JlTW9kdWxlTmFtZSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woKTtcbnZhciBjb3JlTW9kdWxlID0gKCkgPT4gKHtcbiAgbmFtZTogY29yZU1vZHVsZU5hbWUsXG4gIGluaXQoYXBpLCB7XG4gICAgYmFzZVF1ZXJ5LFxuICAgIHRhZ1R5cGVzLFxuICAgIHJlZHVjZXJQYXRoLFxuICAgIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgICBrZWVwVW51c2VkRGF0YUZvcixcbiAgICByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlLFxuICAgIHJlZmV0Y2hPbkZvY3VzLFxuICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICBpbnZhbGlkYXRpb25CZWhhdmlvclxuICB9LCBjb250ZXh0KSB7XG4gICAgZW5hYmxlUGF0Y2hlcygpO1xuICAgIGFzc2VydENhc3Qoc2VyaWFsaXplUXVlcnlBcmdzKTtcbiAgICBjb25zdCBhc3NlcnRUYWdUeXBlID0gKHRhZykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgaWYgKCF0YWdUeXBlcy5pbmNsdWRlcyh0YWcudHlwZSkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBUYWcgdHlwZSAnJHt0YWcudHlwZX0nIHdhcyB1c2VkLCBidXQgbm90IHNwZWNpZmllZCBpbiBcXGB0YWdUeXBlc1xcYCFgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhZztcbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24oYXBpLCB7XG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIGVuZHBvaW50czoge30sXG4gICAgICBpbnRlcm5hbEFjdGlvbnM6IHtcbiAgICAgICAgb25PbmxpbmUsXG4gICAgICAgIG9uT2ZmbGluZSxcbiAgICAgICAgb25Gb2N1cyxcbiAgICAgICAgb25Gb2N1c0xvc3RcbiAgICAgIH0sXG4gICAgICB1dGlsOiB7fVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHF1ZXJ5VGh1bmssXG4gICAgICBtdXRhdGlvblRodW5rLFxuICAgICAgcGF0Y2hRdWVyeURhdGEsXG4gICAgICB1cGRhdGVRdWVyeURhdGEsXG4gICAgICB1cHNlcnRRdWVyeURhdGEsXG4gICAgICBwcmVmZXRjaCxcbiAgICAgIGJ1aWxkTWF0Y2hUaHVua0FjdGlvbnNcbiAgICB9ID0gYnVpbGRUaHVua3Moe1xuICAgICAgYmFzZVF1ZXJ5LFxuICAgICAgcmVkdWNlclBhdGgsXG4gICAgICBjb250ZXh0LFxuICAgICAgYXBpLFxuICAgICAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICAgICAgYXNzZXJ0VGFnVHlwZVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZHVjZXIsXG4gICAgICBhY3Rpb25zOiBzbGljZUFjdGlvbnNcbiAgICB9ID0gYnVpbGRTbGljZSh7XG4gICAgICBjb250ZXh0LFxuICAgICAgcXVlcnlUaHVuayxcbiAgICAgIG11dGF0aW9uVGh1bmssXG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIGFzc2VydFRhZ1R5cGUsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgcmVmZXRjaE9uRm9jdXMsXG4gICAgICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICAgICAgcmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZSxcbiAgICAgICAga2VlcFVudXNlZERhdGFGb3IsXG4gICAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgICBpbnZhbGlkYXRpb25CZWhhdmlvclxuICAgICAgfVxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIHtcbiAgICAgIHBhdGNoUXVlcnlEYXRhLFxuICAgICAgdXBkYXRlUXVlcnlEYXRhLFxuICAgICAgdXBzZXJ0UXVlcnlEYXRhLFxuICAgICAgcHJlZmV0Y2gsXG4gICAgICByZXNldEFwaVN0YXRlOiBzbGljZUFjdGlvbnMucmVzZXRBcGlTdGF0ZVxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLmludGVybmFsQWN0aW9ucywgc2xpY2VBY3Rpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICBtaWRkbGV3YXJlLFxuICAgICAgYWN0aW9uczogbWlkZGxld2FyZUFjdGlvbnNcbiAgICB9ID0gYnVpbGRNaWRkbGV3YXJlKHtcbiAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgY29udGV4dCxcbiAgICAgIHF1ZXJ5VGh1bmssXG4gICAgICBtdXRhdGlvblRodW5rLFxuICAgICAgYXBpLFxuICAgICAgYXNzZXJ0VGFnVHlwZVxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIG1pZGRsZXdhcmVBY3Rpb25zKTtcbiAgICBzYWZlQXNzaWduKGFwaSwge1xuICAgICAgcmVkdWNlcixcbiAgICAgIG1pZGRsZXdhcmVcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBidWlsZFF1ZXJ5U2VsZWN0b3IsXG4gICAgICBidWlsZE11dGF0aW9uU2VsZWN0b3IsXG4gICAgICBzZWxlY3RJbnZhbGlkYXRlZEJ5LFxuICAgICAgc2VsZWN0Q2FjaGVkQXJnc0ZvclF1ZXJ5XG4gICAgfSA9IGJ1aWxkU2VsZWN0b3JzKHtcbiAgICAgIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgICAgIHJlZHVjZXJQYXRoXG4gICAgfSk7XG4gICAgc2FmZUFzc2lnbihhcGkudXRpbCwge1xuICAgICAgc2VsZWN0SW52YWxpZGF0ZWRCeSxcbiAgICAgIHNlbGVjdENhY2hlZEFyZ3NGb3JRdWVyeVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGJ1aWxkSW5pdGlhdGVRdWVyeSxcbiAgICAgIGJ1aWxkSW5pdGlhdGVNdXRhdGlvbixcbiAgICAgIGdldFJ1bm5pbmdNdXRhdGlvblRodW5rLFxuICAgICAgZ2V0UnVubmluZ011dGF0aW9uc1RodW5rLFxuICAgICAgZ2V0UnVubmluZ1F1ZXJpZXNUaHVuayxcbiAgICAgIGdldFJ1bm5pbmdRdWVyeVRodW5rXG4gICAgfSA9IGJ1aWxkSW5pdGlhdGUoe1xuICAgICAgcXVlcnlUaHVuayxcbiAgICAgIG11dGF0aW9uVGh1bmssXG4gICAgICBhcGksXG4gICAgICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gICAgICBjb250ZXh0XG4gICAgfSk7XG4gICAgc2FmZUFzc2lnbihhcGkudXRpbCwge1xuICAgICAgZ2V0UnVubmluZ011dGF0aW9uVGh1bmssXG4gICAgICBnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmssXG4gICAgICBnZXRSdW5uaW5nUXVlcnlUaHVuayxcbiAgICAgIGdldFJ1bm5pbmdRdWVyaWVzVGh1bmtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogY29yZU1vZHVsZU5hbWUsXG4gICAgICBpbmplY3RFbmRwb2ludChlbmRwb2ludE5hbWUsIGRlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3QgYW55QXBpID0gYXBpO1xuICAgICAgICBhbnlBcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0gPz89IHt9O1xuICAgICAgICBpZiAoaXNRdWVyeURlZmluaXRpb24oZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBzYWZlQXNzaWduKGFueUFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSwge1xuICAgICAgICAgICAgbmFtZTogZW5kcG9pbnROYW1lLFxuICAgICAgICAgICAgc2VsZWN0OiBidWlsZFF1ZXJ5U2VsZWN0b3IoZW5kcG9pbnROYW1lLCBkZWZpbml0aW9uKSxcbiAgICAgICAgICAgIGluaXRpYXRlOiBidWlsZEluaXRpYXRlUXVlcnkoZW5kcG9pbnROYW1lLCBkZWZpbml0aW9uKVxuICAgICAgICAgIH0sIGJ1aWxkTWF0Y2hUaHVua0FjdGlvbnMocXVlcnlUaHVuaywgZW5kcG9pbnROYW1lKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNdXRhdGlvbkRlZmluaXRpb24oZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBzYWZlQXNzaWduKGFueUFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSwge1xuICAgICAgICAgICAgbmFtZTogZW5kcG9pbnROYW1lLFxuICAgICAgICAgICAgc2VsZWN0OiBidWlsZE11dGF0aW9uU2VsZWN0b3IoKSxcbiAgICAgICAgICAgIGluaXRpYXRlOiBidWlsZEluaXRpYXRlTXV0YXRpb24oZW5kcG9pbnROYW1lKVxuICAgICAgICAgIH0sIGJ1aWxkTWF0Y2hUaHVua0FjdGlvbnMobXV0YXRpb25UaHVuaywgZW5kcG9pbnROYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvaW5kZXgudHNcbnZhciBjcmVhdGVBcGkgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRDcmVhdGVBcGkoY29yZU1vZHVsZSgpKTtcbmV4cG9ydCB7XG4gIFF1ZXJ5U3RhdHVzLFxuICBidWlsZENyZWF0ZUFwaSxcbiAgY29weVdpdGhTdHJ1Y3R1cmFsU2hhcmluZyxcbiAgY29yZU1vZHVsZSxcbiAgY29yZU1vZHVsZU5hbWUsXG4gIGNyZWF0ZUFwaSxcbiAgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgZmFrZUJhc2VRdWVyeSxcbiAgZmV0Y2hCYXNlUXVlcnksXG4gIHJldHJ5LFxuICBzZXR1cExpc3RlbmVycyxcbiAgc2tpcFRva2VuXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnRrLXF1ZXJ5Lm1vZGVybi5tanMubWFwIl0sIm5hbWVzIjpbIlF1ZXJ5U3RhdHVzIiwiUXVlcnlTdGF0dXMyIiwiZ2V0UmVxdWVzdFN0YXR1c0ZsYWdzIiwic3RhdHVzIiwiaXNVbmluaXRpYWxpemVkIiwiaXNMb2FkaW5nIiwiaXNTdWNjZXNzIiwiaXNFcnJvciIsImlzQWJzb2x1dGVVcmwiLCJ1cmwiLCJSZWdFeHAiLCJ0ZXN0Iiwid2l0aG91dFRyYWlsaW5nU2xhc2giLCJyZXBsYWNlIiwid2l0aG91dExlYWRpbmdTbGFzaCIsImpvaW5VcmxzIiwiYmFzZSIsImRlbGltaXRlciIsImVuZHNXaXRoIiwic3RhcnRzV2l0aCIsImZsYXR0ZW4iLCJhcnIiLCJjb25jYXQiLCJpc09ubGluZSIsIm5hdmlnYXRvciIsIm9uTGluZSIsImlzRG9jdW1lbnRWaXNpYmxlIiwiZG9jdW1lbnQiLCJ2aXNpYmlsaXR5U3RhdGUiLCJjcmVhdGVBY3Rpb24iLCJjcmVhdGVTbGljZSIsImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlQXN5bmNUaHVuayIsImNvbWJpbmVSZWR1Y2VycyIsImNyZWF0ZU5leHRTdGF0ZSIsImlzQW55T2YiLCJpc0FsbE9mIiwiaXNBY3Rpb24iLCJpc1BlbmRpbmciLCJpc1JlamVjdGVkIiwiaXNGdWxmaWxsZWQiLCJpc1JlamVjdGVkV2l0aFZhbHVlIiwiaXNBc3luY1RodW5rQWN0aW9uIiwicHJlcGFyZUF1dG9CYXRjaGVkIiwiU0hPVUxEX0FVVE9CQVRDSCIsImlzUGxhaW5PYmplY3QiLCJuYW5vaWQiLCJpc1BsYWluT2JqZWN0MiIsImNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmciLCJvbGRPYmoiLCJuZXdPYmoiLCJBcnJheSIsImlzQXJyYXkiLCJuZXdLZXlzIiwiT2JqZWN0Iiwia2V5cyIsIm9sZEtleXMiLCJpc1NhbWVPYmplY3QiLCJsZW5ndGgiLCJtZXJnZU9iaiIsImtleSIsImRlZmF1bHRGZXRjaEZuIiwiYXJncyIsImZldGNoIiwiZGVmYXVsdFZhbGlkYXRlU3RhdHVzIiwicmVzcG9uc2UiLCJkZWZhdWx0SXNKc29uQ29udGVudFR5cGUiLCJoZWFkZXJzIiwiZ2V0Iiwic3RyaXBVbmRlZmluZWQiLCJvYmoiLCJjb3B5IiwiayIsInYiLCJlbnRyaWVzIiwiZmV0Y2hCYXNlUXVlcnkiLCJiYXNlVXJsIiwicHJlcGFyZUhlYWRlcnMiLCJ4IiwiZmV0Y2hGbiIsInBhcmFtc1NlcmlhbGl6ZXIiLCJpc0pzb25Db250ZW50VHlwZSIsImpzb25Db250ZW50VHlwZSIsImpzb25SZXBsYWNlciIsInRpbWVvdXQiLCJkZWZhdWx0VGltZW91dCIsInJlc3BvbnNlSGFuZGxlciIsImdsb2JhbFJlc3BvbnNlSGFuZGxlciIsInZhbGlkYXRlU3RhdHVzIiwiZ2xvYmFsVmFsaWRhdGVTdGF0dXMiLCJiYXNlRmV0Y2hPcHRpb25zIiwiY29uc29sZSIsIndhcm4iLCJhcmciLCJhcGkiLCJzaWduYWwiLCJnZXRTdGF0ZSIsImV4dHJhIiwiZW5kcG9pbnQiLCJmb3JjZWQiLCJ0eXBlIiwibWV0YSIsIkhlYWRlcnMiLCJwYXJhbXMiLCJyZXN0IiwiY29uZmlnIiwiaXNKc29uaWZpYWJsZSIsImJvZHkiLCJ0b0pTT04iLCJoYXMiLCJzZXQiLCJKU09OIiwic3RyaW5naWZ5IiwiZGl2aWRlciIsImluZGV4T2YiLCJxdWVyeSIsIlVSTFNlYXJjaFBhcmFtcyIsInJlcXVlc3QiLCJSZXF1ZXN0IiwicmVxdWVzdENsb25lIiwidGltZWRPdXQiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJlIiwiZXJyb3IiLCJTdHJpbmciLCJjbGVhclRpbWVvdXQiLCJyZXNwb25zZUNsb25lIiwiY2xvbmUiLCJyZXN1bHREYXRhIiwicmVzcG9uc2VUZXh0IiwiaGFuZGxlUmVzcG9uc2VFcnJvciIsIlByb21pc2UiLCJhbGwiLCJoYW5kbGVSZXNwb25zZSIsInRoZW4iLCJyIiwidGV4dCIsIm9yaWdpbmFsU3RhdHVzIiwiZGF0YSIsInBhcnNlIiwiSGFuZGxlZEVycm9yIiwiY29uc3RydWN0b3IiLCJ2YWx1ZSIsImRlZmF1bHRCYWNrb2ZmIiwiYXR0ZW1wdCIsIm1heFJldHJpZXMiLCJhdHRlbXB0cyIsIk1hdGgiLCJtaW4iLCJyYW5kb20iLCJyZXNvbHZlIiwicmVzIiwiZmFpbCIsImFzc2lnbiIsInRocm93SW1tZWRpYXRlbHkiLCJFTVBUWV9PUFRJT05TIiwicmV0cnlXaXRoQmFja29mZiIsImJhc2VRdWVyeSIsImRlZmF1bHRPcHRpb25zIiwiZXh0cmFPcHRpb25zIiwicG9zc2libGVNYXhSZXRyaWVzIiwiZmlsdGVyIiwic2xpY2UiLCJkZWZhdWx0UmV0cnlDb25kaXRpb24iLCJfIiwiX18iLCJvcHRpb25zIiwiYmFja29mZiIsInJldHJ5Q29uZGl0aW9uIiwicmV0cnkyIiwicmVzdWx0IiwiYmFzZVF1ZXJ5QXBpIiwicmV0cnkiLCJvbkZvY3VzIiwib25Gb2N1c0xvc3QiLCJvbk9ubGluZSIsIm9uT2ZmbGluZSIsImluaXRpYWxpemVkIiwic2V0dXBMaXN0ZW5lcnMiLCJkaXNwYXRjaCIsImN1c3RvbUhhbmRsZXIiLCJkZWZhdWx0SGFuZGxlciIsImhhbmRsZUZvY3VzIiwiaGFuZGxlRm9jdXNMb3N0IiwiaGFuZGxlT25saW5lIiwiaGFuZGxlT2ZmbGluZSIsImhhbmRsZVZpc2liaWxpdHlDaGFuZ2UiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwidW5zdWJzY3JpYmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaXNRdWVyeURlZmluaXRpb24iLCJpc011dGF0aW9uRGVmaW5pdGlvbiIsImNhbGN1bGF0ZVByb3ZpZGVkQnkiLCJkZXNjcmlwdGlvbiIsInF1ZXJ5QXJnIiwiYXNzZXJ0VGFnVHlwZXMiLCJpc0Z1bmN0aW9uIiwibWFwIiwiZXhwYW5kVGFnRGVzY3JpcHRpb24iLCJ0IiwiZm9ybWF0UHJvZEVycm9yTWVzc2FnZSIsIl9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlIiwiaXNOb3ROdWxsaXNoIiwiY291bnRPYmplY3RLZXlzIiwiY291bnQiLCJfa2V5IiwiZm9yY2VRdWVyeUZuU3ltYm9sIiwiU3ltYm9sIiwiaXNVcHNlcnRRdWVyeSIsImJ1aWxkSW5pdGlhdGUiLCJzZXJpYWxpemVRdWVyeUFyZ3MiLCJxdWVyeVRodW5rIiwibXV0YXRpb25UaHVuayIsImNvbnRleHQiLCJydW5uaW5nUXVlcmllcyIsIk1hcCIsInJ1bm5pbmdNdXRhdGlvbnMiLCJ1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0IiwicmVtb3ZlTXV0YXRpb25SZXN1bHQiLCJ1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zIiwiaW50ZXJuYWxBY3Rpb25zIiwiYnVpbGRJbml0aWF0ZVF1ZXJ5IiwiYnVpbGRJbml0aWF0ZU11dGF0aW9uIiwiZ2V0UnVubmluZ1F1ZXJ5VGh1bmsiLCJnZXRSdW5uaW5nTXV0YXRpb25UaHVuayIsImdldFJ1bm5pbmdRdWVyaWVzVGh1bmsiLCJnZXRSdW5uaW5nTXV0YXRpb25zVGh1bmsiLCJlbmRwb2ludE5hbWUiLCJxdWVyeUFyZ3MiLCJlbmRwb2ludERlZmluaXRpb24iLCJlbmRwb2ludERlZmluaXRpb25zIiwicXVlcnlDYWNoZUtleSIsIl9lbmRwb2ludE5hbWUiLCJmaXhlZENhY2hlS2V5T3JSZXF1ZXN0SWQiLCJ2YWx1ZXMiLCJtaWRkbGV3YXJlV2FybmluZyIsInByb2Nlc3MiLCJ0cmlnZ2VyZWQiLCJyZXR1cm5lZFZhbHVlIiwiaW50ZXJuYWxfZ2V0UlRLUVN1YnNjcmlwdGlvbnMiLCJFcnJvciIsInJlZHVjZXJQYXRoIiwicXVlcnlBY3Rpb24iLCJzdWJzY3JpYmUiLCJmb3JjZVJlZmV0Y2giLCJzdWJzY3JpcHRpb25PcHRpb25zIiwiZm9yY2VRdWVyeUZuIiwidGh1bmsiLCJvcmlnaW5hbEFyZ3MiLCJzZWxlY3RvciIsImVuZHBvaW50cyIsInNlbGVjdCIsInRodW5rUmVzdWx0Iiwic3RhdGVBZnRlciIsInJlcXVlc3RJZCIsInNraXBwZWRTeW5jaHJvbm91c2x5IiwicnVubmluZ1F1ZXJ5Iiwic2VsZWN0RnJvbVN0YXRlIiwic3RhdGVQcm9taXNlIiwidW53cmFwIiwicmVmZXRjaCIsInJ1bm5pbmciLCJkZWxldGUiLCJ0cmFjayIsImZpeGVkQ2FjaGVLZXkiLCJyZXR1cm5WYWx1ZVByb21pc2UiLCJjYXRjaCIsInJlc2V0IiwicmV0IiwiaXNEcmFmdGFibGUiLCJwcm9kdWNlV2l0aFBhdGNoZXMiLCJkZWZhdWx0VHJhbnNmb3JtUmVzcG9uc2UiLCJiYXNlUXVlcnlSZXR1cm5WYWx1ZSIsImJ1aWxkVGh1bmtzIiwiYXNzZXJ0VGFnVHlwZSIsInBhdGNoUXVlcnlEYXRhIiwicGF0Y2hlcyIsInVwZGF0ZVByb3ZpZGVkIiwicXVlcnlSZXN1bHRQYXRjaGVkIiwibmV3VmFsdWUiLCJwcm92aWRlZFRhZ3MiLCJwcm92aWRlc1RhZ3MiLCJ1cGRhdGVQcm92aWRlZEJ5IiwidXBkYXRlUXVlcnlEYXRhIiwidXBkYXRlUmVjaXBlIiwiY3VycmVudFN0YXRlIiwiaW52ZXJzZVBhdGNoZXMiLCJ1bmRvIiwidXRpbCIsInB1c2giLCJvcCIsInBhdGgiLCJ1cHNlcnRRdWVyeURhdGEiLCJpbml0aWF0ZSIsImV4ZWN1dGVFbmRwb2ludCIsInJlamVjdFdpdGhWYWx1ZSIsImZ1bGZpbGxXaXRoVmFsdWUiLCJ0cmFuc2Zvcm1SZXNwb25zZSIsImlzRm9yY2VkUXVlcnkiLCJxdWVyeUZuIiwiYXJnMiIsIndoYXQiLCJlcnIiLCJmdWxmaWxsZWRUaW1lU3RhbXAiLCJEYXRlIiwibm93IiwiYmFzZVF1ZXJ5TWV0YSIsImNhdGNoZWRFcnJvciIsInRyYW5zZm9ybUVycm9yUmVzcG9uc2UiLCJzdGF0ZSIsInJlcXVlc3RTdGF0ZSIsInF1ZXJpZXMiLCJiYXNlRmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UiLCJyZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlIiwiZnVsZmlsbGVkVmFsIiwicmVmZXRjaFZhbCIsIk51bWJlciIsImdldFBlbmRpbmdNZXRhIiwic3RhcnRlZFRpbWVTdGFtcCIsImNvbmRpdGlvbiIsInF1ZXJ5VGh1bmtBcmdzIiwiY3VycmVudEFyZyIsInByZXZpb3VzQXJnIiwiZW5kcG9pbnRTdGF0ZSIsImRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uIiwiaGFzVGhlRm9yY2UiLCJoYXNNYXhBZ2UiLCJwcmVmZXRjaCIsImZvcmNlIiwibWF4QWdlIiwiaWZPbGRlclRoYW4iLCJmb3JjZTIiLCJsYXRlc3RTdGF0ZVZhbHVlIiwibGFzdEZ1bGZpbGxlZFRzIiwic2hvdWxkUmV0cmlnZ2VyIiwibWF0Y2hlc0VuZHBvaW50IiwiYWN0aW9uIiwiYnVpbGRNYXRjaFRodW5rQWN0aW9ucyIsIm1hdGNoUGVuZGluZyIsIm1hdGNoRnVsZmlsbGVkIiwibWF0Y2hSZWplY3RlZCIsImNhbGN1bGF0ZVByb3ZpZGVkQnlUaHVuayIsInBheWxvYWQiLCJpc0RyYWZ0IiwiYXBwbHlQYXRjaGVzIiwib3JpZ2luYWwiLCJ1cGRhdGVRdWVyeVN1YnN0YXRlSWZFeGlzdHMiLCJ1cGRhdGUiLCJzdWJzdGF0ZSIsImdldE11dGF0aW9uQ2FjaGVLZXkiLCJpZCIsInVwZGF0ZU11dGF0aW9uU3Vic3RhdGVJZkV4aXN0cyIsImluaXRpYWxTdGF0ZSIsImJ1aWxkU2xpY2UiLCJkZWZpbml0aW9ucyIsImFwaVVpZCIsImV4dHJhY3RSZWh5ZHJhdGlvbkluZm8iLCJoYXNSZWh5ZHJhdGlvbkluZm8iLCJyZXNldEFwaVN0YXRlIiwicXVlcnlTbGljZSIsIm5hbWUiLCJyZWR1Y2VycyIsInJlbW92ZVF1ZXJ5UmVzdWx0IiwicmVkdWNlciIsImRyYWZ0IiwicHJlcGFyZSIsImV4dHJhUmVkdWNlcnMiLCJidWlsZGVyIiwiYWRkQ2FzZSIsInBlbmRpbmciLCJ1cHNlcnRpbmciLCJmdWxmaWxsZWQiLCJtZXJnZSIsIm5ld0RhdGEiLCJkcmFmdFN1YnN0YXRlRGF0YSIsInN0cnVjdHVyYWxTaGFyaW5nIiwicmVqZWN0ZWQiLCJhZGRNYXRjaGVyIiwiZW50cnkiLCJtdXRhdGlvblNsaWNlIiwiY2FjaGVLZXkiLCJtdXRhdGlvbnMiLCJpbnZhbGlkYXRpb25TbGljZSIsInRhZ1R5cGVTdWJzY3JpcHRpb25zIiwiaWRTdWJzY3JpcHRpb25zIiwiZm91bmRBdCIsInNwbGljZSIsInN1YnNjcmliZWRRdWVyaWVzIiwiYWxyZWFkeVN1YnNjcmliZWQiLCJpbmNsdWRlcyIsImFjdGlvbnMiLCJwcm92aWRlZCIsImluY29taW5nVGFncyIsImNhY2hlS2V5cyIsImNhc2VSZWR1Y2VycyIsInN1YnNjcmlwdGlvblNsaWNlIiwiZCIsImEiLCJpbnRlcm5hbFN1YnNjcmlwdGlvbnNTbGljZSIsInN1YnNjcmlwdGlvbnNVcGRhdGVkIiwiY29uZmlnU2xpY2UiLCJvbmxpbmUiLCJmb2N1c2VkIiwibWlkZGxld2FyZVJlZ2lzdGVyZWQiLCJjb21iaW5lZFJlZHVjZXIiLCJzdWJzY3JpcHRpb25zIiwibWF0Y2giLCJza2lwVG9rZW4iLCJmb3IiLCJpbml0aWFsU3ViU3RhdGUiLCJkZWZhdWx0UXVlcnlTdWJTdGF0ZSIsImRlZmF1bHRNdXRhdGlvblN1YlN0YXRlIiwiYnVpbGRTZWxlY3RvcnMiLCJzZWxlY3RTa2lwcGVkUXVlcnkiLCJzZWxlY3RTa2lwcGVkTXV0YXRpb24iLCJidWlsZFF1ZXJ5U2VsZWN0b3IiLCJidWlsZE11dGF0aW9uU2VsZWN0b3IiLCJzZWxlY3RJbnZhbGlkYXRlZEJ5Iiwic2VsZWN0Q2FjaGVkQXJnc0ZvclF1ZXJ5Iiwid2l0aFJlcXVlc3RGbGFncyIsInNlbGVjdEludGVybmFsU3RhdGUiLCJyb290U3RhdGUiLCJzZXJpYWxpemVkQXJncyIsInNlbGVjdFF1ZXJ5U3Vic3RhdGUiLCJmaW5hbFNlbGVjdFF1ZXJ5U3ViU3RhdGUiLCJtdXRhdGlvbklkIiwic2VsZWN0TXV0YXRpb25TdWJzdGF0ZSIsImZpbmFsU2VsZWN0TXV0YXRpb25TdWJzdGF0ZSIsInRhZ3MiLCJhcGlTdGF0ZSIsInRvSW52YWxpZGF0ZSIsIlNldCIsInRhZyIsImludmFsaWRhdGVTdWJzY3JpcHRpb25zIiwiaW52YWxpZGF0ZSIsImFkZCIsImZyb20iLCJxdWVyeVN1YlN0YXRlIiwicXVlcnlOYW1lIiwiY2FjaGUiLCJXZWFrTWFwIiwiZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyIsInNlcmlhbGl6ZWQiLCJjYWNoZWQiLCJzdHJpbmdpZmllZCIsInNvcnQiLCJyZWR1Y2UiLCJhY2MiLCJrZXkyIiwid2Vha01hcE1lbW9pemUiLCJidWlsZENyZWF0ZUFwaSIsIm1vZHVsZXMiLCJiYXNlQ3JlYXRlQXBpIiwib3B0aW9uc1dpdGhEZWZhdWx0cyIsImtlZXBVbnVzZWREYXRhRm9yIiwicmVmZXRjaE9uRm9jdXMiLCJyZWZldGNoT25SZWNvbm5lY3QiLCJpbnZhbGlkYXRpb25CZWhhdmlvciIsInF1ZXJ5QXJnc0FwaSIsImZpbmFsU2VyaWFsaXplUXVlcnlBcmdzIiwiZW5kcG9pbnRTUUEiLCJxdWVyeUFyZ3NBcGkyIiwiaW5pdGlhbFJlc3VsdCIsInRhZ1R5cGVzIiwiYmF0Y2giLCJmbiIsImluamVjdEVuZHBvaW50cyIsImVuaGFuY2VFbmRwb2ludHMiLCJhZGRUYWdUeXBlcyIsImVUIiwicGFydGlhbERlZmluaXRpb24iLCJpbml0aWFsaXplZE1vZHVsZXMiLCJtIiwiaW5pdCIsImluamVjdCIsImV2YWx1YXRlZEVuZHBvaW50cyIsIm11dGF0aW9uIiwiZGVmaW5pdGlvbiIsIm92ZXJyaWRlRXhpc3RpbmciLCJpbmplY3RFbmRwb2ludCIsIl9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiIsImZha2VCYXNlUXVlcnkiLCJpc09iamVjdEVtcHR5IiwiVEhJUlRZX1RXT19CSVRfTUFYX1RJTUVSX1NFQ09ORFMiLCJidWlsZENhY2hlQ29sbGVjdGlvbkhhbmRsZXIiLCJpbnRlcm5hbFN0YXRlIiwiYW55U3Vic2NyaXB0aW9uc1JlbWFpbmluZ0ZvcktleSIsImN1cnJlbnRTdWJzY3JpcHRpb25zIiwiY3VycmVudFJlbW92YWxUaW1lb3V0cyIsImhhbmRsZXIiLCJtd0FwaSIsImludGVybmFsU3RhdGUyIiwiaGFuZGxlVW5zdWJzY3JpYmUiLCJxdWVyeVN0YXRlIiwiYXBpMiIsIkluZmluaXR5IiwiZmluYWxLZWVwVW51c2VkRGF0YUZvciIsIm1heCIsImN1cnJlbnRUaW1lb3V0IiwiYnVpbGRJbnZhbGlkYXRpb25CeVRhZ3NIYW5kbGVyIiwicmVmZXRjaFF1ZXJ5IiwiaXNUaHVua0FjdGlvbldpdGhUYWdzIiwiaXNRdWVyeUVuZCIsInBlbmRpbmdUYWdJbnZhbGlkYXRpb25zIiwiaW52YWxpZGF0ZVRhZ3MiLCJoYXNQZW5kaW5nUmVxdWVzdHMiLCJuZXdUYWdzIiwidmFsdWVzQXJyYXkiLCJzdWJzY3JpcHRpb25TdWJTdGF0ZSIsImJ1aWxkUG9sbGluZ0hhbmRsZXIiLCJjdXJyZW50UG9sbHMiLCJ1cGRhdGVQb2xsaW5nSW50ZXJ2YWwiLCJzdGFydE5leHRQb2xsIiwiY2xlYXJQb2xscyIsImxvd2VzdFBvbGxpbmdJbnRlcnZhbCIsImZpbmRMb3dlc3RQb2xsaW5nSW50ZXJ2YWwiLCJpc0Zpbml0ZSIsImN1cnJlbnRQb2xsIiwibmV4dFBvbGxUaW1lc3RhbXAiLCJjdXJyZW50SW50ZXJ2YWwiLCJwb2xsaW5nSW50ZXJ2YWwiLCJjbGVhbnVwUG9sbEZvcktleSIsImV4aXN0aW5nUG9sbCIsInN1YnNjcmliZXJzIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJidWlsZFdpbmRvd0V2ZW50SGFuZGxlciIsInJlZmV0Y2hWYWxpZFF1ZXJpZXMiLCJzaG91bGRSZWZldGNoIiwic29tZSIsInN1YiIsImV2ZXJ5IiwibmV2ZXJSZXNvbHZlZEVycm9yIiwiYnVpbGRDYWNoZUxpZmVjeWNsZUhhbmRsZXIiLCJpc1F1ZXJ5VGh1bmsiLCJpc011dGF0aW9uVGh1bmsiLCJpc0Z1bGZpbGxlZFRodW5rIiwibGlmZWN5Y2xlTWFwIiwic3RhdGVCZWZvcmUiLCJnZXRDYWNoZUtleSIsIm9sZFN0YXRlIiwiaGFuZGxlTmV3S2V5IiwibGlmZWN5Y2xlIiwidmFsdWVSZXNvbHZlZCIsImNhY2hlRW50cnlSZW1vdmVkIiwiY2FjaGVLZXkyIiwib25DYWNoZUVudHJ5QWRkZWQiLCJjYWNoZURhdGFMb2FkZWQiLCJyYWNlIiwiZXh0cmEyIiwibGlmZWN5Y2xlQXBpIiwiZ2V0Q2FjaGVFbnRyeSIsInVwZGF0ZUNhY2hlZERhdGEiLCJydW5uaW5nSGFuZGxlciIsImJ1aWxkUXVlcnlMaWZlY3ljbGVIYW5kbGVyIiwiaXNQZW5kaW5nVGh1bmsiLCJpc1JlamVjdGVkVGh1bmsiLCJpc0Z1bGxmaWxsZWRUaHVuayIsIm9uUXVlcnlTdGFydGVkIiwicXVlcnlGdWxmaWxsZWQiLCJyZWplY3QiLCJyZWplY3RlZFdpdGhWYWx1ZSIsImlzVW5oYW5kbGVkRXJyb3IiLCJidWlsZERldkNoZWNrSGFuZGxlciIsInByb2R1Y2VXaXRoUGF0Y2hlczIiLCJidWlsZEJhdGNoZWRBY3Rpb25zSGFuZGxlciIsInN1YnNjcmlwdGlvbnNQcmVmaXgiLCJwcmV2aW91c1N1YnNjcmlwdGlvbnMiLCJ1cGRhdGVTeW5jVGltZXIiLCJhY3R1YWxseU11dGF0ZVN1YnNjcmlwdGlvbnMiLCJtdXRhYmxlU3RhdGUiLCJtdXRhdGVkIiwiZ2V0U3Vic2NyaXB0aW9ucyIsImdldFN1YnNjcmlwdGlvbkNvdW50Iiwic3Vic2NyaXB0aW9uc0ZvclF1ZXJ5QXJnIiwiaXNSZXF1ZXN0U3Vic2NyaWJlZCIsInN1YnNjcmlwdGlvblNlbGVjdG9ycyIsImRpZE11dGF0ZSIsImFjdGlvblNob3VsZENvbnRpbnVlIiwibmV3U3Vic2NyaXB0aW9ucyIsIm5leHQiLCJpc1N1YnNjcmlwdGlvblNsaWNlQWN0aW9uIiwiaXNBZGRpdGlvbmFsU3Vic2NyaXB0aW9uQWN0aW9uIiwiYnVpbGRNaWRkbGV3YXJlIiwiaW5wdXQiLCJpc1RoaXNBcGlTbGljZUFjdGlvbiIsImhhbmRsZXJCdWlsZGVycyIsIm1pZGRsZXdhcmUiLCJpbml0aWFsaXplZDIiLCJidWlsZGVyQXJncyIsImhhbmRsZXJzIiwiYnVpbGQiLCJiYXRjaGVkQWN0aW9uc0hhbmRsZXIiLCJ3aW5kb3dFdmVudHNIYW5kbGVyIiwibXdBcGlXaXRoTmV4dCIsImludGVybmFsUHJvYmVSZXN1bHQiLCJvdmVycmlkZSIsImFzc2VydENhc3QiLCJzYWZlQXNzaWduIiwidGFyZ2V0IiwiZW5hYmxlUGF0Y2hlcyIsImNvcmVNb2R1bGVOYW1lIiwiY29yZU1vZHVsZSIsInNsaWNlQWN0aW9ucyIsIm1pZGRsZXdhcmVBY3Rpb25zIiwiYW55QXBpIiwiY3JlYXRlQXBpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReducerType: () => (/* binding */ ReducerType),\n/* harmony export */   SHOULD_AUTOBATCH: () => (/* binding */ SHOULD_AUTOBATCH),\n/* harmony export */   TaskAbortError: () => (/* binding */ TaskAbortError),\n/* harmony export */   Tuple: () => (/* binding */ Tuple),\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),\n/* harmony export */   addListener: () => (/* binding */ addListener),\n/* harmony export */   applyMiddleware: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),\n/* harmony export */   asyncThunkCreator: () => (/* binding */ asyncThunkCreator),\n/* harmony export */   autoBatchEnhancer: () => (/* binding */ autoBatchEnhancer),\n/* harmony export */   bindActionCreators: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),\n/* harmony export */   buildCreateSlice: () => (/* binding */ buildCreateSlice),\n/* harmony export */   clearAllListeners: () => (/* binding */ clearAllListeners),\n/* harmony export */   combineReducers: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),\n/* harmony export */   combineSlices: () => (/* binding */ combineSlices),\n/* harmony export */   compose: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),\n/* harmony export */   configureStore: () => (/* binding */ configureStore),\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   createActionCreatorInvariantMiddleware: () => (/* binding */ createActionCreatorInvariantMiddleware),\n/* harmony export */   createAsyncThunk: () => (/* binding */ createAsyncThunk),\n/* harmony export */   createDraftSafeSelector: () => (/* binding */ createDraftSafeSelector),\n/* harmony export */   createDraftSafeSelectorCreator: () => (/* binding */ createDraftSafeSelectorCreator),\n/* harmony export */   createDynamicMiddleware: () => (/* binding */ createDynamicMiddleware),\n/* harmony export */   createEntityAdapter: () => (/* binding */ createEntityAdapter),\n/* harmony export */   createImmutableStateInvariantMiddleware: () => (/* binding */ createImmutableStateInvariantMiddleware),\n/* harmony export */   createListenerMiddleware: () => (/* binding */ createListenerMiddleware),\n/* harmony export */   createNextState: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.produce),\n/* harmony export */   createReducer: () => (/* binding */ createReducer),\n/* harmony export */   createSelector: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),\n/* harmony export */   createSelectorCreator: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator),\n/* harmony export */   createSerializableStateInvariantMiddleware: () => (/* binding */ createSerializableStateInvariantMiddleware),\n/* harmony export */   createSlice: () => (/* binding */ createSlice),\n/* harmony export */   createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   current: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),\n/* harmony export */   findNonSerializableValue: () => (/* binding */ findNonSerializableValue),\n/* harmony export */   formatProdErrorMessage: () => (/* binding */ formatProdErrorMessage),\n/* harmony export */   freeze: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),\n/* harmony export */   isAction: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isAction),\n/* harmony export */   isActionCreator: () => (/* binding */ isActionCreator),\n/* harmony export */   isAllOf: () => (/* binding */ isAllOf),\n/* harmony export */   isAnyOf: () => (/* binding */ isAnyOf),\n/* harmony export */   isAsyncThunkAction: () => (/* binding */ isAsyncThunkAction),\n/* harmony export */   isDraft: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),\n/* harmony export */   isFluxStandardAction: () => (/* binding */ isFSA),\n/* harmony export */   isFulfilled: () => (/* binding */ isFulfilled),\n/* harmony export */   isImmutableDefault: () => (/* binding */ isImmutableDefault),\n/* harmony export */   isPending: () => (/* binding */ isPending),\n/* harmony export */   isPlain: () => (/* binding */ isPlain),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject),\n/* harmony export */   isRejected: () => (/* binding */ isRejected),\n/* harmony export */   isRejectedWithValue: () => (/* binding */ isRejectedWithValue),\n/* harmony export */   legacy_createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),\n/* harmony export */   lruMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.lruMemoize),\n/* harmony export */   miniSerializeError: () => (/* binding */ miniSerializeError),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   original: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),\n/* harmony export */   prepareAutoBatched: () => (/* binding */ prepareAutoBatched),\n/* harmony export */   removeListener: () => (/* binding */ removeListener),\n/* harmony export */   unwrapResult: () => (/* binding */ unwrapResult),\n/* harmony export */   weakMapMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize)\n/* harmony export */ });\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/redux-thunk/dist/redux-thunk.mjs\");\n// src/index.ts\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelectorCreator = (...args)=>{\n    const createSelector2 = (0,reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator)(...args);\n    return (...args2)=>{\n        const selector = createSelector2(...args2);\n        const wrappedSelector = (value, ...rest)=>selector((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value, ...rest);\n        Object.assign(wrappedSelector, selector);\n        return wrappedSelector;\n    };\n};\nvar createDraftSafeSelector = createDraftSafeSelectorCreator(reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize);\n// src/configureStore.ts\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools =  false ? 0 : function() {\n    if (arguments.length === 0) return void 0;\n    if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer =  false ? 0 : function() {\n    return function(noop3) {\n        return noop3;\n    };\n};\n// src/getDefaultMiddleware.ts\n\n// src/createAction.ts\n\n// src/tsHelpers.ts\nvar hasMatchFunction = (v)=>{\n    return v && typeof v.match === \"function\";\n};\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n    function actionCreator(...args) {\n        if (prepareAction) {\n            let prepared = prepareAction(...args);\n            if (!prepared) {\n                throw new Error( false ? 0 : \"prepareAction did not return an object\");\n            }\n            return {\n                type,\n                payload: prepared.payload,\n                ...\"meta\" in prepared && {\n                    meta: prepared.meta\n                },\n                ...\"error\" in prepared && {\n                    error: prepared.error\n                }\n            };\n        }\n        return {\n            type,\n            payload: args[0]\n        };\n    }\n    actionCreator.toString = ()=>`${type}`;\n    actionCreator.type = type;\n    actionCreator.match = (action)=>(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && action.type === type;\n    return actionCreator;\n}\nfunction isActionCreator(action) {\n    return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\n    hasMatchFunction(action);\n}\nfunction isFSA(action) {\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n    return [\n        \"type\",\n        \"payload\",\n        \"error\",\n        \"meta\"\n    ].indexOf(key) > -1;\n}\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n    const splitType = type ? `${type}`.split(\"/\") : [];\n    const actionName = splitType[splitType.length - 1] || \"actionCreator\";\n    return `Detected an action creator with type \"${type || \"unknown\"}\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. \\`dispatch(${actionName}())\\` instead of \\`dispatch(${actionName})\\`. This is necessary even if the action has no payload.`;\n}\nfunction createActionCreatorInvariantMiddleware(options = {}) {\n    if (false) {}\n    const { isActionCreator: isActionCreator2 = isActionCreator } = options;\n    return ()=>(next)=>(action)=>{\n                if (isActionCreator2(action)) {\n                    console.warn(getMessage(action.type));\n                }\n                return next(action);\n            };\n}\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n    let elapsed = 0;\n    return {\n        measureTime (fn) {\n            const started = Date.now();\n            try {\n                return fn();\n            } finally{\n                const finished = Date.now();\n                elapsed += finished - started;\n            }\n        },\n        warnIfExceeded () {\n            if (elapsed > maxDelay) {\n                console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.`);\n            }\n        }\n    };\n}\nfunction find(iterable, comparator) {\n    for (const entry of iterable){\n        if (comparator(entry)) {\n            return entry;\n        }\n    }\n    return void 0;\n}\nvar Tuple = class _Tuple extends Array {\n    constructor(...items){\n        super(...items);\n        Object.setPrototypeOf(this, _Tuple.prototype);\n    }\n    static get [Symbol.species]() {\n        return _Tuple;\n    }\n    concat(...arr) {\n        return super.concat.apply(this, arr);\n    }\n    prepend(...arr) {\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new _Tuple(...arr[0].concat(this));\n        }\n        return new _Tuple(...arr.concat(this));\n    }\n};\nfunction freezeDraftable(val) {\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(val, ()=>{}) : val;\n}\nfunction emplace(map, key, handler) {\n    if (map.has(key)) {\n        let value = map.get(key);\n        if (handler.update) {\n            value = handler.update(value, key, map);\n            map.set(key, value);\n        }\n        return value;\n    }\n    if (!handler.insert) throw new Error( false ? 0 : \"No insert provided for key not already in map\");\n    const inserted = handler.insert(key, map);\n    map.set(key, inserted);\n    return inserted;\n}\n// src/immutableStateInvariantMiddleware.ts\nfunction isImmutableDefault(value) {\n    return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n    const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n    return {\n        detectMutations () {\n            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n        }\n    };\n}\nfunction trackProperties(isImmutable, ignorePaths = [], obj, path = \"\", checkedObjects = /* @__PURE__ */ new Set()) {\n    const tracked = {\n        value: obj\n    };\n    if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n        checkedObjects.add(obj);\n        tracked.children = {};\n        for(const key in obj){\n            const childPath = path ? path + \".\" + key : key;\n            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n                continue;\n            }\n            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n        }\n    }\n    return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = \"\") {\n    const prevObj = trackedProperty ? trackedProperty.value : void 0;\n    const sameRef = prevObj === obj;\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n        return {\n            wasMutated: true,\n            path\n        };\n    }\n    if (isImmutable(prevObj) || isImmutable(obj)) {\n        return {\n            wasMutated: false\n        };\n    }\n    const keysToDetect = {};\n    for(let key in trackedProperty.children){\n        keysToDetect[key] = true;\n    }\n    for(let key in obj){\n        keysToDetect[key] = true;\n    }\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for(let key in keysToDetect){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n        if (result.wasMutated) {\n            return result;\n        }\n    }\n    return {\n        wasMutated: false\n    };\n}\nfunction createImmutableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        let stringify2 = function(obj, serializer, indent, decycler) {\n            return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\n        }, getSerialize2 = function(serializer, decycler) {\n            let stack = [], keys = [];\n            if (!decycler) decycler = function(_, value) {\n                if (stack[0] === value) return \"[Circular ~]\";\n                return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n            };\n            return function(key, value) {\n                if (stack.length > 0) {\n                    var thisPos = stack.indexOf(this);\n                    ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n                    ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n                    if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n                } else stack.push(value);\n                return serializer == null ? value : serializer.call(this, key, value);\n            };\n        };\n        var stringify = stringify2, getSerialize = getSerialize2;\n        let { isImmutable = isImmutableDefault, ignoredPaths, warnAfter = 32 } = options;\n        const track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n        return ({ getState })=>{\n            let state = getState();\n            let tracker = track(state);\n            let result;\n            return (next)=>(action)=>{\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected between dispatches, in the path '${result.path || \"\"}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    const dispatchedAction = next(action);\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected inside a dispatch, in the path: ${result.path || \"\"}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    measureUtils.warnIfExceeded();\n                    return dispatchedAction;\n                };\n        };\n    }\n}\n// src/serializableStateInvariantMiddleware.ts\n\nfunction isPlain(val) {\n    const type = typeof val;\n    return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || (0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val);\n}\nfunction findNonSerializableValue(value, path = \"\", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {\n    let foundNestedSerializable;\n    if (!isSerializable(value)) {\n        return {\n            keyPath: path || \"<root>\",\n            value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    if (cache?.has(value)) return false;\n    const entries = getEntries != null ? getEntries(value) : Object.entries(value);\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for (const [key, nestedValue] of entries){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        if (!isSerializable(nestedValue)) {\n            return {\n                keyPath: nestedPath,\n                value: nestedValue\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n            if (foundNestedSerializable) {\n                return foundNestedSerializable;\n            }\n        }\n    }\n    if (cache && isNestedFrozen(value)) cache.add(value);\n    return false;\n}\nfunction isNestedFrozen(value) {\n    if (!Object.isFrozen(value)) return false;\n    for (const nestedValue of Object.values(value)){\n        if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n        if (!isNestedFrozen(nestedValue)) return false;\n    }\n    return true;\n}\nfunction createSerializableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        const { isSerializable = isPlain, getEntries, ignoredActions = [], ignoredActionPaths = [\n            \"meta.arg\",\n            \"meta.baseQueryMeta\"\n        ], ignoredPaths = [], warnAfter = 32, ignoreState = false, ignoreActions = false, disableCache = false } = options;\n        const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;\n        return (storeAPI)=>(next)=>(action)=>{\n                    if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                        return next(action);\n                    }\n                    const result = next(action);\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n                    if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n                        measureUtils.measureTime(()=>{\n                            const foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n                            if (foundActionNonSerializableValue) {\n                                const { keyPath, value } = foundActionNonSerializableValue;\n                                console.error(`A non-serializable value was detected in an action, in the path: \\`${keyPath}\\`. Value:`, value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n                            }\n                        });\n                    }\n                    if (!ignoreState) {\n                        measureUtils.measureTime(()=>{\n                            const state = storeAPI.getState();\n                            const foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n                            if (foundStateNonSerializableValue) {\n                                const { keyPath, value } = foundStateNonSerializableValue;\n                                console.error(`A non-serializable value was detected in the state, in the path: \\`${keyPath}\\`. Value:`, value, `\nTake a look at the reducer(s) handling this action type: ${action.type}.\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);\n                            }\n                        });\n                        measureUtils.warnIfExceeded();\n                    }\n                    return result;\n                };\n    }\n}\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nvar buildGetDefaultMiddleware = ()=>function getDefaultMiddleware(options) {\n        const { thunk = true, immutableCheck = true, serializableCheck = true, actionCreatorCheck = true } = options ?? {};\n        let middlewareArray = new Tuple();\n        if (thunk) {\n            if (isBoolean(thunk)) {\n                middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__.thunk);\n            } else {\n                middlewareArray.push((0,redux_thunk__WEBPACK_IMPORTED_MODULE_3__.withExtraArgument)(thunk.extraArgument));\n            }\n        }\n        if (true) {\n            if (immutableCheck) {\n                let immutableOptions = {};\n                if (!isBoolean(immutableCheck)) {\n                    immutableOptions = immutableCheck;\n                }\n                middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n            }\n            if (serializableCheck) {\n                let serializableOptions = {};\n                if (!isBoolean(serializableCheck)) {\n                    serializableOptions = serializableCheck;\n                }\n                middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n            }\n            if (actionCreatorCheck) {\n                let actionCreatorOptions = {};\n                if (!isBoolean(actionCreatorCheck)) {\n                    actionCreatorOptions = actionCreatorCheck;\n                }\n                middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n            }\n        }\n        return middlewareArray;\n    };\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = ()=>(payload)=>({\n            payload,\n            meta: {\n                [SHOULD_AUTOBATCH]: true\n            }\n        });\nvar createQueueWithTimer = (timeout)=>{\n    return (notify)=>{\n        setTimeout(notify, timeout);\n    };\n};\nvar rAF =  false ? 0 : createQueueWithTimer(10);\nvar autoBatchEnhancer = (options = {\n    type: \"raf\"\n})=>(next)=>(...args)=>{\n            const store = next(...args);\n            let notifying = true;\n            let shouldNotifyAtEndOfTick = false;\n            let notificationQueued = false;\n            const listeners = /* @__PURE__ */ new Set();\n            const queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? rAF : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n            const notifyListeners = ()=>{\n                notificationQueued = false;\n                if (shouldNotifyAtEndOfTick) {\n                    shouldNotifyAtEndOfTick = false;\n                    listeners.forEach((l)=>l());\n                }\n            };\n            return Object.assign({}, store, {\n                // Override the base `store.subscribe` method to keep original listeners\n                // from running if we're delaying notifications\n                subscribe (listener2) {\n                    const wrappedListener = ()=>notifying && listener2();\n                    const unsubscribe = store.subscribe(wrappedListener);\n                    listeners.add(listener2);\n                    return ()=>{\n                        unsubscribe();\n                        listeners.delete(listener2);\n                    };\n                },\n                // Override the base `store.dispatch` method so that we can check actions\n                // for the `shouldAutoBatch` flag and determine if batching is active\n                dispatch (action) {\n                    try {\n                        notifying = !action?.meta?.[SHOULD_AUTOBATCH];\n                        shouldNotifyAtEndOfTick = !notifying;\n                        if (shouldNotifyAtEndOfTick) {\n                            if (!notificationQueued) {\n                                notificationQueued = true;\n                                queueCallback(notifyListeners);\n                            }\n                        }\n                        return store.dispatch(action);\n                    } finally{\n                        notifying = true;\n                    }\n                }\n            });\n        };\n// src/getDefaultEnhancers.ts\nvar buildGetDefaultEnhancers = (middlewareEnhancer)=>function getDefaultEnhancers(options) {\n        const { autoBatch = true } = options ?? {};\n        let enhancerArray = new Tuple(middlewareEnhancer);\n        if (autoBatch) {\n            enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\n        }\n        return enhancerArray;\n    };\n// src/configureStore.ts\nvar IS_PRODUCTION = \"development\" === \"production\";\nfunction configureStore(options) {\n    const getDefaultMiddleware = buildGetDefaultMiddleware();\n    const { reducer = void 0, middleware, devTools = true, preloadedState = void 0, enhancers = void 0 } = options || {};\n    let rootReducer;\n    if (typeof reducer === \"function\") {\n        rootReducer = reducer;\n    } else if ((0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(reducer)) {\n        rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n    } else {\n        throw new Error( false ? 0 : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\n    }\n    if (!IS_PRODUCTION && middleware && typeof middleware !== \"function\") {\n        throw new Error( false ? 0 : \"`middleware` field must be a callback\");\n    }\n    let finalMiddleware;\n    if (typeof middleware === \"function\") {\n        finalMiddleware = middleware(getDefaultMiddleware);\n        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n            throw new Error( false ? 0 : \"when using a middleware builder function, an array of middleware must be returned\");\n        }\n    } else {\n        finalMiddleware = getDefaultMiddleware();\n    }\n    if (!IS_PRODUCTION && finalMiddleware.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each middleware provided to configureStore must be a function\");\n    }\n    let finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    if (devTools) {\n        finalCompose = composeWithDevTools({\n            // Enable capture of stack traces for dispatched Redux actions\n            trace: !IS_PRODUCTION,\n            ...typeof devTools === \"object\" && devTools\n        });\n    }\n    const middlewareEnhancer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware)(...finalMiddleware);\n    const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\n    if (!IS_PRODUCTION && enhancers && typeof enhancers !== \"function\") {\n        throw new Error( false ? 0 : \"`enhancers` field must be a callback\");\n    }\n    let storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\n    if (!IS_PRODUCTION && !Array.isArray(storeEnhancers)) {\n        throw new Error( false ? 0 : \"`enhancers` callback must return an array\");\n    }\n    if (!IS_PRODUCTION && storeEnhancers.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each enhancer provided to configureStore must be a function\");\n    }\n    if (!IS_PRODUCTION && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\n        console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\n    }\n    const composedEnhancer = finalCompose(...storeEnhancers);\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n// src/createReducer.ts\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n    const actionsMap = {};\n    const actionMatchers = [];\n    let defaultCaseReducer;\n    const builder = {\n        addCase (typeOrActionCreator, reducer) {\n            if (true) {\n                if (actionMatchers.length > 0) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n                }\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n            if (!type) {\n                throw new Error( false ? 0 : \"`builder.addCase` cannot be called with an empty action type\");\n            }\n            if (type in actionsMap) {\n                throw new Error( false ? 0 : `\\`builder.addCase\\` cannot be called with two reducers for the same action type '${type}'`);\n            }\n            actionsMap[type] = reducer;\n            return builder;\n        },\n        addMatcher (matcher, reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            actionMatchers.push({\n                matcher,\n                reducer\n            });\n            return builder;\n        },\n        addDefaultCase (reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addDefaultCase` can only be called once\");\n                }\n            }\n            defaultCaseReducer = reducer;\n            return builder;\n        }\n    };\n    builderCallback(builder);\n    return [\n        actionsMap,\n        actionMatchers,\n        defaultCaseReducer\n    ];\n}\n// src/createReducer.ts\nfunction isStateFunction(x) {\n    return typeof x === \"function\";\n}\nfunction createReducer(initialState, mapOrBuilderCallback) {\n    if (true) {\n        if (typeof mapOrBuilderCallback === \"object\") {\n            throw new Error( false ? 0 : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n        }\n    }\n    let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);\n    let getInitialState;\n    if (isStateFunction(initialState)) {\n        getInitialState = ()=>freezeDraftable(initialState());\n    } else {\n        const frozenInitialState = freezeDraftable(initialState);\n        getInitialState = ()=>frozenInitialState;\n    }\n    function reducer(state = getInitialState(), action) {\n        let caseReducers = [\n            actionsMap[action.type],\n            ...finalActionMatchers.filter(({ matcher })=>matcher(action)).map(({ reducer: reducer2 })=>reducer2)\n        ];\n        if (caseReducers.filter((cr)=>!!cr).length === 0) {\n            caseReducers = [\n                finalDefaultCaseReducer\n            ];\n        }\n        return caseReducers.reduce((previousState, caseReducer)=>{\n            if (caseReducer) {\n                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n                    const draft = previousState;\n                    const result = caseReducer(draft, action);\n                    if (result === void 0) {\n                        return previousState;\n                    }\n                    return result;\n                } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n                    const result = caseReducer(previousState, action);\n                    if (result === void 0) {\n                        if (previousState === null) {\n                            return previousState;\n                        }\n                        throw new Error( false ? 0 : \"A case reducer on a non-draftable value must not return undefined\");\n                    }\n                    return result;\n                } else {\n                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(previousState, (draft)=>{\n                        return caseReducer(draft, action);\n                    });\n                }\n            }\n            return previousState;\n        }, state);\n    }\n    reducer.getInitialState = getInitialState;\n    return reducer;\n}\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = (size = 21)=>{\n    let id = \"\";\n    let i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/matchers.ts\nvar matches = (matcher, action)=>{\n    if (hasMatchFunction(matcher)) {\n        return matcher.match(action);\n    } else {\n        return matcher(action);\n    }\n};\nfunction isAnyOf(...matchers) {\n    return (action)=>{\n        return matchers.some((matcher)=>matches(matcher, action));\n    };\n}\nfunction isAllOf(...matchers) {\n    return (action)=>{\n        return matchers.every((matcher)=>matches(matcher, action));\n    };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n    if (!action || !action.meta) return false;\n    const hasValidRequestId = typeof action.meta.requestId === \"string\";\n    const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n    return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isPending()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.pending);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejected(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejected()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.rejected);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejectedWithValue(...asyncThunks) {\n    const hasFlag = (action)=>{\n        return action && action.meta && action.meta.rejectedWithValue;\n    };\n    if (asyncThunks.length === 0) {\n        return (action)=>{\n            const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n            return combinedMatcher(action);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejectedWithValue()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n        return combinedMatcher(action);\n    };\n}\nfunction isFulfilled(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"fulfilled\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isFulfilled()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.fulfilled);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isAsyncThunkAction(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\",\n                \"fulfilled\",\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isAsyncThunkAction()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = [];\n        for (const asyncThunk of asyncThunks){\n            matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);\n        }\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\n// src/createAsyncThunk.ts\nvar commonProperties = [\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\"\n];\nvar RejectWithValue = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar FulfillWithMeta = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar miniSerializeError = (value)=>{\n    if (typeof value === \"object\" && value !== null) {\n        const simpleError = {};\n        for (const property of commonProperties){\n            if (typeof value[property] === \"string\") {\n                simpleError[property] = value[property];\n            }\n        }\n        return simpleError;\n    }\n    return {\n        message: String(value)\n    };\n};\nvar createAsyncThunk = /* @__PURE__ */ (()=>{\n    function createAsyncThunk2(typePrefix, payloadCreator, options) {\n        const fulfilled = createAction(typePrefix + \"/fulfilled\", (payload, requestId, arg, meta)=>({\n                payload,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"fulfilled\"\n                }\n            }));\n        const pending = createAction(typePrefix + \"/pending\", (requestId, arg, meta)=>({\n                payload: void 0,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"pending\"\n                }\n            }));\n        const rejected = createAction(typePrefix + \"/rejected\", (error, requestId, arg, payload, meta)=>({\n                payload,\n                error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    rejectedWithValue: !!payload,\n                    requestStatus: \"rejected\",\n                    aborted: error?.name === \"AbortError\",\n                    condition: error?.name === \"ConditionError\"\n                }\n            }));\n        function actionCreator(arg) {\n            return (dispatch, getState, extra)=>{\n                const requestId = options?.idGenerator ? options.idGenerator(arg) : nanoid();\n                const abortController = new AbortController();\n                let abortReason;\n                function abort(reason) {\n                    abortReason = reason;\n                    abortController.abort();\n                }\n                const promise = async function() {\n                    let finalAction;\n                    try {\n                        let conditionResult = options?.condition?.(arg, {\n                            getState,\n                            extra\n                        });\n                        if (isThenable(conditionResult)) {\n                            conditionResult = await conditionResult;\n                        }\n                        if (conditionResult === false || abortController.signal.aborted) {\n                            throw {\n                                name: \"ConditionError\",\n                                message: \"Aborted due to condition callback returning false.\"\n                            };\n                        }\n                        const abortedPromise = new Promise((_, reject)=>abortController.signal.addEventListener(\"abort\", ()=>reject({\n                                    name: \"AbortError\",\n                                    message: abortReason || \"Aborted\"\n                                })));\n                        dispatch(pending(requestId, arg, options?.getPendingMeta?.({\n                            requestId,\n                            arg\n                        }, {\n                            getState,\n                            extra\n                        })));\n                        finalAction = await Promise.race([\n                            abortedPromise,\n                            Promise.resolve(payloadCreator(arg, {\n                                dispatch,\n                                getState,\n                                extra,\n                                requestId,\n                                signal: abortController.signal,\n                                abort,\n                                rejectWithValue: (value, meta)=>{\n                                    return new RejectWithValue(value, meta);\n                                },\n                                fulfillWithValue: (value, meta)=>{\n                                    return new FulfillWithMeta(value, meta);\n                                }\n                            })).then((result)=>{\n                                if (result instanceof RejectWithValue) {\n                                    throw result;\n                                }\n                                if (result instanceof FulfillWithMeta) {\n                                    return fulfilled(result.payload, requestId, arg, result.meta);\n                                }\n                                return fulfilled(result, requestId, arg);\n                            })\n                        ]);\n                    } catch (err) {\n                        finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);\n                    }\n                    const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n                    if (!skipDispatch) {\n                        dispatch(finalAction);\n                    }\n                    return finalAction;\n                }();\n                return Object.assign(promise, {\n                    abort,\n                    requestId,\n                    arg,\n                    unwrap () {\n                        return promise.then(unwrapResult);\n                    }\n                });\n            };\n        }\n        return Object.assign(actionCreator, {\n            pending,\n            rejected,\n            fulfilled,\n            settled: isAnyOf(rejected, fulfilled),\n            typePrefix\n        });\n    }\n    createAsyncThunk2.withTypes = ()=>createAsyncThunk2;\n    return createAsyncThunk2;\n})();\nfunction unwrapResult(action) {\n    if (action.meta && action.meta.rejectedWithValue) {\n        throw action.payload;\n    }\n    if (action.error) {\n        throw action.error;\n    }\n    return action.payload;\n}\nfunction isThenable(value) {\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n// src/createSlice.ts\nvar asyncThunkSymbol = Symbol.for(\"rtk-slice-createasyncthunk\");\nvar asyncThunkCreator = {\n    [asyncThunkSymbol]: createAsyncThunk\n};\nvar ReducerType = /* @__PURE__ */ ((ReducerType2)=>{\n    ReducerType2[\"reducer\"] = \"reducer\";\n    ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\n    ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\n    return ReducerType2;\n})(ReducerType || {});\nfunction getType(slice, actionKey) {\n    return `${slice}/${actionKey}`;\n}\nfunction buildCreateSlice({ creators } = {}) {\n    const cAT = creators?.asyncThunk?.[asyncThunkSymbol];\n    return function createSlice2(options) {\n        const { name, reducerPath = name } = options;\n        if (!name) {\n            throw new Error( false ? 0 : \"`name` is a required option for createSlice\");\n        }\n        if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n            if (options.initialState === void 0) {\n                console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n            }\n        }\n        const reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\n        const reducerNames = Object.keys(reducers);\n        const context = {\n            sliceCaseReducersByName: {},\n            sliceCaseReducersByType: {},\n            actionCreators: {},\n            sliceMatchers: []\n        };\n        const contextMethods = {\n            addCase (typeOrActionCreator, reducer) {\n                const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n                if (!type) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with an empty action type\");\n                }\n                if (type in context.sliceCaseReducersByType) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\n                }\n                context.sliceCaseReducersByType[type] = reducer;\n                return contextMethods;\n            },\n            addMatcher (matcher, reducer) {\n                context.sliceMatchers.push({\n                    matcher,\n                    reducer\n                });\n                return contextMethods;\n            },\n            exposeAction (name2, actionCreator) {\n                context.actionCreators[name2] = actionCreator;\n                return contextMethods;\n            },\n            exposeCaseReducer (name2, reducer) {\n                context.sliceCaseReducersByName[name2] = reducer;\n                return contextMethods;\n            }\n        };\n        reducerNames.forEach((reducerName)=>{\n            const reducerDefinition = reducers[reducerName];\n            const reducerDetails = {\n                reducerName,\n                type: getType(name, reducerName),\n                createNotation: typeof options.reducers === \"function\"\n            };\n            if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\n                handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\n            } else {\n                handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\n            }\n        });\n        function buildReducer() {\n            if (true) {\n                if (typeof options.extraReducers === \"object\") {\n                    throw new Error( false ? 0 : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n                }\n            }\n            const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [\n                options.extraReducers\n            ];\n            const finalCaseReducers = {\n                ...extraReducers,\n                ...context.sliceCaseReducersByType\n            };\n            return createReducer(options.initialState, (builder)=>{\n                for(let key in finalCaseReducers){\n                    builder.addCase(key, finalCaseReducers[key]);\n                }\n                for (let sM of context.sliceMatchers){\n                    builder.addMatcher(sM.matcher, sM.reducer);\n                }\n                for (let m of actionMatchers){\n                    builder.addMatcher(m.matcher, m.reducer);\n                }\n                if (defaultCaseReducer) {\n                    builder.addDefaultCase(defaultCaseReducer);\n                }\n            });\n        }\n        const selectSelf = (state)=>state;\n        const injectedSelectorCache = /* @__PURE__ */ new WeakMap();\n        let _reducer;\n        const slice = {\n            name,\n            reducerPath,\n            reducer (state, action) {\n                if (!_reducer) _reducer = buildReducer();\n                return _reducer(state, action);\n            },\n            actions: context.actionCreators,\n            caseReducers: context.sliceCaseReducersByName,\n            getInitialState () {\n                if (!_reducer) _reducer = buildReducer();\n                return _reducer.getInitialState();\n            },\n            getSelectors (selectState = selectSelf) {\n                const selectorCache = emplace(injectedSelectorCache, this, {\n                    insert: ()=>/* @__PURE__ */ new WeakMap()\n                });\n                return emplace(selectorCache, selectState, {\n                    insert: ()=>{\n                        const map = {};\n                        for (const [name2, selector] of Object.entries(options.selectors ?? {})){\n                            map[name2] = wrapSelector(this, selector, selectState, this !== slice);\n                        }\n                        return map;\n                    }\n                });\n            },\n            selectSlice (state) {\n                let sliceState = state[this.reducerPath];\n                if (typeof sliceState === \"undefined\") {\n                    if (this !== slice) {\n                        sliceState = this.getInitialState();\n                    } else if (true) {\n                        throw new Error( false ? 0 : \"selectSlice returned undefined for an uninjected slice reducer\");\n                    }\n                }\n                return sliceState;\n            },\n            get selectors () {\n                return this.getSelectors(this.selectSlice);\n            },\n            injectInto (injectable, { reducerPath: pathOpt, ...config } = {}) {\n                const reducerPath2 = pathOpt ?? this.reducerPath;\n                injectable.inject({\n                    reducerPath: reducerPath2,\n                    reducer: this.reducer\n                }, config);\n                return {\n                    ...this,\n                    reducerPath: reducerPath2\n                };\n            }\n        };\n        return slice;\n    };\n}\nfunction wrapSelector(slice, selector, selectState, injected) {\n    function wrapper(rootState, ...args) {\n        let sliceState = selectState.call(slice, rootState);\n        if (typeof sliceState === \"undefined\") {\n            if (injected) {\n                sliceState = slice.getInitialState();\n            } else if (true) {\n                throw new Error( false ? 0 : \"selectState returned undefined for an uninjected slice reducer\");\n            }\n        }\n        return selector(sliceState, ...args);\n    }\n    wrapper.unwrapped = selector;\n    return wrapper;\n}\nvar createSlice = buildCreateSlice();\nfunction buildReducerCreators() {\n    function asyncThunk(payloadCreator, config) {\n        return {\n            _reducerDefinitionType: \"asyncThunk\" /* asyncThunk */ ,\n            payloadCreator,\n            ...config\n        };\n    }\n    asyncThunk.withTypes = ()=>asyncThunk;\n    return {\n        reducer (caseReducer) {\n            return Object.assign({\n                // hack so the wrapping function has the same name as the original\n                // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\n                [caseReducer.name] (...args) {\n                    return caseReducer(...args);\n                }\n            }[caseReducer.name], {\n                _reducerDefinitionType: \"reducer\" /* reducer */ \n            });\n        },\n        preparedReducer (prepare, reducer) {\n            return {\n                _reducerDefinitionType: \"reducerWithPrepare\" /* reducerWithPrepare */ ,\n                prepare,\n                reducer\n            };\n        },\n        asyncThunk\n    };\n}\nfunction handleNormalReducerDefinition({ type, reducerName, createNotation }, maybeReducerWithPrepare, context) {\n    let caseReducer;\n    let prepareCallback;\n    if (\"reducer\" in maybeReducerWithPrepare) {\n        if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\n            throw new Error( false ? 0 : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\n        }\n        caseReducer = maybeReducerWithPrepare.reducer;\n        prepareCallback = maybeReducerWithPrepare.prepare;\n    } else {\n        caseReducer = maybeReducerWithPrepare;\n    }\n    context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\n}\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"asyncThunk\" /* asyncThunk */ ;\n}\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\" /* reducerWithPrepare */ ;\n}\nfunction handleThunkCaseReducerDefinition({ type, reducerName }, reducerDefinition, context, cAT) {\n    if (!cAT) {\n        throw new Error( false ? 0 : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\n    }\n    const { payloadCreator, fulfilled, pending, rejected, settled, options } = reducerDefinition;\n    const thunk = cAT(type, payloadCreator, options);\n    context.exposeAction(reducerName, thunk);\n    if (fulfilled) {\n        context.addCase(thunk.fulfilled, fulfilled);\n    }\n    if (pending) {\n        context.addCase(thunk.pending, pending);\n    }\n    if (rejected) {\n        context.addCase(thunk.rejected, rejected);\n    }\n    if (settled) {\n        context.addMatcher(thunk.settled, settled);\n    }\n    context.exposeCaseReducer(reducerName, {\n        fulfilled: fulfilled || noop,\n        pending: pending || noop,\n        rejected: rejected || noop,\n        settled: settled || noop\n    });\n}\nfunction noop() {}\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n    return {\n        ids: [],\n        entities: {}\n    };\n}\nfunction createInitialStateFactory() {\n    function getInitialState(additionalState = {}) {\n        return Object.assign(getInitialEntityState(), additionalState);\n    }\n    return {\n        getInitialState\n    };\n}\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n    function getSelectors(selectState, options = {}) {\n        const { createSelector: createSelector2 = createDraftSafeSelector } = options;\n        const selectIds = (state)=>state.ids;\n        const selectEntities = (state)=>state.entities;\n        const selectAll = createSelector2(selectIds, selectEntities, (ids, entities)=>ids.map((id)=>entities[id]));\n        const selectId = (_, id)=>id;\n        const selectById = (entities, id)=>entities[id];\n        const selectTotal = createSelector2(selectIds, (ids)=>ids.length);\n        if (!selectState) {\n            return {\n                selectIds,\n                selectEntities,\n                selectAll,\n                selectTotal,\n                selectById: createSelector2(selectEntities, selectId, selectById)\n            };\n        }\n        const selectGlobalizedEntities = createSelector2(selectState, selectEntities);\n        return {\n            selectIds: createSelector2(selectState, selectIds),\n            selectEntities: selectGlobalizedEntities,\n            selectAll: createSelector2(selectState, selectAll),\n            selectTotal: createSelector2(selectState, selectTotal),\n            selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\n        };\n    }\n    return {\n        getSelectors\n    };\n}\n// src/entities/state_adapter.ts\n\nvar isDraftTyped = immer__WEBPACK_IMPORTED_MODULE_2__.isDraft;\nfunction createSingleArgumentStateOperator(mutator) {\n    const operator = createStateOperator((_, state)=>mutator(state));\n    return function operation(state) {\n        return operator(state, void 0);\n    };\n}\nfunction createStateOperator(mutator) {\n    return function operation(state, arg) {\n        function isPayloadActionArgument(arg2) {\n            return isFSA(arg2);\n        }\n        const runMutator = (draft)=>{\n            if (isPayloadActionArgument(arg)) {\n                mutator(arg.payload, draft);\n            } else {\n                mutator(arg, draft);\n            }\n        };\n        if (isDraftTyped(state)) {\n            runMutator(state);\n            return state;\n        }\n        return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(state, runMutator);\n    };\n}\n// src/entities/utils.ts\nfunction selectIdValue(entity, selectId) {\n    const key = selectId(entity);\n    if ( true && key === void 0) {\n        console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n    }\n    return key;\n}\nfunction ensureEntitiesArray(entities) {\n    if (!Array.isArray(entities)) {\n        entities = Object.values(entities);\n    }\n    return entities;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    const added = [];\n    const updated = [];\n    for (const entity of newEntities){\n        const id = selectIdValue(entity, selectId);\n        if (id in state.entities) {\n            updated.push({\n                id,\n                changes: entity\n            });\n        } else {\n            added.push(entity);\n        }\n    }\n    return [\n        added,\n        updated\n    ];\n}\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n    function addOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (key in state.entities) {\n            return;\n        }\n        state.ids.push(key);\n        state.entities[key] = entity;\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            addOneMutably(entity, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (!(key in state.entities)) {\n            state.ids.push(key);\n        }\n        state.entities[key] = entity;\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            setOneMutably(entity, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.ids = [];\n        state.entities = {};\n        addManyMutably(newEntities, state);\n    }\n    function removeOneMutably(key, state) {\n        return removeManyMutably([\n            key\n        ], state);\n    }\n    function removeManyMutably(keys, state) {\n        let didMutate = false;\n        keys.forEach((key)=>{\n            if (key in state.entities) {\n                delete state.entities[key];\n                didMutate = true;\n            }\n        });\n        if (didMutate) {\n            state.ids = state.ids.filter((id)=>id in state.entities);\n        }\n    }\n    function removeAllMutably(state) {\n        Object.assign(state, {\n            ids: [],\n            entities: {}\n        });\n    }\n    function takeNewKey(keys, update, state) {\n        const original3 = state.entities[update.id];\n        if (original3 === void 0) {\n            return false;\n        }\n        const updated = Object.assign({}, original3, update.changes);\n        const newKey = selectIdValue(updated, selectId);\n        const hasNewKey = newKey !== update.id;\n        if (hasNewKey) {\n            keys[update.id] = newKey;\n            delete state.entities[update.id];\n        }\n        state.entities[newKey] = updated;\n        return hasNewKey;\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        const newKeys = {};\n        const updatesPerEntity = {};\n        updates.forEach((update)=>{\n            if (update.id in state.entities) {\n                updatesPerEntity[update.id] = {\n                    id: update.id,\n                    // Spreads ignore falsy values, so this works even if there isn't\n                    // an existing update already at this key\n                    changes: {\n                        ...updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null,\n                        ...update.changes\n                    }\n                };\n            }\n        });\n        updates = Object.values(updatesPerEntity);\n        const didMutateEntities = updates.length > 0;\n        if (didMutateEntities) {\n            const didMutateIds = updates.filter((update)=>takeNewKey(newKeys, update, state)).length > 0;\n            if (didMutateIds) {\n                state.ids = Object.values(state.entities).map((e)=>selectIdValue(e, selectId));\n            }\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    return {\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\n        addOne: createStateOperator(addOneMutably),\n        addMany: createStateOperator(addManyMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        upsertMany: createStateOperator(upsertManyMutably),\n        removeOne: createStateOperator(removeOneMutably),\n        removeMany: createStateOperator(removeManyMutably)\n    };\n}\n// src/entities/sorted_state_adapter.ts\nfunction createSortedStateAdapter(selectId, sort) {\n    const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(selectId);\n    function addOneMutably(entity, state) {\n        return addManyMutably([\n            entity\n        ], state);\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        const models = newEntities.filter((model)=>!(selectIdValue(model, selectId) in state.entities));\n        if (models.length !== 0) {\n            merge(models, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        return setManyMutably([\n            entity\n        ], state);\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        if (newEntities.length !== 0) {\n            merge(newEntities, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.entities = {};\n        state.ids = [];\n        addManyMutably(newEntities, state);\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        let appliedUpdates = false;\n        for (let update of updates){\n            const entity = state.entities[update.id];\n            if (!entity) {\n                continue;\n            }\n            appliedUpdates = true;\n            Object.assign(entity, update.changes);\n            const newId = selectId(entity);\n            if (update.id !== newId) {\n                delete state.entities[update.id];\n                state.entities[newId] = entity;\n            }\n        }\n        if (appliedUpdates) {\n            resortEntities(state);\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    function areArraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length && i < b.length; i++){\n            if (a[i] === b[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    function merge(models, state) {\n        models.forEach((model)=>{\n            state.entities[selectId(model)] = model;\n        });\n        resortEntities(state);\n    }\n    function resortEntities(state) {\n        const allEntities = Object.values(state.entities);\n        allEntities.sort(sort);\n        const newSortedIds = allEntities.map(selectId);\n        const { ids } = state;\n        if (!areArraysEqual(ids, newSortedIds)) {\n            state.ids = newSortedIds;\n        }\n    }\n    return {\n        removeOne,\n        removeMany,\n        removeAll,\n        addOne: createStateOperator(addOneMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        addMany: createStateOperator(addManyMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertMany: createStateOperator(upsertManyMutably)\n    };\n}\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options = {}) {\n    const { selectId, sortComparer } = {\n        sortComparer: false,\n        selectId: (instance)=>instance.id,\n        ...options\n    };\n    const stateFactory = createInitialStateFactory();\n    const selectorsFactory = createSelectorsFactory();\n    const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n    return {\n        selectId,\n        sortComparer,\n        ...stateFactory,\n        ...selectorsFactory,\n        ...stateAdapter\n    };\n}\n// src/listenerMiddleware/index.ts\n\n// src/listenerMiddleware/utils.ts\nvar assertFunction = (func, expected)=>{\n    if (typeof func !== \"function\") {\n        throw new Error( false ? 0 : `${expected} is not a function`);\n    }\n};\nvar noop2 = ()=>{};\nvar catchRejection = (promise, onError = noop2)=>{\n    promise.catch(onError);\n    return promise;\n};\nvar addAbortSignalListener = (abortSignal, callback)=>{\n    abortSignal.addEventListener(\"abort\", callback, {\n        once: true\n    });\n    return ()=>abortSignal.removeEventListener(\"abort\", callback);\n};\nvar abortControllerWithReason = (abortController, reason)=>{\n    const signal = abortController.signal;\n    if (signal.aborted) {\n        return;\n    }\n    if (!(\"reason\" in signal)) {\n        Object.defineProperty(signal, \"reason\", {\n            enumerable: true,\n            value: reason,\n            configurable: true,\n            writable: true\n        });\n    }\n    ;\n    abortController.abort(reason);\n};\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = `task-${cancelled}`;\nvar taskCompleted = `task-${completed}`;\nvar listenerCancelled = `${listener}-${cancelled}`;\nvar listenerCompleted = `${listener}-${completed}`;\nvar TaskAbortError = class {\n    constructor(code){\n        this.name = \"TaskAbortError\";\n        this.code = code;\n        this.message = `${task} ${cancelled} (reason: ${code})`;\n    }\n};\n// src/listenerMiddleware/task.ts\nvar validateActive = (signal)=>{\n    if (signal.aborted) {\n        const { reason } = signal;\n        throw new TaskAbortError(reason);\n    }\n};\nfunction raceWithSignal(signal, promise) {\n    let cleanup = noop2;\n    return new Promise((resolve, reject)=>{\n        const notifyRejection = ()=>reject(new TaskAbortError(signal.reason));\n        if (signal.aborted) {\n            notifyRejection();\n            return;\n        }\n        cleanup = addAbortSignalListener(signal, notifyRejection);\n        promise.finally(()=>cleanup()).then(resolve, reject);\n    }).finally(()=>{\n        cleanup = noop2;\n    });\n}\nvar runTask = async (task2, cleanUp)=>{\n    try {\n        await Promise.resolve();\n        const value = await task2();\n        return {\n            status: \"ok\",\n            value\n        };\n    } catch (error) {\n        return {\n            status: error instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n            error\n        };\n    } finally{\n        cleanUp?.();\n    }\n};\nvar createPause = (signal)=>{\n    return (promise)=>{\n        return catchRejection(raceWithSignal(signal, promise).then((output)=>{\n            validateActive(signal);\n            return output;\n        }));\n    };\n};\nvar createDelay = (signal)=>{\n    const pause = createPause(signal);\n    return (timeoutMs)=>{\n        return pause(new Promise((resolve)=>setTimeout(resolve, timeoutMs)));\n    };\n};\n// src/listenerMiddleware/index.ts\nvar { assign } = Object;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = (parentAbortSignal, parentBlockingPromises)=>{\n    const linkControllers = (controller)=>addAbortSignalListener(parentAbortSignal, ()=>abortControllerWithReason(controller, parentAbortSignal.reason));\n    return (taskExecutor, opts)=>{\n        assertFunction(taskExecutor, \"taskExecutor\");\n        const childAbortController = new AbortController();\n        linkControllers(childAbortController);\n        const result = runTask(async ()=>{\n            validateActive(parentAbortSignal);\n            validateActive(childAbortController.signal);\n            const result2 = await taskExecutor({\n                pause: createPause(childAbortController.signal),\n                delay: createDelay(childAbortController.signal),\n                signal: childAbortController.signal\n            });\n            validateActive(childAbortController.signal);\n            return result2;\n        }, ()=>abortControllerWithReason(childAbortController, taskCompleted));\n        if (opts?.autoJoin) {\n            parentBlockingPromises.push(result);\n        }\n        return {\n            result: createPause(parentAbortSignal)(result),\n            cancel () {\n                abortControllerWithReason(childAbortController, taskCancelled);\n            }\n        };\n    };\n};\nvar createTakePattern = (startListening, signal)=>{\n    const take = async (predicate, timeout)=>{\n        validateActive(signal);\n        let unsubscribe = ()=>{};\n        const tuplePromise = new Promise((resolve, reject)=>{\n            let stopListening = startListening({\n                predicate,\n                effect: (action, listenerApi)=>{\n                    listenerApi.unsubscribe();\n                    resolve([\n                        action,\n                        listenerApi.getState(),\n                        listenerApi.getOriginalState()\n                    ]);\n                }\n            });\n            unsubscribe = ()=>{\n                stopListening();\n                reject();\n            };\n        });\n        const promises = [\n            tuplePromise\n        ];\n        if (timeout != null) {\n            promises.push(new Promise((resolve)=>setTimeout(resolve, timeout, null)));\n        }\n        try {\n            const output = await raceWithSignal(signal, Promise.race(promises));\n            validateActive(signal);\n            return output;\n        } finally{\n            unsubscribe();\n        }\n    };\n    return (predicate, timeout)=>catchRejection(take(predicate, timeout));\n};\nvar getListenerEntryPropsFrom = (options)=>{\n    let { type, actionCreator, matcher, predicate, effect } = options;\n    if (type) {\n        predicate = createAction(type).match;\n    } else if (actionCreator) {\n        type = actionCreator.type;\n        predicate = actionCreator.match;\n    } else if (matcher) {\n        predicate = matcher;\n    } else if (predicate) {} else {\n        throw new Error( false ? 0 : \"Creating or removing a listener requires one of the known fields for matching an action\");\n    }\n    assertFunction(effect, \"options.listener\");\n    return {\n        predicate,\n        type,\n        effect\n    };\n};\nvar createListenerEntry = (options)=>{\n    const { type, predicate, effect } = getListenerEntryPropsFrom(options);\n    const id = nanoid();\n    const entry = {\n        id,\n        effect,\n        type,\n        predicate,\n        pending: /* @__PURE__ */ new Set(),\n        unsubscribe: ()=>{\n            throw new Error( false ? 0 : \"Unsubscribe not initialized\");\n        }\n    };\n    return entry;\n};\nvar cancelActiveListeners = (entry)=>{\n    entry.pending.forEach((controller)=>{\n        abortControllerWithReason(controller, listenerCancelled);\n    });\n};\nvar createClearListenerMiddleware = (listenerMap)=>{\n    return ()=>{\n        listenerMap.forEach(cancelActiveListeners);\n        listenerMap.clear();\n    };\n};\nvar safelyNotifyError = (errorHandler, errorToNotify, errorInfo)=>{\n    try {\n        errorHandler(errorToNotify, errorInfo);\n    } catch (errorHandlerError) {\n        setTimeout(()=>{\n            throw errorHandlerError;\n        }, 0);\n    }\n};\nvar addListener = createAction(`${alm}/add`);\nvar clearAllListeners = createAction(`${alm}/removeAll`);\nvar removeListener = createAction(`${alm}/remove`);\nvar defaultErrorHandler = (...args)=>{\n    console.error(`${alm}/error`, ...args);\n};\nfunction createListenerMiddleware(middlewareOptions = {}) {\n    const listenerMap = /* @__PURE__ */ new Map();\n    const { extra, onError = defaultErrorHandler } = middlewareOptions;\n    assertFunction(onError, \"onError\");\n    const insertEntry = (entry)=>{\n        entry.unsubscribe = ()=>listenerMap.delete(entry.id);\n        listenerMap.set(entry.id, entry);\n        return (cancelOptions)=>{\n            entry.unsubscribe();\n            if (cancelOptions?.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        };\n    };\n    const startListening = (options)=>{\n        let entry = find(Array.from(listenerMap.values()), (existingEntry)=>existingEntry.effect === options.effect);\n        if (!entry) {\n            entry = createListenerEntry(options);\n        }\n        return insertEntry(entry);\n    };\n    const stopListening = (options)=>{\n        const { type, effect, predicate } = getListenerEntryPropsFrom(options);\n        const entry = find(Array.from(listenerMap.values()), (entry2)=>{\n            const matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n            return matchPredicateOrType && entry2.effect === effect;\n        });\n        if (entry) {\n            entry.unsubscribe();\n            if (options.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        }\n        return !!entry;\n    };\n    const notifyListener = async (entry, action, api, getOriginalState)=>{\n        const internalTaskController = new AbortController();\n        const take = createTakePattern(startListening, internalTaskController.signal);\n        const autoJoinPromises = [];\n        try {\n            entry.pending.add(internalTaskController);\n            await Promise.resolve(entry.effect(action, // Use assign() rather than ... to avoid extra helper functions added to bundle\n            assign({}, api, {\n                getOriginalState,\n                condition: (predicate, timeout)=>take(predicate, timeout).then(Boolean),\n                take,\n                delay: createDelay(internalTaskController.signal),\n                pause: createPause(internalTaskController.signal),\n                extra,\n                signal: internalTaskController.signal,\n                fork: createFork(internalTaskController.signal, autoJoinPromises),\n                unsubscribe: entry.unsubscribe,\n                subscribe: ()=>{\n                    listenerMap.set(entry.id, entry);\n                },\n                cancelActiveListeners: ()=>{\n                    entry.pending.forEach((controller, _, set)=>{\n                        if (controller !== internalTaskController) {\n                            abortControllerWithReason(controller, listenerCancelled);\n                            set.delete(controller);\n                        }\n                    });\n                },\n                cancel: ()=>{\n                    abortControllerWithReason(internalTaskController, listenerCancelled);\n                    entry.pending.delete(internalTaskController);\n                },\n                throwIfCancelled: ()=>{\n                    validateActive(internalTaskController.signal);\n                }\n            })));\n        } catch (listenerError) {\n            if (!(listenerError instanceof TaskAbortError)) {\n                safelyNotifyError(onError, listenerError, {\n                    raisedBy: \"effect\"\n                });\n            }\n        } finally{\n            await Promise.allSettled(autoJoinPromises);\n            abortControllerWithReason(internalTaskController, listenerCompleted);\n            entry.pending.delete(internalTaskController);\n        }\n    };\n    const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n    const middleware = (api)=>(next)=>(action)=>{\n                if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                    return next(action);\n                }\n                if (addListener.match(action)) {\n                    return startListening(action.payload);\n                }\n                if (clearAllListeners.match(action)) {\n                    clearListenerMiddleware();\n                    return;\n                }\n                if (removeListener.match(action)) {\n                    return stopListening(action.payload);\n                }\n                let originalState = api.getState();\n                const getOriginalState = ()=>{\n                    if (originalState === INTERNAL_NIL_TOKEN) {\n                        throw new Error( false ? 0 : `${alm}: getOriginalState can only be called synchronously`);\n                    }\n                    return originalState;\n                };\n                let result;\n                try {\n                    result = next(action);\n                    if (listenerMap.size > 0) {\n                        let currentState = api.getState();\n                        const listenerEntries = Array.from(listenerMap.values());\n                        for (let entry of listenerEntries){\n                            let runListener = false;\n                            try {\n                                runListener = entry.predicate(action, currentState, originalState);\n                            } catch (predicateError) {\n                                runListener = false;\n                                safelyNotifyError(onError, predicateError, {\n                                    raisedBy: \"predicate\"\n                                });\n                            }\n                            if (!runListener) {\n                                continue;\n                            }\n                            notifyListener(entry, action, api, getOriginalState);\n                        }\n                    }\n                } finally{\n                    originalState = INTERNAL_NIL_TOKEN;\n                }\n                return result;\n            };\n    return {\n        middleware,\n        startListening,\n        stopListening,\n        clearListeners: clearListenerMiddleware\n    };\n}\n// src/dynamicMiddleware/index.ts\n\nvar createMiddlewareEntry = (middleware)=>({\n        id: nanoid(),\n        middleware,\n        applied: /* @__PURE__ */ new Map()\n    });\nvar matchInstance = (instanceId)=>(action)=>action?.meta?.instanceId === instanceId;\nvar createDynamicMiddleware = ()=>{\n    const instanceId = nanoid();\n    const middlewareMap = /* @__PURE__ */ new Map();\n    const withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", (...middlewares)=>({\n            payload: middlewares,\n            meta: {\n                instanceId\n            }\n        })), {\n        withTypes: ()=>withMiddleware\n    });\n    const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {\n        middlewares.forEach((middleware2)=>{\n            let entry = find(Array.from(middlewareMap.values()), (entry2)=>entry2.middleware === middleware2);\n            if (!entry) {\n                entry = createMiddlewareEntry(middleware2);\n            }\n            middlewareMap.set(entry.id, entry);\n        });\n    }, {\n        withTypes: ()=>addMiddleware\n    });\n    const getFinalMiddleware = (api)=>{\n        const appliedMiddleware = Array.from(middlewareMap.values()).map((entry)=>emplace(entry.applied, api, {\n                insert: ()=>entry.middleware(api)\n            }));\n        return (0,redux__WEBPACK_IMPORTED_MODULE_0__.compose)(...appliedMiddleware);\n    };\n    const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\n    const middleware = (api)=>(next)=>(action)=>{\n                if (isWithMiddleware(action)) {\n                    addMiddleware(...action.payload);\n                    return api.dispatch;\n                }\n                return getFinalMiddleware(api)(next)(action);\n            };\n    return {\n        middleware,\n        addMiddleware,\n        withMiddleware,\n        instanceId\n    };\n};\n// src/combineSlices.ts\n\nvar isSliceLike = (maybeSliceLike)=>\"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\nvar getReducers = (slices)=>slices.flatMap((sliceOrMap)=>isSliceLike(sliceOrMap) ? [\n            [\n                sliceOrMap.reducerPath,\n                sliceOrMap.reducer\n            ]\n        ] : Object.entries(sliceOrMap));\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\nvar isStateProxy = (value)=>!!value && !!value[ORIGINAL_STATE];\nvar stateProxyMap = /* @__PURE__ */ new WeakMap();\nvar createStateProxy = (state, reducerMap)=>emplace(stateProxyMap, state, {\n        insert: ()=>new Proxy(state, {\n                get: (target, prop, receiver)=>{\n                    if (prop === ORIGINAL_STATE) return target;\n                    const result = Reflect.get(target, prop, receiver);\n                    if (typeof result === \"undefined\") {\n                        const reducer = reducerMap[prop.toString()];\n                        if (reducer) {\n                            const reducerResult = reducer(void 0, {\n                                type: nanoid()\n                            });\n                            if (typeof reducerResult === \"undefined\") {\n                                throw new Error( false ? 0 : `The slice reducer for key \"${prop.toString()}\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n                            }\n                            return reducerResult;\n                        }\n                    }\n                    return result;\n                }\n            })\n    });\nvar original = (state)=>{\n    if (!isStateProxy(state)) {\n        throw new Error( false ? 0 : \"original must be used on state Proxy\");\n    }\n    return state[ORIGINAL_STATE];\n};\nfunction combineSlices(...slices) {\n    const reducerMap = Object.fromEntries(getReducers(slices));\n    const getReducer = ()=>(0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducerMap);\n    let reducer = getReducer();\n    function combinedReducer(state, action) {\n        return reducer(state, action);\n    }\n    combinedReducer.withLazyLoadedSlices = ()=>combinedReducer;\n    const inject = (slice, config = {})=>{\n        const { reducerPath, reducer: reducerToInject } = slice;\n        const currentReducer = reducerMap[reducerPath];\n        if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\n            if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n                console.error(`called \\`inject\\` to override already-existing reducer ${reducerPath} without specifying \\`overrideExisting: true\\``);\n            }\n            return combinedReducer;\n        }\n        reducerMap[reducerPath] = reducerToInject;\n        reducer = getReducer();\n        return combinedReducer;\n    };\n    const selector = Object.assign(function makeSelector(selectorFn, selectState) {\n        return function selector2(state, ...args) {\n            return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap), ...args);\n        };\n    }, {\n        original\n    });\n    return Object.assign(combinedReducer, {\n        inject,\n        selector\n    });\n}\n// src/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n    return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n}\n //# sourceMappingURL=redux-toolkit.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ087QUFDbUY7QUFDaUM7QUFFMUksaUNBQWlDO0FBQ1E7QUFDd0I7QUFDakUsSUFBSWMsaUNBQWlDLENBQUMsR0FBR0M7SUFDdkMsTUFBTUMsa0JBQWtCUCwrREFBcUJBLElBQUlNO0lBQ2pELE9BQU8sQ0FBQyxHQUFHRTtRQUNULE1BQU1DLFdBQVdGLG1CQUFtQkM7UUFDcEMsTUFBTUUsa0JBQWtCLENBQUNDLE9BQU8sR0FBR0MsT0FBU0gsU0FBU1osOENBQU9BLENBQUNjLFNBQVNuQiw4Q0FBT0EsQ0FBQ21CLFNBQVNBLFVBQVVDO1FBQ2pHQyxPQUFPQyxNQUFNLENBQUNKLGlCQUFpQkQ7UUFDL0IsT0FBT0M7SUFDVDtBQUNGO0FBQ0EsSUFBSUssMEJBQTBCViwrQkFBK0JGLG9EQUFjQTtBQUUzRSx3QkFBd0I7QUFDb0c7QUFFNUgsMkJBQTJCO0FBQ0s7QUFDaEMsSUFBSW9CLHNCQUFzQixNQUE0RSxHQUFHQyxDQUEyQyxHQUFHO0lBQ3JKLElBQUlFLFVBQVVDLE1BQU0sS0FBSyxHQUN2QixPQUFPLEtBQUs7SUFDZCxJQUFJLE9BQU9ELFNBQVMsQ0FBQyxFQUFFLEtBQUssVUFDMUIsT0FBT1IsMENBQU9BO0lBQ2hCLE9BQU9BLDBDQUFPQSxDQUFDVSxLQUFLLENBQUMsTUFBTUY7QUFDN0I7QUFDQSxJQUFJRyxtQkFBbUIsTUFBb0UsR0FBR0wsQ0FBbUMsR0FBRztJQUNsSSxPQUFPLFNBQVNPLEtBQUs7UUFDbkIsT0FBT0E7SUFDVDtBQUNGO0FBRUEsOEJBQThCO0FBQzRDO0FBRTFFLHNCQUFzQjtBQUNXO0FBRWpDLG1CQUFtQjtBQUNuQixJQUFJSyxtQkFBbUIsQ0FBQ0M7SUFD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QUFPa0IsT0FBT0MsTUFBTSxDQUFDZ29CLGlCQUFpQjtRQUNwQ25QO1FBQ0FsWjtJQUNGO0FBQ0Y7QUFFQSxnQ0FBZ0M7QUFDaEMsU0FBU3FDLHVCQUF1QjJlLElBQUk7SUFDbEMsT0FBTyxDQUFDLDhCQUE4QixFQUFFQSxLQUFLLGlEQUFpRCxFQUFFQSxLQUFLLCtFQUErRSxDQUFDO0FBQ3ZMO0FBb0RFLENBQ0YsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2FnZS5zdG9yZS8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcmVkdXgtdG9vbGtpdC5tb2Rlcm4ubWpzP2FkM2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicmVkdXhcIjtcbmltcG9ydCB7IHByb2R1Y2UsIGN1cnJlbnQgYXMgY3VycmVudDIsIGZyZWV6ZSwgb3JpZ2luYWwgYXMgb3JpZ2luYWwyLCBpc0RyYWZ0IGFzIGlzRHJhZnQ0IH0gZnJvbSBcImltbWVyXCI7XG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvciwgY3JlYXRlU2VsZWN0b3JDcmVhdG9yIGFzIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcjIsIGxydU1lbW9pemUsIHdlYWtNYXBNZW1vaXplIGFzIHdlYWtNYXBNZW1vaXplMiB9IGZyb20gXCJyZXNlbGVjdFwiO1xuXG4vLyBzcmMvY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IudHNcbmltcG9ydCB7IGN1cnJlbnQsIGlzRHJhZnQgfSBmcm9tIFwiaW1tZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciwgd2Vha01hcE1lbW9pemUgfSBmcm9tIFwicmVzZWxlY3RcIjtcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBjcmVhdGVTZWxlY3RvcjIgPSBjcmVhdGVTZWxlY3RvckNyZWF0b3IoLi4uYXJncyk7XG4gIHJldHVybiAoLi4uYXJnczIpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yMiguLi5hcmdzMik7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gKHZhbHVlLCAuLi5yZXN0KSA9PiBzZWxlY3Rvcihpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWUsIC4uLnJlc3QpO1xuICAgIE9iamVjdC5hc3NpZ24od3JhcHBlZFNlbGVjdG9yLCBzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvcjtcbiAgfTtcbn07XG52YXIgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IgPSBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3Iod2Vha01hcE1lbW9pemUpO1xuXG4vLyBzcmMvY29uZmlndXJlU3RvcmUudHNcbmltcG9ydCB7IGFwcGx5TWlkZGxld2FyZSwgY3JlYXRlU3RvcmUsIGNvbXBvc2UgYXMgY29tcG9zZTIsIGNvbWJpbmVSZWR1Y2VycywgaXNQbGFpbk9iamVjdCBhcyBpc1BsYWluT2JqZWN0MiB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvZGV2dG9vbHNFeHRlbnNpb24udHNcbmltcG9ydCB7IGNvbXBvc2UgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBjb21wb3NlV2l0aERldlRvb2xzID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA6IGZ1bmN0aW9uKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gdm9pZCAwO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gY29tcG9zZTtcbiAgcmV0dXJuIGNvbXBvc2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG52YXIgZGV2VG9vbHNFbmhhbmNlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA6IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZnVuY3Rpb24obm9vcDMpIHtcbiAgICByZXR1cm4gbm9vcDM7XG4gIH07XG59O1xuXG4vLyBzcmMvZ2V0RGVmYXVsdE1pZGRsZXdhcmUudHNcbmltcG9ydCB7IHRodW5rIGFzIHRodW5rTWlkZGxld2FyZSwgd2l0aEV4dHJhQXJndW1lbnQgfSBmcm9tIFwicmVkdXgtdGh1bmtcIjtcblxuLy8gc3JjL2NyZWF0ZUFjdGlvbi50c1xuaW1wb3J0IHsgaXNBY3Rpb24gfSBmcm9tIFwicmVkdXhcIjtcblxuLy8gc3JjL3RzSGVscGVycy50c1xudmFyIGhhc01hdGNoRnVuY3Rpb24gPSAodikgPT4ge1xuICByZXR1cm4gdiAmJiB0eXBlb2Ygdi5tYXRjaCA9PT0gXCJmdW5jdGlvblwiO1xufTtcblxuLy8gc3JjL2NyZWF0ZUFjdGlvbi50c1xuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVBY3Rpb24pIHtcbiAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvciguLi5hcmdzKSB7XG4gICAgaWYgKHByZXBhcmVBY3Rpb24pIHtcbiAgICAgIGxldCBwcmVwYXJlZCA9IHByZXBhcmVBY3Rpb24oLi4uYXJncyk7XG4gICAgICBpZiAoIXByZXBhcmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDApIDogXCJwcmVwYXJlQWN0aW9uIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHBheWxvYWQ6IHByZXBhcmVkLnBheWxvYWQsXG4gICAgICAgIC4uLlwibWV0YVwiIGluIHByZXBhcmVkICYmIHtcbiAgICAgICAgICBtZXRhOiBwcmVwYXJlZC5tZXRhXG4gICAgICAgIH0sXG4gICAgICAgIC4uLlwiZXJyb3JcIiBpbiBwcmVwYXJlZCAmJiB7XG4gICAgICAgICAgZXJyb3I6IHByZXBhcmVkLmVycm9yXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlLFxuICAgICAgcGF5bG9hZDogYXJnc1swXVxuICAgIH07XG4gIH1cbiAgYWN0aW9uQ3JlYXRvci50b1N0cmluZyA9ICgpID0+IGAke3R5cGV9YDtcbiAgYWN0aW9uQ3JlYXRvci50eXBlID0gdHlwZTtcbiAgYWN0aW9uQ3JlYXRvci5tYXRjaCA9IChhY3Rpb24pID0+IGlzQWN0aW9uKGFjdGlvbikgJiYgYWN0aW9uLnR5cGUgPT09IHR5cGU7XG4gIHJldHVybiBhY3Rpb25DcmVhdG9yO1xufVxuZnVuY3Rpb24gaXNBY3Rpb25DcmVhdG9yKGFjdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gXCJmdW5jdGlvblwiICYmIFwidHlwZVwiIGluIGFjdGlvbiAmJiAvLyBoYXNNYXRjaEZ1bmN0aW9uIG9ubHkgd2FudHMgTWF0Y2hlcnMgYnV0IEkgZG9uJ3Qgc2VlIHRoZSBwb2ludCBpbiByZXdyaXRpbmcgaXRcbiAgaGFzTWF0Y2hGdW5jdGlvbihhY3Rpb24pO1xufVxuZnVuY3Rpb24gaXNGU0EoYWN0aW9uKSB7XG4gIHJldHVybiBpc0FjdGlvbihhY3Rpb24pICYmIE9iamVjdC5rZXlzKGFjdGlvbikuZXZlcnkoaXNWYWxpZEtleSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICByZXR1cm4gW1widHlwZVwiLCBcInBheWxvYWRcIiwgXCJlcnJvclwiLCBcIm1ldGFcIl0uaW5kZXhPZihrZXkpID4gLTE7XG59XG5cbi8vIHNyYy9hY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gZ2V0TWVzc2FnZSh0eXBlKSB7XG4gIGNvbnN0IHNwbGl0VHlwZSA9IHR5cGUgPyBgJHt0eXBlfWAuc3BsaXQoXCIvXCIpIDogW107XG4gIGNvbnN0IGFjdGlvbk5hbWUgPSBzcGxpdFR5cGVbc3BsaXRUeXBlLmxlbmd0aCAtIDFdIHx8IFwiYWN0aW9uQ3JlYXRvclwiO1xuICByZXR1cm4gYERldGVjdGVkIGFuIGFjdGlvbiBjcmVhdG9yIHdpdGggdHlwZSBcIiR7dHlwZSB8fCBcInVua25vd25cIn1cIiBiZWluZyBkaXNwYXRjaGVkLiBcbk1ha2Ugc3VyZSB5b3UncmUgY2FsbGluZyB0aGUgYWN0aW9uIGNyZWF0b3IgYmVmb3JlIGRpc3BhdGNoaW5nLCBpLmUuIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0oKSlcXGAgaW5zdGVhZCBvZiBcXGBkaXNwYXRjaCgke2FjdGlvbk5hbWV9KVxcYC4gVGhpcyBpcyBuZWNlc3NhcnkgZXZlbiBpZiB0aGUgYWN0aW9uIGhhcyBubyBwYXlsb2FkLmA7XG59XG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4gbmV4dChhY3Rpb24pO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpc0FjdGlvbkNyZWF0b3I6IGlzQWN0aW9uQ3JlYXRvcjIgPSBpc0FjdGlvbkNyZWF0b3JcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmIChpc0FjdGlvbkNyZWF0b3IyKGFjdGlvbikpIHtcbiAgICAgIGNvbnNvbGUud2FybihnZXRNZXNzYWdlKGFjdGlvbi50eXBlKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUsIGlzRHJhZnRhYmxlIH0gZnJvbSBcImltbWVyXCI7XG5mdW5jdGlvbiBnZXRUaW1lTWVhc3VyZVV0aWxzKG1heERlbGF5LCBmbk5hbWUpIHtcbiAgbGV0IGVsYXBzZWQgPSAwO1xuICByZXR1cm4ge1xuICAgIG1lYXN1cmVUaW1lKGZuKSB7XG4gICAgICBjb25zdCBzdGFydGVkID0gRGF0ZS5ub3coKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29uc3QgZmluaXNoZWQgPSBEYXRlLm5vdygpO1xuICAgICAgICBlbGFwc2VkICs9IGZpbmlzaGVkIC0gc3RhcnRlZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhcm5JZkV4Y2VlZGVkKCkge1xuICAgICAgaWYgKGVsYXBzZWQgPiBtYXhEZWxheSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYCR7Zm5OYW1lfSB0b29rICR7ZWxhcHNlZH1tcywgd2hpY2ggaXMgbW9yZSB0aGFuIHRoZSB3YXJuaW5nIHRocmVzaG9sZCBvZiAke21heERlbGF5fW1zLiBcbklmIHlvdXIgc3RhdGUgb3IgYWN0aW9ucyBhcmUgdmVyeSBsYXJnZSwgeW91IG1heSB3YW50IHRvIGRpc2FibGUgdGhlIG1pZGRsZXdhcmUgYXMgaXQgbWlnaHQgY2F1c2UgdG9vIG11Y2ggb2YgYSBzbG93ZG93biBpbiBkZXZlbG9wbWVudCBtb2RlLiBTZWUgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvZ2V0RGVmYXVsdE1pZGRsZXdhcmUgZm9yIGluc3RydWN0aW9ucy5cbkl0IGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLCBzbyB5b3UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGF0LmApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmQoaXRlcmFibGUsIGNvbXBhcmF0b3IpIHtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiBpdGVyYWJsZSkge1xuICAgIGlmIChjb21wYXJhdG9yKGVudHJ5KSkge1xuICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxudmFyIFR1cGxlID0gY2xhc3MgX1R1cGxlIGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3RvciguLi5pdGVtcykge1xuICAgIHN1cGVyKC4uLml0ZW1zKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgX1R1cGxlLnByb3RvdHlwZSk7XG4gIH1cbiAgc3RhdGljIGdldCBbU3ltYm9sLnNwZWNpZXNdKCkge1xuICAgIHJldHVybiBfVHVwbGU7XG4gIH1cbiAgY29uY2F0KC4uLmFycikge1xuICAgIHJldHVybiBzdXBlci5jb25jYXQuYXBwbHkodGhpcywgYXJyKTtcbiAgfVxuICBwcmVwZW5kKC4uLmFycikge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyWzBdKSkge1xuICAgICAgcmV0dXJuIG5ldyBfVHVwbGUoLi4uYXJyWzBdLmNvbmNhdCh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1R1cGxlKC4uLmFyci5jb25jYXQodGhpcykpO1xuICB9XG59O1xuZnVuY3Rpb24gZnJlZXplRHJhZnRhYmxlKHZhbCkge1xuICByZXR1cm4gaXNEcmFmdGFibGUodmFsKSA/IGNyZWF0ZU5leHRTdGF0ZSh2YWwsICgpID0+IHtcbiAgfSkgOiB2YWw7XG59XG5mdW5jdGlvbiBlbXBsYWNlKG1hcCwga2V5LCBoYW5kbGVyKSB7XG4gIGlmIChtYXAuaGFzKGtleSkpIHtcbiAgICBsZXQgdmFsdWUgPSBtYXAuZ2V0KGtleSk7XG4gICAgaWYgKGhhbmRsZXIudXBkYXRlKSB7XG4gICAgICB2YWx1ZSA9IGhhbmRsZXIudXBkYXRlKHZhbHVlLCBrZXksIG1hcCk7XG4gICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKCFoYW5kbGVyLmluc2VydClcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMCkgOiBcIk5vIGluc2VydCBwcm92aWRlZCBmb3Iga2V5IG5vdCBhbHJlYWR5IGluIG1hcFwiKTtcbiAgY29uc3QgaW5zZXJ0ZWQgPSBoYW5kbGVyLmluc2VydChrZXksIG1hcCk7XG4gIG1hcC5zZXQoa2V5LCBpbnNlcnRlZCk7XG4gIHJldHVybiBpbnNlcnRlZDtcbn1cblxuLy8gc3JjL2ltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT0gbnVsbCB8fCBPYmplY3QuaXNGcm96ZW4odmFsdWUpO1xufVxuZnVuY3Rpb24gdHJhY2tGb3JNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopIHtcbiAgY29uc3QgdHJhY2tlZFByb3BlcnRpZXMgPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopO1xuICByZXR1cm4ge1xuICAgIGRldGVjdE11dGF0aW9ucygpIHtcbiAgICAgIHJldHVybiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCB0cmFja2VkUHJvcGVydGllcywgb2JqKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzID0gW10sIG9iaiwgcGF0aCA9IFwiXCIsIGNoZWNrZWRPYmplY3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkge1xuICBjb25zdCB0cmFja2VkID0ge1xuICAgIHZhbHVlOiBvYmpcbiAgfTtcbiAgaWYgKCFpc0ltbXV0YWJsZShvYmopICYmICFjaGVja2VkT2JqZWN0cy5oYXMob2JqKSkge1xuICAgIGNoZWNrZWRPYmplY3RzLmFkZChvYmopO1xuICAgIHRyYWNrZWQuY2hpbGRyZW4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgICBpZiAoaWdub3JlUGF0aHMubGVuZ3RoICYmIGlnbm9yZVBhdGhzLmluZGV4T2YoY2hpbGRQYXRoKSAhPT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0cmFja2VkLmNoaWxkcmVuW2tleV0gPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmpba2V5XSwgY2hpbGRQYXRoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYWNrZWQ7XG59XG5mdW5jdGlvbiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocyA9IFtdLCB0cmFja2VkUHJvcGVydHksIG9iaiwgc2FtZVBhcmVudFJlZiA9IGZhbHNlLCBwYXRoID0gXCJcIikge1xuICBjb25zdCBwcmV2T2JqID0gdHJhY2tlZFByb3BlcnR5ID8gdHJhY2tlZFByb3BlcnR5LnZhbHVlIDogdm9pZCAwO1xuICBjb25zdCBzYW1lUmVmID0gcHJldk9iaiA9PT0gb2JqO1xuICBpZiAoc2FtZVBhcmVudFJlZiAmJiAhc2FtZVJlZiAmJiAhTnVtYmVyLmlzTmFOKG9iaikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FzTXV0YXRlZDogdHJ1ZSxcbiAgICAgIHBhdGhcbiAgICB9O1xuICB9XG4gIGlmIChpc0ltbXV0YWJsZShwcmV2T2JqKSB8fCBpc0ltbXV0YWJsZShvYmopKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhc011dGF0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjb25zdCBrZXlzVG9EZXRlY3QgPSB7fTtcbiAgZm9yIChsZXQga2V5IGluIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbikge1xuICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZTtcbiAgfVxuICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xuICB9XG4gIGNvbnN0IGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xuICBmb3IgKGxldCBrZXkgaW4ga2V5c1RvRGV0ZWN0KSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKGhhc0lnbm9yZWRQYXRocykge1xuICAgICAgY29uc3QgaGFzTWF0Y2hlcyA9IGlnbm9yZWRQYXRocy5zb21lKChpZ25vcmVkKSA9PiB7XG4gICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVzdGVkUGF0aCA9PT0gaWdub3JlZDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc01hdGNoZXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzLCB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW5ba2V5XSwgb2JqW2tleV0sIHNhbWVSZWYsIG5lc3RlZFBhdGgpO1xuICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3YXNNdXRhdGVkOiBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHN0cmluZ2lmeTIgPSBmdW5jdGlvbihvYmosIHNlcmlhbGl6ZXIsIGluZGVudCwgZGVjeWNsZXIpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIGdldFNlcmlhbGl6ZTIoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xuICAgIH0sIGdldFNlcmlhbGl6ZTIgPSBmdW5jdGlvbihzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xuICAgICAgbGV0IHN0YWNrID0gW10sIGtleXMgPSBbXTtcbiAgICAgIGlmICghZGVjeWNsZXIpXG4gICAgICAgIGRlY3ljbGVyID0gZnVuY3Rpb24oXywgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoc3RhY2tbMF0gPT09IHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIFwiW0NpcmN1bGFyIH5dXCI7XG4gICAgICAgICAgcmV0dXJuIFwiW0NpcmN1bGFyIH4uXCIgKyBrZXlzLnNsaWNlKDAsIHN0YWNrLmluZGV4T2YodmFsdWUpKS5qb2luKFwiLlwiKSArIFwiXVwiO1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdGhpc1BvcyA9IHN0YWNrLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IGtleXMuc3BsaWNlKHRoaXNQb3MsIEluZmluaXR5LCBrZXkpIDoga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gZGVjeWNsZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgc3RyaW5naWZ5ID0gc3RyaW5naWZ5MiwgZ2V0U2VyaWFsaXplID0gZ2V0U2VyaWFsaXplMjtcbiAgICBsZXQge1xuICAgICAgaXNJbW11dGFibGUgPSBpc0ltbXV0YWJsZURlZmF1bHQsXG4gICAgICBpZ25vcmVkUGF0aHMsXG4gICAgICB3YXJuQWZ0ZXIgPSAzMlxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tGb3JNdXRhdGlvbnMuYmluZChudWxsLCBpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzKTtcbiAgICByZXR1cm4gKHtcbiAgICAgIGdldFN0YXRlXG4gICAgfSkgPT4ge1xuICAgICAgbGV0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgIGxldCB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIHJldHVybiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc3VsdCA9IHRyYWNrZXIuZGV0ZWN0TXV0YXRpb25zKCk7XG4gICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcbiAgICAgICAgICBpZiAocmVzdWx0Lndhc011dGF0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE5KSA6IGBBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBiZXR3ZWVuIGRpc3BhdGNoZXMsIGluIHRoZSBwYXRoICcke3Jlc3VsdC5wYXRoIHx8IFwiXCJ9Jy4gIFRoaXMgbWF5IGNhdXNlIGluY29ycmVjdCBiZWhhdmlvci4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hlZEFjdGlvbiA9IG5leHQoYWN0aW9uKTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjApIDogYEEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGluc2lkZSBhIGRpc3BhdGNoLCBpbiB0aGUgcGF0aDogJHtyZXN1bHQucGF0aCB8fCBcIlwifS4gVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhlIGFjdGlvbiAke3N0cmluZ2lmeTIoYWN0aW9uKX0uIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hlZEFjdGlvbjtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvc2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5pbXBvcnQgeyBpc0FjdGlvbiBhcyBpc0FjdGlvbjIsIGlzUGxhaW5PYmplY3QgfSBmcm9tIFwicmVkdXhcIjtcbmZ1bmN0aW9uIGlzUGxhaW4odmFsKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsO1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsKSB8fCBpc1BsYWluT2JqZWN0KHZhbCk7XG59XG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGggPSBcIlwiLCBpc1NlcmlhbGl6YWJsZSA9IGlzUGxhaW4sIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocyA9IFtdLCBjYWNoZSkge1xuICBsZXQgZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XG4gIGlmICghaXNTZXJpYWxpemFibGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleVBhdGg6IHBhdGggfHwgXCI8cm9vdD5cIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjYWNoZT8uaGFzKHZhbHVlKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGVudHJpZXMgPSBnZXRFbnRyaWVzICE9IG51bGwgPyBnZXRFbnRyaWVzKHZhbHVlKSA6IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcbiAgY29uc3QgaGFzSWdub3JlZFBhdGhzID0gaWdub3JlZFBhdGhzLmxlbmd0aCA+IDA7XG4gIGZvciAoY29uc3QgW2tleSwgbmVzdGVkVmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XG4gICAgICBjb25zdCBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoKGlnbm9yZWQpID0+IHtcbiAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1NlcmlhbGl6YWJsZShuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleVBhdGg6IG5lc3RlZFBhdGgsXG4gICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm91bmROZXN0ZWRTZXJpYWxpemFibGUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUobmVzdGVkVmFsdWUsIG5lc3RlZFBhdGgsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMsIGNhY2hlKTtcbiAgICAgIGlmIChmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSkge1xuICAgICAgICByZXR1cm4gZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjYWNoZSAmJiBpc05lc3RlZEZyb3plbih2YWx1ZSkpXG4gICAgY2FjaGUuYWRkKHZhbHVlKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNOZXN0ZWRGcm96ZW4odmFsdWUpIHtcbiAgaWYgKCFPYmplY3QuaXNGcm96ZW4odmFsdWUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBuZXN0ZWRWYWx1ZSBvZiBPYmplY3QudmFsdWVzKHZhbHVlKSkge1xuICAgIGlmICh0eXBlb2YgbmVzdGVkVmFsdWUgIT09IFwib2JqZWN0XCIgfHwgbmVzdGVkVmFsdWUgPT09IG51bGwpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoIWlzTmVzdGVkRnJvemVuKG5lc3RlZFZhbHVlKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4gbmV4dChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbixcbiAgICAgIGdldEVudHJpZXMsXG4gICAgICBpZ25vcmVkQWN0aW9ucyA9IFtdLFxuICAgICAgaWdub3JlZEFjdGlvblBhdGhzID0gW1wibWV0YS5hcmdcIiwgXCJtZXRhLmJhc2VRdWVyeU1ldGFcIl0sXG4gICAgICBpZ25vcmVkUGF0aHMgPSBbXSxcbiAgICAgIHdhcm5BZnRlciA9IDMyLFxuICAgICAgaWdub3JlU3RhdGUgPSBmYWxzZSxcbiAgICAgIGlnbm9yZUFjdGlvbnMgPSBmYWxzZSxcbiAgICAgIGRpc2FibGVDYWNoZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY2FjaGUgPSAhZGlzYWJsZUNhY2hlICYmIFdlYWtTZXQgPyAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gKHN0b3JlQVBJKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgICAgaWYgKCFpc0FjdGlvbjIoYWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xuICAgICAgY29uc3QgbWVhc3VyZVV0aWxzID0gZ2V0VGltZU1lYXN1cmVVdGlscyh3YXJuQWZ0ZXIsIFwiU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlXCIpO1xuICAgICAgaWYgKCFpZ25vcmVBY3Rpb25zICYmICEoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocywgY2FjaGUpO1xuICAgICAgICAgIGlmIChmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gYW4gYWN0aW9uLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsIFwiXFxuVGFrZSBhIGxvb2sgYXQgdGhlIGxvZ2ljIHRoYXQgZGlzcGF0Y2hlZCB0aGlzIGFjdGlvbjogXCIsIGFjdGlvbiwgXCJcXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9hY3Rpb25zI3doeS1zaG91bGQtdHlwZS1iZS1hLXN0cmluZy1vci1hdC1sZWFzdC1zZXJpYWxpemFibGUtd2h5LXNob3VsZC1teS1hY3Rpb24tdHlwZXMtYmUtY29uc3RhbnRzKVwiLCBcIlxcbihUbyBhbGxvdyBub24tc2VyaWFsaXphYmxlIHZhbHVlcyBzZWU6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvdXNhZ2UvdXNhZ2UtZ3VpZGUjd29ya2luZy13aXRoLW5vbi1zZXJpYWxpemFibGUtZGF0YSlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghaWdub3JlU3RhdGUpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlQVBJLmdldFN0YXRlKCk7XG4gICAgICAgICAgY29uc3QgZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHN0YXRlLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XG4gICAgICAgICAgaWYgKGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSA9IGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gdGhlIHN0YXRlLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsIGBcblRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoaXMgYWN0aW9uIHR5cGU6ICR7YWN0aW9uLnR5cGV9LlxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvb3JnYW5pemluZy1zdGF0ZSNjYW4taS1wdXQtZnVuY3Rpb25zLXByb21pc2VzLW9yLW90aGVyLW5vbi1zZXJpYWxpemFibGUtaXRlbXMtaW4tbXktc3RvcmUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBpc0Jvb2xlYW4oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwiYm9vbGVhblwiO1xufVxudmFyIGJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUgPSAoKSA9PiBmdW5jdGlvbiBnZXREZWZhdWx0TWlkZGxld2FyZShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB0aHVuayA9IHRydWUsXG4gICAgaW1tdXRhYmxlQ2hlY2sgPSB0cnVlLFxuICAgIHNlcmlhbGl6YWJsZUNoZWNrID0gdHJ1ZSxcbiAgICBhY3Rpb25DcmVhdG9yQ2hlY2sgPSB0cnVlXG4gIH0gPSBvcHRpb25zID8/IHt9O1xuICBsZXQgbWlkZGxld2FyZUFycmF5ID0gbmV3IFR1cGxlKCk7XG4gIGlmICh0aHVuaykge1xuICAgIGlmIChpc0Jvb2xlYW4odGh1bmspKSB7XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh0aHVua01pZGRsZXdhcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh3aXRoRXh0cmFBcmd1bWVudCh0aHVuay5leHRyYUFyZ3VtZW50KSk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoaW1tdXRhYmxlQ2hlY2spIHtcbiAgICAgIGxldCBpbW11dGFibGVPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihpbW11dGFibGVDaGVjaykpIHtcbiAgICAgICAgaW1tdXRhYmxlT3B0aW9ucyA9IGltbXV0YWJsZUNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKGltbXV0YWJsZU9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6YWJsZUNoZWNrKSB7XG4gICAgICBsZXQgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oc2VyaWFsaXphYmxlQ2hlY2spKSB7XG4gICAgICAgIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSBzZXJpYWxpemFibGVDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShzZXJpYWxpemFibGVPcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChhY3Rpb25DcmVhdG9yQ2hlY2spIHtcbiAgICAgIGxldCBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oYWN0aW9uQ3JlYXRvckNoZWNrKSkge1xuICAgICAgICBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IGFjdGlvbkNyZWF0b3JDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKGFjdGlvbkNyZWF0b3JPcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaWRkbGV3YXJlQXJyYXk7XG59O1xuXG4vLyBzcmMvYXV0b0JhdGNoRW5oYW5jZXIudHNcbnZhciBTSE9VTERfQVVUT0JBVENIID0gXCJSVEtfYXV0b0JhdGNoXCI7XG52YXIgcHJlcGFyZUF1dG9CYXRjaGVkID0gKCkgPT4gKHBheWxvYWQpID0+ICh7XG4gIHBheWxvYWQsXG4gIG1ldGE6IHtcbiAgICBbU0hPVUxEX0FVVE9CQVRDSF06IHRydWVcbiAgfVxufSk7XG52YXIgY3JlYXRlUXVldWVXaXRoVGltZXIgPSAodGltZW91dCkgPT4ge1xuICByZXR1cm4gKG5vdGlmeSkgPT4ge1xuICAgIHNldFRpbWVvdXQobm90aWZ5LCB0aW1lb3V0KTtcbiAgfTtcbn07XG52YXIgckFGID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKDEwKTtcbnZhciBhdXRvQmF0Y2hFbmhhbmNlciA9IChvcHRpb25zID0ge1xuICB0eXBlOiBcInJhZlwiXG59KSA9PiAobmV4dCkgPT4gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3Qgc3RvcmUgPSBuZXh0KC4uLmFyZ3MpO1xuICBsZXQgbm90aWZ5aW5nID0gdHJ1ZTtcbiAgbGV0IHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gZmFsc2U7XG4gIGxldCBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcbiAgY29uc3QgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgcXVldWVDYWxsYmFjayA9IG9wdGlvbnMudHlwZSA9PT0gXCJ0aWNrXCIgPyBxdWV1ZU1pY3JvdGFzayA6IG9wdGlvbnMudHlwZSA9PT0gXCJyYWZcIiA/IHJBRiA6IG9wdGlvbnMudHlwZSA9PT0gXCJjYWxsYmFja1wiID8gb3B0aW9ucy5xdWV1ZU5vdGlmaWNhdGlvbiA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKG9wdGlvbnMudGltZW91dCk7XG4gIGNvbnN0IG5vdGlmeUxpc3RlbmVycyA9ICgpID0+IHtcbiAgICBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcbiAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcbiAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gZmFsc2U7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobCkgPT4gbCgpKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdG9yZSwge1xuICAgIC8vIE92ZXJyaWRlIHRoZSBiYXNlIGBzdG9yZS5zdWJzY3JpYmVgIG1ldGhvZCB0byBrZWVwIG9yaWdpbmFsIGxpc3RlbmVyc1xuICAgIC8vIGZyb20gcnVubmluZyBpZiB3ZSdyZSBkZWxheWluZyBub3RpZmljYXRpb25zXG4gICAgc3Vic2NyaWJlKGxpc3RlbmVyMikge1xuICAgICAgY29uc3Qgd3JhcHBlZExpc3RlbmVyID0gKCkgPT4gbm90aWZ5aW5nICYmIGxpc3RlbmVyMigpO1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdG9yZS5zdWJzY3JpYmUod3JhcHBlZExpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIyKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIyKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBPdmVycmlkZSB0aGUgYmFzZSBgc3RvcmUuZGlzcGF0Y2hgIG1ldGhvZCBzbyB0aGF0IHdlIGNhbiBjaGVjayBhY3Rpb25zXG4gICAgLy8gZm9yIHRoZSBgc2hvdWxkQXV0b0JhdGNoYCBmbGFnIGFuZCBkZXRlcm1pbmUgaWYgYmF0Y2hpbmcgaXMgYWN0aXZlXG4gICAgZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBub3RpZnlpbmcgPSAhYWN0aW9uPy5tZXRhPy5bU0hPVUxEX0FVVE9CQVRDSF07XG4gICAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gIW5vdGlmeWluZztcbiAgICAgICAgaWYgKHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrKSB7XG4gICAgICAgICAgaWYgKCFub3RpZmljYXRpb25RdWV1ZWQpIHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IHRydWU7XG4gICAgICAgICAgICBxdWV1ZUNhbGxiYWNrKG5vdGlmeUxpc3RlbmVycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbm90aWZ5aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLy8gc3JjL2dldERlZmF1bHRFbmhhbmNlcnMudHNcbnZhciBidWlsZEdldERlZmF1bHRFbmhhbmNlcnMgPSAobWlkZGxld2FyZUVuaGFuY2VyKSA9PiBmdW5jdGlvbiBnZXREZWZhdWx0RW5oYW5jZXJzKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGF1dG9CYXRjaCA9IHRydWVcbiAgfSA9IG9wdGlvbnMgPz8ge307XG4gIGxldCBlbmhhbmNlckFycmF5ID0gbmV3IFR1cGxlKG1pZGRsZXdhcmVFbmhhbmNlcik7XG4gIGlmIChhdXRvQmF0Y2gpIHtcbiAgICBlbmhhbmNlckFycmF5LnB1c2goYXV0b0JhdGNoRW5oYW5jZXIodHlwZW9mIGF1dG9CYXRjaCA9PT0gXCJvYmplY3RcIiA/IGF1dG9CYXRjaCA6IHZvaWQgMCkpO1xuICB9XG4gIHJldHVybiBlbmhhbmNlckFycmF5O1xufTtcblxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXG52YXIgSVNfUFJPRFVDVElPTiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcbmZ1bmN0aW9uIGNvbmZpZ3VyZVN0b3JlKG9wdGlvbnMpIHtcbiAgY29uc3QgZ2V0RGVmYXVsdE1pZGRsZXdhcmUgPSBidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlKCk7XG4gIGNvbnN0IHtcbiAgICByZWR1Y2VyID0gdm9pZCAwLFxuICAgIG1pZGRsZXdhcmUsXG4gICAgZGV2VG9vbHMgPSB0cnVlLFxuICAgIHByZWxvYWRlZFN0YXRlID0gdm9pZCAwLFxuICAgIGVuaGFuY2VycyA9IHZvaWQgMFxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IHJvb3RSZWR1Y2VyO1xuICBpZiAodHlwZW9mIHJlZHVjZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJvb3RSZWR1Y2VyID0gcmVkdWNlcjtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0MihyZWR1Y2VyKSkge1xuICAgIHJvb3RSZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHJlZHVjZXIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEpIDogXCJgcmVkdWNlcmAgaXMgYSByZXF1aXJlZCBhcmd1bWVudCwgYW5kIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgb2YgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBjb21iaW5lUmVkdWNlcnNcIik7XG4gIH1cbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIG1pZGRsZXdhcmUgJiYgdHlwZW9mIG1pZGRsZXdhcmUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIpIDogXCJgbWlkZGxld2FyZWAgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrXCIpO1xuICB9XG4gIGxldCBmaW5hbE1pZGRsZXdhcmU7XG4gIGlmICh0eXBlb2YgbWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZmluYWxNaWRkbGV3YXJlID0gbWlkZGxld2FyZShnZXREZWZhdWx0TWlkZGxld2FyZSk7XG4gICAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KGZpbmFsTWlkZGxld2FyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMpIDogXCJ3aGVuIHVzaW5nIGEgbWlkZGxld2FyZSBidWlsZGVyIGZ1bmN0aW9uLCBhbiBhcnJheSBvZiBtaWRkbGV3YXJlIG11c3QgYmUgcmV0dXJuZWRcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZpbmFsTWlkZGxld2FyZSA9IGdldERlZmF1bHRNaWRkbGV3YXJlKCk7XG4gIH1cbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIGZpbmFsTWlkZGxld2FyZS5zb21lKChpdGVtKSA9PiB0eXBlb2YgaXRlbSAhPT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQpIDogXCJlYWNoIG1pZGRsZXdhcmUgcHJvdmlkZWQgdG8gY29uZmlndXJlU3RvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIGxldCBmaW5hbENvbXBvc2UgPSBjb21wb3NlMjtcbiAgaWYgKGRldlRvb2xzKSB7XG4gICAgZmluYWxDb21wb3NlID0gY29tcG9zZVdpdGhEZXZUb29scyh7XG4gICAgICAvLyBFbmFibGUgY2FwdHVyZSBvZiBzdGFjayB0cmFjZXMgZm9yIGRpc3BhdGNoZWQgUmVkdXggYWN0aW9uc1xuICAgICAgdHJhY2U6ICFJU19QUk9EVUNUSU9OLFxuICAgICAgLi4udHlwZW9mIGRldlRvb2xzID09PSBcIm9iamVjdFwiICYmIGRldlRvb2xzXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWlkZGxld2FyZUVuaGFuY2VyID0gYXBwbHlNaWRkbGV3YXJlKC4uLmZpbmFsTWlkZGxld2FyZSk7XG4gIGNvbnN0IGdldERlZmF1bHRFbmhhbmNlcnMgPSBidWlsZEdldERlZmF1bHRFbmhhbmNlcnMobWlkZGxld2FyZUVuaGFuY2VyKTtcbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIGVuaGFuY2VycyAmJiB0eXBlb2YgZW5oYW5jZXJzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1KSA6IFwiYGVuaGFuY2Vyc2AgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrXCIpO1xuICB9XG4gIGxldCBzdG9yZUVuaGFuY2VycyA9IHR5cGVvZiBlbmhhbmNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGVuaGFuY2VycyhnZXREZWZhdWx0RW5oYW5jZXJzKSA6IGdldERlZmF1bHRFbmhhbmNlcnMoKTtcbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KHN0b3JlRW5oYW5jZXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDYpIDogXCJgZW5oYW5jZXJzYCBjYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheVwiKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgc3RvcmVFbmhhbmNlcnMuc29tZSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg3KSA6IFwiZWFjaCBlbmhhbmNlciBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIGZpbmFsTWlkZGxld2FyZS5sZW5ndGggJiYgIXN0b3JlRW5oYW5jZXJzLmluY2x1ZGVzKG1pZGRsZXdhcmVFbmhhbmNlcikpIHtcbiAgICBjb25zb2xlLmVycm9yKFwibWlkZGxld2FyZXMgd2VyZSBwcm92aWRlZCwgYnV0IG1pZGRsZXdhcmUgZW5oYW5jZXIgd2FzIG5vdCBpbmNsdWRlZCBpbiBmaW5hbCBlbmhhbmNlcnMgLSBtYWtlIHN1cmUgdG8gY2FsbCBgZ2V0RGVmYXVsdEVuaGFuY2Vyc2BcIik7XG4gIH1cbiAgY29uc3QgY29tcG9zZWRFbmhhbmNlciA9IGZpbmFsQ29tcG9zZSguLi5zdG9yZUVuaGFuY2Vycyk7XG4gIHJldHVybiBjcmVhdGVTdG9yZShyb290UmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGNvbXBvc2VkRW5oYW5jZXIpO1xufVxuXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUyLCBpc0RyYWZ0IGFzIGlzRHJhZnQyLCBpc0RyYWZ0YWJsZSBhcyBpc0RyYWZ0YWJsZTIgfSBmcm9tIFwiaW1tZXJcIjtcblxuLy8gc3JjL21hcEJ1aWxkZXJzLnRzXG5mdW5jdGlvbiBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhidWlsZGVyQ2FsbGJhY2spIHtcbiAgY29uc3QgYWN0aW9uc01hcCA9IHt9O1xuICBjb25zdCBhY3Rpb25NYXRjaGVycyA9IFtdO1xuICBsZXQgZGVmYXVsdENhc2VSZWR1Y2VyO1xuICBjb25zdCBidWlsZGVyID0ge1xuICAgIGFkZENhc2UodHlwZU9yQWN0aW9uQ3JlYXRvciwgcmVkdWNlcikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoYWN0aW9uTWF0Y2hlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI2KSA6IFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZE1hdGNoZXJgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNykgOiBcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjgpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggYW4gZW1wdHkgYWN0aW9uIHR5cGVcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSBpbiBhY3Rpb25zTWFwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI5KSA6IGBcXGBidWlsZGVyLmFkZENhc2VcXGAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIHR3byByZWR1Y2VycyBmb3IgdGhlIHNhbWUgYWN0aW9uIHR5cGUgJyR7dHlwZX0nYCk7XG4gICAgICB9XG4gICAgICBhY3Rpb25zTWFwW3R5cGVdID0gcmVkdWNlcjtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sXG4gICAgYWRkTWF0Y2hlcihtYXRjaGVyLCByZWR1Y2VyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMCkgOiBcImBidWlsZGVyLmFkZE1hdGNoZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdGlvbk1hdGNoZXJzLnB1c2goe1xuICAgICAgICBtYXRjaGVyLFxuICAgICAgICByZWR1Y2VyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sXG4gICAgYWRkRGVmYXVsdENhc2UocmVkdWNlcikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzEpIDogXCJgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHJlZHVjZXI7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG4gIH07XG4gIGJ1aWxkZXJDYWxsYmFjayhidWlsZGVyKTtcbiAgcmV0dXJuIFthY3Rpb25zTWFwLCBhY3Rpb25NYXRjaGVycywgZGVmYXVsdENhc2VSZWR1Y2VyXTtcbn1cblxuLy8gc3JjL2NyZWF0ZVJlZHVjZXIudHNcbmZ1bmN0aW9uIGlzU3RhdGVGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUsIG1hcE9yQnVpbGRlckNhbGxiYWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVJlZHVjZXJgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVSZWR1Y2VyXCIpO1xuICAgIH1cbiAgfVxuICBsZXQgW2FjdGlvbnNNYXAsIGZpbmFsQWN0aW9uTWF0Y2hlcnMsIGZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXSA9IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG1hcE9yQnVpbGRlckNhbGxiYWNrKTtcbiAgbGV0IGdldEluaXRpYWxTdGF0ZTtcbiAgaWYgKGlzU3RhdGVGdW5jdGlvbihpbml0aWFsU3RhdGUpKSB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmcm96ZW5Jbml0aWFsU3RhdGUgPSBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKTtcbiAgICBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBmcm96ZW5Jbml0aWFsU3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSA9IGdldEluaXRpYWxTdGF0ZSgpLCBhY3Rpb24pIHtcbiAgICBsZXQgY2FzZVJlZHVjZXJzID0gW2FjdGlvbnNNYXBbYWN0aW9uLnR5cGVdLCAuLi5maW5hbEFjdGlvbk1hdGNoZXJzLmZpbHRlcigoe1xuICAgICAgbWF0Y2hlclxuICAgIH0pID0+IG1hdGNoZXIoYWN0aW9uKSkubWFwKCh7XG4gICAgICByZWR1Y2VyOiByZWR1Y2VyMlxuICAgIH0pID0+IHJlZHVjZXIyKV07XG4gICAgaWYgKGNhc2VSZWR1Y2Vycy5maWx0ZXIoKGNyKSA9PiAhIWNyKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhc2VSZWR1Y2VycyA9IFtmaW5hbERlZmF1bHRDYXNlUmVkdWNlcl07XG4gICAgfVxuICAgIHJldHVybiBjYXNlUmVkdWNlcnMucmVkdWNlKChwcmV2aW91c1N0YXRlLCBjYXNlUmVkdWNlcikgPT4ge1xuICAgICAgaWYgKGNhc2VSZWR1Y2VyKSB7XG4gICAgICAgIGlmIChpc0RyYWZ0MihwcmV2aW91c1N0YXRlKSkge1xuICAgICAgICAgIGNvbnN0IGRyYWZ0ID0gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0RyYWZ0YWJsZTIocHJldmlvdXNTdGF0ZSkpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihwcmV2aW91c1N0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg5KSA6IFwiQSBjYXNlIHJlZHVjZXIgb24gYSBub24tZHJhZnRhYmxlIHZhbHVlIG11c3Qgbm90IHJldHVybiB1bmRlZmluZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTIocHJldmlvdXNTdGF0ZSwgKGRyYWZ0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgIH0sIHN0YXRlKTtcbiAgfVxuICByZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZTtcbiAgcmV0dXJuIHJlZHVjZXI7XG59XG5cbi8vIHNyYy9uYW5vaWQudHNcbnZhciB1cmxBbHBoYWJldCA9IFwiTW9kdWxlU3ltYmhhc093blByLTAxMjM0NTY3ODlBQkNERUZHSE5SVmZnY3RpVXZ6X0txWVRKa0x4cFpYSWpRV1wiO1xudmFyIG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gXCJcIjtcbiAgbGV0IGkgPSBzaXplO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XG4gIH1cbiAgcmV0dXJuIGlkO1xufTtcblxuLy8gc3JjL21hdGNoZXJzLnRzXG52YXIgbWF0Y2hlcyA9IChtYXRjaGVyLCBhY3Rpb24pID0+IHtcbiAgaWYgKGhhc01hdGNoRnVuY3Rpb24obWF0Y2hlcikpIHtcbiAgICByZXR1cm4gbWF0Y2hlci5tYXRjaChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYXRjaGVyKGFjdGlvbik7XG4gIH1cbn07XG5mdW5jdGlvbiBpc0FueU9mKC4uLm1hdGNoZXJzKSB7XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoKG1hdGNoZXIpID0+IG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKSk7XG4gIH07XG59XG5mdW5jdGlvbiBpc0FsbE9mKC4uLm1hdGNoZXJzKSB7XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIG1hdGNoZXJzLmV2ZXJ5KChtYXRjaGVyKSA9PiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbikpO1xuICB9O1xufVxuZnVuY3Rpb24gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCB2YWxpZFN0YXR1cykge1xuICBpZiAoIWFjdGlvbiB8fCAhYWN0aW9uLm1ldGEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBoYXNWYWxpZFJlcXVlc3RJZCA9IHR5cGVvZiBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQgPT09IFwic3RyaW5nXCI7XG4gIGNvbnN0IGhhc1ZhbGlkUmVxdWVzdFN0YXR1cyA9IHZhbGlkU3RhdHVzLmluZGV4T2YoYWN0aW9uLm1ldGEucmVxdWVzdFN0YXR1cykgPiAtMTtcbiAgcmV0dXJuIGhhc1ZhbGlkUmVxdWVzdElkICYmIGhhc1ZhbGlkUmVxdWVzdFN0YXR1cztcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FycmF5KGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBhWzBdID09PSBcImZ1bmN0aW9uXCIgJiYgXCJwZW5kaW5nXCIgaW4gYVswXSAmJiBcImZ1bGZpbGxlZFwiIGluIGFbMF0gJiYgXCJyZWplY3RlZFwiIGluIGFbMF07XG59XG5mdW5jdGlvbiBpc1BlbmRpbmcoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUGVuZGluZygpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgIGNvbnN0IG1hdGNoZXJzID0gYXN5bmNUaHVua3MubWFwKChhc3luY1RodW5rKSA9PiBhc3luY1RodW5rLnBlbmRpbmcpO1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUmVqZWN0ZWQoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInJlamVjdGVkXCJdKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc1JlamVjdGVkKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsucmVqZWN0ZWQpO1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUmVqZWN0ZWRXaXRoVmFsdWUoLi4uYXN5bmNUaHVua3MpIHtcbiAgY29uc3QgaGFzRmxhZyA9IChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gYWN0aW9uICYmIGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlO1xuICB9O1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xuICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICAgIH07XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNSZWplY3RlZFdpdGhWYWx1ZSgpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzRnVsZmlsbGVkKC4uLmFzeW5jVGh1bmtzKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJmdWxmaWxsZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzRnVsZmlsbGVkKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsuZnVsZmlsbGVkKTtcbiAgICBjb25zdCBjb21iaW5lZE1hdGNoZXIgPSBpc0FueU9mKC4uLm1hdGNoZXJzKTtcbiAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XG4gIH07XG59XG5mdW5jdGlvbiBpc0FzeW5jVGh1bmtBY3Rpb24oLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIiwgXCJmdWxmaWxsZWRcIiwgXCJyZWplY3RlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNBc3luY1RodW5rQWN0aW9uKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGFzeW5jVGh1bmsgb2YgYXN5bmNUaHVua3MpIHtcbiAgICAgIG1hdGNoZXJzLnB1c2goYXN5bmNUaHVuay5wZW5kaW5nLCBhc3luY1RodW5rLnJlamVjdGVkLCBhc3luY1RodW5rLmZ1bGZpbGxlZCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cblxuLy8gc3JjL2NyZWF0ZUFzeW5jVGh1bmsudHNcbnZhciBjb21tb25Qcm9wZXJ0aWVzID0gW1wibmFtZVwiLCBcIm1lc3NhZ2VcIiwgXCJzdGFja1wiLCBcImNvZGVcIl07XG52YXIgUmVqZWN0V2l0aFZhbHVlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIC8qXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcbiAgKi9cbiAgX3R5cGU7XG59O1xudmFyIEZ1bGZpbGxXaXRoTWV0YSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocGF5bG9hZCwgbWV0YSkge1xuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgfVxuICAvKlxuICB0eXBlLW9ubHkgcHJvcGVydHkgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBSZWplY3RXaXRoVmFsdWUgYW5kIEZ1bGZpbGxXaXRoTWV0YVxuICBkb2VzIG5vdCBleGlzdCBhdCBydW50aW1lXG4gICovXG4gIF90eXBlO1xufTtcbnZhciBtaW5pU2VyaWFsaXplRXJyb3IgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNpbXBsZUVycm9yID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBjb21tb25Qcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlW3Byb3BlcnR5XSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzaW1wbGVFcnJvcltwcm9wZXJ0eV0gPSB2YWx1ZVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaW1wbGVFcnJvcjtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6IFN0cmluZyh2YWx1ZSlcbiAgfTtcbn07XG52YXIgY3JlYXRlQXN5bmNUaHVuayA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICBmdW5jdGlvbiBjcmVhdGVBc3luY1RodW5rMih0eXBlUHJlZml4LCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZ1bGZpbGxlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvZnVsZmlsbGVkXCIsIChwYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgbWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcImZ1bGZpbGxlZFwiXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3BlbmRpbmdcIiwgKHJlcXVlc3RJZCwgYXJnLCBtZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZDogdm9pZCAwLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5tZXRhIHx8IHt9LFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogXCJwZW5kaW5nXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcmVqZWN0ZWQgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3JlamVjdGVkXCIsIChlcnJvciwgcmVxdWVzdElkLCBhcmcsIHBheWxvYWQsIG1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkLFxuICAgICAgZXJyb3I6IChvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplRXJyb3IgfHwgbWluaVNlcmlhbGl6ZUVycm9yKShlcnJvciB8fCBcIlJlamVjdGVkXCIpLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5tZXRhIHx8IHt9LFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVqZWN0ZWRXaXRoVmFsdWU6ICEhcGF5bG9hZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogXCJyZWplY3RlZFwiLFxuICAgICAgICBhYm9ydGVkOiBlcnJvcj8ubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIsXG4gICAgICAgIGNvbmRpdGlvbjogZXJyb3I/Lm5hbWUgPT09IFwiQ29uZGl0aW9uRXJyb3JcIlxuICAgICAgfVxuICAgIH0pKTtcbiAgICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKGFyZykge1xuICAgICAgcmV0dXJuIChkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IG9wdGlvbnM/LmlkR2VuZXJhdG9yID8gb3B0aW9ucy5pZEdlbmVyYXRvcihhcmcpIDogbmFub2lkKCk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgbGV0IGFib3J0UmVhc29uO1xuICAgICAgICBmdW5jdGlvbiBhYm9ydChyZWFzb24pIHtcbiAgICAgICAgICBhYm9ydFJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGV0IGZpbmFsQWN0aW9uO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uUmVzdWx0ID0gb3B0aW9ucz8uY29uZGl0aW9uPy4oYXJnLCB7XG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaXNUaGVuYWJsZShjb25kaXRpb25SZXN1bHQpKSB7XG4gICAgICAgICAgICAgIGNvbmRpdGlvblJlc3VsdCA9IGF3YWl0IGNvbmRpdGlvblJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25kaXRpb25SZXN1bHQgPT09IGZhbHNlIHx8IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJDb25kaXRpb25FcnJvclwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQWJvcnRlZCBkdWUgdG8gY29uZGl0aW9uIGNhbGxiYWNrIHJldHVybmluZyBmYWxzZS5cIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWJvcnRlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiByZWplY3Qoe1xuICAgICAgICAgICAgICBuYW1lOiBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgICAgICAgbWVzc2FnZTogYWJvcnRSZWFzb24gfHwgXCJBYm9ydGVkXCJcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICBkaXNwYXRjaChwZW5kaW5nKHJlcXVlc3RJZCwgYXJnLCBvcHRpb25zPy5nZXRQZW5kaW5nTWV0YT8uKHtcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBhcmdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgZmluYWxBY3Rpb24gPSBhd2FpdCBQcm9taXNlLnJhY2UoW2Fib3J0ZWRQcm9taXNlLCBQcm9taXNlLnJlc29sdmUocGF5bG9hZENyZWF0b3IoYXJnLCB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoLFxuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICAgICAgcmVqZWN0V2l0aFZhbHVlOiAodmFsdWUsIG1ldGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlamVjdFdpdGhWYWx1ZSh2YWx1ZSwgbWV0YSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bGZpbGxXaXRoVmFsdWU6ICh2YWx1ZSwgbWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnVsZmlsbFdpdGhNZXRhKHZhbHVlLCBtZXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGdWxmaWxsV2l0aE1ldGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdC5wYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgcmVzdWx0Lm1ldGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LCByZXF1ZXN0SWQsIGFyZyk7XG4gICAgICAgICAgICB9KV0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZmluYWxBY3Rpb24gPSBlcnIgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUgPyByZWplY3RlZChudWxsLCByZXF1ZXN0SWQsIGFyZywgZXJyLnBheWxvYWQsIGVyci5tZXRhKSA6IHJlamVjdGVkKGVyciwgcmVxdWVzdElkLCBhcmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBza2lwRGlzcGF0Y2ggPSBvcHRpb25zICYmICFvcHRpb25zLmRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uICYmIHJlamVjdGVkLm1hdGNoKGZpbmFsQWN0aW9uKSAmJiBmaW5hbEFjdGlvbi5tZXRhLmNvbmRpdGlvbjtcbiAgICAgICAgICBpZiAoIXNraXBEaXNwYXRjaCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goZmluYWxBY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmluYWxBY3Rpb247XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvbWlzZSwge1xuICAgICAgICAgIGFib3J0LFxuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgdW53cmFwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbih1bndyYXBSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY3Rpb25DcmVhdG9yLCB7XG4gICAgICBwZW5kaW5nLFxuICAgICAgcmVqZWN0ZWQsXG4gICAgICBmdWxmaWxsZWQsXG4gICAgICBzZXR0bGVkOiBpc0FueU9mKHJlamVjdGVkLCBmdWxmaWxsZWQpLFxuICAgICAgdHlwZVByZWZpeFxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUFzeW5jVGh1bmsyLndpdGhUeXBlcyA9ICgpID0+IGNyZWF0ZUFzeW5jVGh1bmsyO1xuICByZXR1cm4gY3JlYXRlQXN5bmNUaHVuazI7XG59KSgpO1xuZnVuY3Rpb24gdW53cmFwUmVzdWx0KGFjdGlvbikge1xuICBpZiAoYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWUpIHtcbiAgICB0aHJvdyBhY3Rpb24ucGF5bG9hZDtcbiAgfVxuICBpZiAoYWN0aW9uLmVycm9yKSB7XG4gICAgdGhyb3cgYWN0aW9uLmVycm9yO1xuICB9XG4gIHJldHVybiBhY3Rpb24ucGF5bG9hZDtcbn1cbmZ1bmN0aW9uIGlzVGhlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vLyBzcmMvY3JlYXRlU2xpY2UudHNcbnZhciBhc3luY1RodW5rU3ltYm9sID0gU3ltYm9sLmZvcihcInJ0ay1zbGljZS1jcmVhdGVhc3luY3RodW5rXCIpO1xudmFyIGFzeW5jVGh1bmtDcmVhdG9yID0ge1xuICBbYXN5bmNUaHVua1N5bWJvbF06IGNyZWF0ZUFzeW5jVGh1bmtcbn07XG52YXIgUmVkdWNlclR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChSZWR1Y2VyVHlwZTIpID0+IHtcbiAgUmVkdWNlclR5cGUyW1wicmVkdWNlclwiXSA9IFwicmVkdWNlclwiO1xuICBSZWR1Y2VyVHlwZTJbXCJyZWR1Y2VyV2l0aFByZXBhcmVcIl0gPSBcInJlZHVjZXJXaXRoUHJlcGFyZVwiO1xuICBSZWR1Y2VyVHlwZTJbXCJhc3luY1RodW5rXCJdID0gXCJhc3luY1RodW5rXCI7XG4gIHJldHVybiBSZWR1Y2VyVHlwZTI7XG59KShSZWR1Y2VyVHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBnZXRUeXBlKHNsaWNlLCBhY3Rpb25LZXkpIHtcbiAgcmV0dXJuIGAke3NsaWNlfS8ke2FjdGlvbktleX1gO1xufVxuZnVuY3Rpb24gYnVpbGRDcmVhdGVTbGljZSh7XG4gIGNyZWF0b3JzXG59ID0ge30pIHtcbiAgY29uc3QgY0FUID0gY3JlYXRvcnM/LmFzeW5jVGh1bms/Llthc3luY1RodW5rU3ltYm9sXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVNsaWNlMihvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHJlZHVjZXJQYXRoID0gbmFtZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTEpIDogXCJgbmFtZWAgaXMgYSByZXF1aXJlZCBvcHRpb24gZm9yIGNyZWF0ZVNsaWNlXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgaWYgKG9wdGlvbnMuaW5pdGlhbFN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSBtdXN0IHByb3ZpZGUgYW4gYGluaXRpYWxTdGF0ZWAgdmFsdWUgdGhhdCBpcyBub3QgYHVuZGVmaW5lZGAuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGBpbml0aWFsU3RhdGVgXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZWR1Y2VycyA9ICh0eXBlb2Ygb3B0aW9ucy5yZWR1Y2VycyA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5yZWR1Y2VycyhidWlsZFJlZHVjZXJDcmVhdG9ycygpKSA6IG9wdGlvbnMucmVkdWNlcnMpIHx8IHt9O1xuICAgIGNvbnN0IHJlZHVjZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWU6IHt9LFxuICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGU6IHt9LFxuICAgICAgYWN0aW9uQ3JlYXRvcnM6IHt9LFxuICAgICAgc2xpY2VNYXRjaGVyczogW11cbiAgICB9O1xuICAgIGNvbnN0IGNvbnRleHRNZXRob2RzID0ge1xuICAgICAgYWRkQ2FzZSh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IFwiYGNvbnRleHQuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlIGluIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMykgOiBcImBjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGVbdHlwZV0gPSByZWR1Y2VyO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgYWRkTWF0Y2hlcihtYXRjaGVyLCByZWR1Y2VyKSB7XG4gICAgICAgIGNvbnRleHQuc2xpY2VNYXRjaGVycy5wdXNoKHtcbiAgICAgICAgICBtYXRjaGVyLFxuICAgICAgICAgIHJlZHVjZXJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG4gICAgICBleHBvc2VBY3Rpb24obmFtZTIsIGFjdGlvbkNyZWF0b3IpIHtcbiAgICAgICAgY29udGV4dC5hY3Rpb25DcmVhdG9yc1tuYW1lMl0gPSBhY3Rpb25DcmVhdG9yO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgZXhwb3NlQ2FzZVJlZHVjZXIobmFtZTIsIHJlZHVjZXIpIHtcbiAgICAgICAgY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZVtuYW1lMl0gPSByZWR1Y2VyO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWR1Y2VyTmFtZXMuZm9yRWFjaCgocmVkdWNlck5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHJlZHVjZXJEZWZpbml0aW9uID0gcmVkdWNlcnNbcmVkdWNlck5hbWVdO1xuICAgICAgY29uc3QgcmVkdWNlckRldGFpbHMgPSB7XG4gICAgICAgIHJlZHVjZXJOYW1lLFxuICAgICAgICB0eXBlOiBnZXRUeXBlKG5hbWUsIHJlZHVjZXJOYW1lKSxcbiAgICAgICAgY3JlYXRlTm90YXRpb246IHR5cGVvZiBvcHRpb25zLnJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCJcbiAgICAgIH07XG4gICAgICBpZiAoaXNBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGVmaW5pdGlvbikpIHtcbiAgICAgICAgaGFuZGxlVGh1bmtDYXNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRldGFpbHMsIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0TWV0aG9kcywgY0FUKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZXRhaWxzLCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dE1ldGhvZHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGJ1aWxkUmVkdWNlcigpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNCkgOiBcIlRoZSBvYmplY3Qgbm90YXRpb24gZm9yIGBjcmVhdGVTbGljZS5leHRyYVJlZHVjZXJzYCBoYXMgYmVlbiByZW1vdmVkLiBQbGVhc2UgdXNlIHRoZSAnYnVpbGRlciBjYWxsYmFjaycgbm90YXRpb24gaW5zdGVhZDogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvY3JlYXRlU2xpY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IFtleHRyYVJlZHVjZXJzID0ge30sIGFjdGlvbk1hdGNoZXJzID0gW10sIGRlZmF1bHRDYXNlUmVkdWNlciA9IHZvaWQgMF0gPSB0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhvcHRpb25zLmV4dHJhUmVkdWNlcnMpIDogW29wdGlvbnMuZXh0cmFSZWR1Y2Vyc107XG4gICAgICBjb25zdCBmaW5hbENhc2VSZWR1Y2VycyA9IHtcbiAgICAgICAgLi4uZXh0cmFSZWR1Y2VycyxcbiAgICAgICAgLi4uY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjcmVhdGVSZWR1Y2VyKG9wdGlvbnMuaW5pdGlhbFN0YXRlLCAoYnVpbGRlcikgPT4ge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gZmluYWxDYXNlUmVkdWNlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZENhc2Uoa2V5LCBmaW5hbENhc2VSZWR1Y2Vyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzTSBvZiBjb250ZXh0LnNsaWNlTWF0Y2hlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZE1hdGNoZXIoc00ubWF0Y2hlciwgc00ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbSBvZiBhY3Rpb25NYXRjaGVycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTWF0Y2hlcihtLm1hdGNoZXIsIG0ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkRGVmYXVsdENhc2UoZGVmYXVsdENhc2VSZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdFNlbGYgPSAoc3RhdGUpID0+IHN0YXRlO1xuICAgIGNvbnN0IGluamVjdGVkU2VsZWN0b3JDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIGxldCBfcmVkdWNlcjtcbiAgICBjb25zdCBzbGljZSA9IHtcbiAgICAgIG5hbWUsXG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgICAgICBpZiAoIV9yZWR1Y2VyKVxuICAgICAgICAgIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XG4gICAgICAgIHJldHVybiBfcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgICAgIH0sXG4gICAgICBhY3Rpb25zOiBjb250ZXh0LmFjdGlvbkNyZWF0b3JzLFxuICAgICAgY2FzZVJlZHVjZXJzOiBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lLFxuICAgICAgZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICBpZiAoIV9yZWR1Y2VyKVxuICAgICAgICAgIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XG4gICAgICAgIHJldHVybiBfcmVkdWNlci5nZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgIH0sXG4gICAgICBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGUgPSBzZWxlY3RTZWxmKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yQ2FjaGUgPSBlbXBsYWNlKGluamVjdGVkU2VsZWN0b3JDYWNoZSwgdGhpcywge1xuICAgICAgICAgIGluc2VydDogKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbXBsYWNlKHNlbGVjdG9yQ2FjaGUsIHNlbGVjdFN0YXRlLCB7XG4gICAgICAgICAgaW5zZXJ0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUyLCBzZWxlY3Rvcl0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5zZWxlY3RvcnMgPz8ge30pKSB7XG4gICAgICAgICAgICAgIG1hcFtuYW1lMl0gPSB3cmFwU2VsZWN0b3IodGhpcywgc2VsZWN0b3IsIHNlbGVjdFN0YXRlLCB0aGlzICE9PSBzbGljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2VsZWN0U2xpY2Uoc3RhdGUpIHtcbiAgICAgICAgbGV0IHNsaWNlU3RhdGUgPSBzdGF0ZVt0aGlzLnJlZHVjZXJQYXRoXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzbGljZVN0YXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaWYgKHRoaXMgIT09IHNsaWNlKSB7XG4gICAgICAgICAgICBzbGljZVN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTUpIDogXCJzZWxlY3RTbGljZSByZXR1cm5lZCB1bmRlZmluZWQgZm9yIGFuIHVuaW5qZWN0ZWQgc2xpY2UgcmVkdWNlclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNsaWNlU3RhdGU7XG4gICAgICB9LFxuICAgICAgZ2V0IHNlbGVjdG9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0b3JzKHRoaXMuc2VsZWN0U2xpY2UpO1xuICAgICAgfSxcbiAgICAgIGluamVjdEludG8oaW5qZWN0YWJsZSwge1xuICAgICAgICByZWR1Y2VyUGF0aDogcGF0aE9wdCxcbiAgICAgICAgLi4uY29uZmlnXG4gICAgICB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcmVkdWNlclBhdGgyID0gcGF0aE9wdCA/PyB0aGlzLnJlZHVjZXJQYXRoO1xuICAgICAgICBpbmplY3RhYmxlLmluamVjdCh7XG4gICAgICAgICAgcmVkdWNlclBhdGg6IHJlZHVjZXJQYXRoMixcbiAgICAgICAgICByZWR1Y2VyOiB0aGlzLnJlZHVjZXJcbiAgICAgICAgfSwgY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi50aGlzLFxuICAgICAgICAgIHJlZHVjZXJQYXRoOiByZWR1Y2VyUGF0aDJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzbGljZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHdyYXBTZWxlY3RvcihzbGljZSwgc2VsZWN0b3IsIHNlbGVjdFN0YXRlLCBpbmplY3RlZCkge1xuICBmdW5jdGlvbiB3cmFwcGVyKHJvb3RTdGF0ZSwgLi4uYXJncykge1xuICAgIGxldCBzbGljZVN0YXRlID0gc2VsZWN0U3RhdGUuY2FsbChzbGljZSwgcm9vdFN0YXRlKTtcbiAgICBpZiAodHlwZW9mIHNsaWNlU3RhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgICBzbGljZVN0YXRlID0gc2xpY2UuZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNikgOiBcInNlbGVjdFN0YXRlIHJldHVybmVkIHVuZGVmaW5lZCBmb3IgYW4gdW5pbmplY3RlZCBzbGljZSByZWR1Y2VyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3Ioc2xpY2VTdGF0ZSwgLi4uYXJncyk7XG4gIH1cbiAgd3JhcHBlci51bndyYXBwZWQgPSBzZWxlY3RvcjtcbiAgcmV0dXJuIHdyYXBwZXI7XG59XG52YXIgY3JlYXRlU2xpY2UgPSBidWlsZENyZWF0ZVNsaWNlKCk7XG5mdW5jdGlvbiBidWlsZFJlZHVjZXJDcmVhdG9ycygpIHtcbiAgZnVuY3Rpb24gYXN5bmNUaHVuayhwYXlsb2FkQ3JlYXRvciwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9yZWR1Y2VyRGVmaW5pdGlvblR5cGU6IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi8sXG4gICAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gIH1cbiAgYXN5bmNUaHVuay53aXRoVHlwZXMgPSAoKSA9PiBhc3luY1RodW5rO1xuICByZXR1cm4ge1xuICAgIHJlZHVjZXIoY2FzZVJlZHVjZXIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgLy8gaGFjayBzbyB0aGUgd3JhcHBpbmcgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY3JlYXRlIGEgd3JhcHBlciBzbyB0aGUgYHJlZHVjZXJEZWZpbml0aW9uVHlwZWAgaXMgbm90IGFzc2lnbmVkIHRvIHRoZSBvcmlnaW5hbFxuICAgICAgICBbY2FzZVJlZHVjZXIubmFtZV0oLi4uYXJncykge1xuICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlciguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVtjYXNlUmVkdWNlci5uYW1lXSwge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJcIiAvKiByZWR1Y2VyICovXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHByZXBhcmVkUmVkdWNlcihwcmVwYXJlLCByZWR1Y2VyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLyxcbiAgICAgICAgcHJlcGFyZSxcbiAgICAgICAgcmVkdWNlclxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jVGh1bmtcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWUsXG4gIGNyZWF0ZU5vdGF0aW9uXG59LCBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSwgY29udGV4dCkge1xuICBsZXQgY2FzZVJlZHVjZXI7XG4gIGxldCBwcmVwYXJlQ2FsbGJhY2s7XG4gIGlmIChcInJlZHVjZXJcIiBpbiBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkge1xuICAgIGlmIChjcmVhdGVOb3RhdGlvbiAmJiAhaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbihtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE3KSA6IFwiUGxlYXNlIHVzZSB0aGUgYGNyZWF0ZS5wcmVwYXJlZFJlZHVjZXJgIG5vdGF0aW9uIGZvciBwcmVwYXJlZCBhY3Rpb24gY3JlYXRvcnMgd2l0aCB0aGUgYGNyZWF0ZWAgbm90YXRpb24uXCIpO1xuICAgIH1cbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnJlZHVjZXI7XG4gICAgcHJlcGFyZUNhbGxiYWNrID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucHJlcGFyZTtcbiAgfSBlbHNlIHtcbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlO1xuICB9XG4gIGNvbnRleHQuYWRkQ2FzZSh0eXBlLCBjYXNlUmVkdWNlcikuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIGNhc2VSZWR1Y2VyKS5leHBvc2VBY3Rpb24ocmVkdWNlck5hbWUsIHByZXBhcmVDYWxsYmFjayA/IGNyZWF0ZUFjdGlvbih0eXBlLCBwcmVwYXJlQ2FsbGJhY2spIDogY3JlYXRlQWN0aW9uKHR5cGUpKTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHJlZHVjZXJEZWZpbml0aW9uLl9yZWR1Y2VyRGVmaW5pdGlvblR5cGUgPT09IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi87XG59XG5mdW5jdGlvbiBpc0Nhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSB7XG4gIHJldHVybiByZWR1Y2VyRGVmaW5pdGlvbi5fcmVkdWNlckRlZmluaXRpb25UeXBlID09PSBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLztcbn1cbmZ1bmN0aW9uIGhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWVcbn0sIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0LCBjQVQpIHtcbiAgaWYgKCFjQVQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxOCkgOiBcIkNhbm5vdCB1c2UgYGNyZWF0ZS5hc3luY1RodW5rYCBpbiB0aGUgYnVpbHQtaW4gYGNyZWF0ZVNsaWNlYC4gVXNlIGBidWlsZENyZWF0ZVNsaWNlKHsgY3JlYXRvcnM6IHsgYXN5bmNUaHVuazogYXN5bmNUaHVua0NyZWF0b3IgfSB9KWAgdG8gY3JlYXRlIGEgY3VzdG9taXNlZCB2ZXJzaW9uIG9mIGBjcmVhdGVTbGljZWAuXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICBmdWxmaWxsZWQsXG4gICAgcGVuZGluZyxcbiAgICByZWplY3RlZCxcbiAgICBzZXR0bGVkLFxuICAgIG9wdGlvbnNcbiAgfSA9IHJlZHVjZXJEZWZpbml0aW9uO1xuICBjb25zdCB0aHVuayA9IGNBVCh0eXBlLCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucyk7XG4gIGNvbnRleHQuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCB0aHVuayk7XG4gIGlmIChmdWxmaWxsZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsuZnVsZmlsbGVkLCBmdWxmaWxsZWQpO1xuICB9XG4gIGlmIChwZW5kaW5nKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLnBlbmRpbmcsIHBlbmRpbmcpO1xuICB9XG4gIGlmIChyZWplY3RlZCkge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5yZWplY3RlZCwgcmVqZWN0ZWQpO1xuICB9XG4gIGlmIChzZXR0bGVkKSB7XG4gICAgY29udGV4dC5hZGRNYXRjaGVyKHRodW5rLnNldHRsZWQsIHNldHRsZWQpO1xuICB9XG4gIGNvbnRleHQuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCB8fCBub29wLFxuICAgIHBlbmRpbmc6IHBlbmRpbmcgfHwgbm9vcCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQgfHwgbm9vcCxcbiAgICBzZXR0bGVkOiBzZXR0bGVkIHx8IG5vb3BcbiAgfSk7XG59XG5mdW5jdGlvbiBub29wKCkge1xufVxuXG4vLyBzcmMvZW50aXRpZXMvZW50aXR5X3N0YXRlLnRzXG5mdW5jdGlvbiBnZXRJbml0aWFsRW50aXR5U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgaWRzOiBbXSxcbiAgICBlbnRpdGllczoge31cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3RvcnkoKSB7XG4gIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZShhZGRpdGlvbmFsU3RhdGUgPSB7fSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGdldEluaXRpYWxFbnRpdHlTdGF0ZSgpLCBhZGRpdGlvbmFsU3RhdGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9zdGF0ZV9zZWxlY3RvcnMudHNcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKSB7XG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgY3JlYXRlU2VsZWN0b3I6IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2VsZWN0SWRzID0gKHN0YXRlKSA9PiBzdGF0ZS5pZHM7XG4gICAgY29uc3Qgc2VsZWN0RW50aXRpZXMgPSAoc3RhdGUpID0+IHN0YXRlLmVudGl0aWVzO1xuICAgIGNvbnN0IHNlbGVjdEFsbCA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RJZHMsIHNlbGVjdEVudGl0aWVzLCAoaWRzLCBlbnRpdGllcykgPT4gaWRzLm1hcCgoaWQpID0+IGVudGl0aWVzW2lkXSkpO1xuICAgIGNvbnN0IHNlbGVjdElkID0gKF8sIGlkKSA9PiBpZDtcbiAgICBjb25zdCBzZWxlY3RCeUlkID0gKGVudGl0aWVzLCBpZCkgPT4gZW50aXRpZXNbaWRdO1xuICAgIGNvbnN0IHNlbGVjdFRvdGFsID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdElkcywgKGlkcykgPT4gaWRzLmxlbmd0aCk7XG4gICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0SWRzLFxuICAgICAgICBzZWxlY3RFbnRpdGllcyxcbiAgICAgICAgc2VsZWN0QWxsLFxuICAgICAgICBzZWxlY3RUb3RhbCxcbiAgICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0RW50aXRpZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RJZHM6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0SWRzKSxcbiAgICAgIHNlbGVjdEVudGl0aWVzOiBzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsXG4gICAgICBzZWxlY3RBbGw6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0QWxsKSxcbiAgICAgIHNlbGVjdFRvdGFsOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0U3RhdGUsIHNlbGVjdFRvdGFsKSxcbiAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRTZWxlY3RvcnNcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX2FkYXB0ZXIudHNcbmltcG9ydCB7IHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlMywgaXNEcmFmdCBhcyBpc0RyYWZ0MyB9IGZyb20gXCJpbW1lclwiO1xudmFyIGlzRHJhZnRUeXBlZCA9IGlzRHJhZnQzO1xuZnVuY3Rpb24gY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yKG11dGF0b3IpIHtcbiAgY29uc3Qgb3BlcmF0b3IgPSBjcmVhdGVTdGF0ZU9wZXJhdG9yKChfLCBzdGF0ZSkgPT4gbXV0YXRvcihzdGF0ZSkpO1xuICByZXR1cm4gZnVuY3Rpb24gb3BlcmF0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIG9wZXJhdG9yKHN0YXRlLCB2b2lkIDApO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGVPcGVyYXRvcihtdXRhdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUsIGFyZykge1xuICAgIGZ1bmN0aW9uIGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZzIpIHtcbiAgICAgIHJldHVybiBpc0ZTQShhcmcyKTtcbiAgICB9XG4gICAgY29uc3QgcnVuTXV0YXRvciA9IChkcmFmdCkgPT4ge1xuICAgICAgaWYgKGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZykpIHtcbiAgICAgICAgbXV0YXRvcihhcmcucGF5bG9hZCwgZHJhZnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXV0YXRvcihhcmcsIGRyYWZ0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0RyYWZ0VHlwZWQoc3RhdGUpKSB7XG4gICAgICBydW5NdXRhdG9yKHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTMoc3RhdGUsIHJ1bk11dGF0b3IpO1xuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvdXRpbHMudHNcbmZ1bmN0aW9uIHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCkge1xuICBjb25zdCBrZXkgPSBzZWxlY3RJZChlbnRpdHkpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGtleSA9PT0gdm9pZCAwKSB7XG4gICAgY29uc29sZS53YXJuKFwiVGhlIGVudGl0eSBwYXNzZWQgdG8gdGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgdW5kZWZpbmVkLlwiLCBcIllvdSBzaG91bGQgcHJvYmFibHkgcHJvdmlkZSB5b3VyIG93biBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uLlwiLCBcIlRoZSBlbnRpdHkgdGhhdCB3YXMgcGFzc2VkOlwiLCBlbnRpdHksIFwiVGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb246XCIsIHNlbGVjdElkLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiBlbnN1cmVFbnRpdGllc0FycmF5KGVudGl0aWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShlbnRpdGllcykpIHtcbiAgICBlbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoZW50aXRpZXMpO1xuICB9XG4gIHJldHVybiBlbnRpdGllcztcbn1cbmZ1bmN0aW9uIHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSkge1xuICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICBjb25zdCBhZGRlZCA9IFtdO1xuICBjb25zdCB1cGRhdGVkID0gW107XG4gIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgY29uc3QgaWQgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmIChpZCBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgdXBkYXRlZC5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGNoYW5nZXM6IGVudGl0eVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZGVkLnB1c2goZW50aXR5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthZGRlZCwgdXBkYXRlZF07XG59XG5cbi8vIHNyYy9lbnRpdGllcy91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCkge1xuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICBjb25zdCBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmIChrZXkgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcbiAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xuICB9XG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgbmV3RW50aXRpZXMpIHtcbiAgICAgIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKCEoa2V5IGluIHN0YXRlLmVudGl0aWVzKSkge1xuICAgICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgc3RhdGUuZW50aXRpZXNba2V5XSA9IGVudGl0eTtcbiAgfVxuICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgICBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgc3RhdGUuaWRzID0gW107XG4gICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcbiAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU9uZU11dGFibHkoa2V5LCBzdGF0ZSkge1xuICAgIHJldHVybiByZW1vdmVNYW55TXV0YWJseShba2V5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU1hbnlNdXRhYmx5KGtleXMsIHN0YXRlKSB7XG4gICAgbGV0IGRpZE11dGF0ZSA9IGZhbHNlO1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1trZXldO1xuICAgICAgICBkaWRNdXRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkaWRNdXRhdGUpIHtcbiAgICAgIHN0YXRlLmlkcyA9IHN0YXRlLmlkcy5maWx0ZXIoKGlkKSA9PiBpZCBpbiBzdGF0ZS5lbnRpdGllcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUFsbE11dGFibHkoc3RhdGUpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLCB7XG4gICAgICBpZHM6IFtdLFxuICAgICAgZW50aXRpZXM6IHt9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdGFrZU5ld0tleShrZXlzLCB1cGRhdGUsIHN0YXRlKSB7XG4gICAgY29uc3Qgb3JpZ2luYWwzID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICBpZiAob3JpZ2luYWwzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsMywgdXBkYXRlLmNoYW5nZXMpO1xuICAgIGNvbnN0IG5ld0tleSA9IHNlbGVjdElkVmFsdWUodXBkYXRlZCwgc2VsZWN0SWQpO1xuICAgIGNvbnN0IGhhc05ld0tleSA9IG5ld0tleSAhPT0gdXBkYXRlLmlkO1xuICAgIGlmIChoYXNOZXdLZXkpIHtcbiAgICAgIGtleXNbdXBkYXRlLmlkXSA9IG5ld0tleTtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgIH1cbiAgICBzdGF0ZS5lbnRpdGllc1tuZXdLZXldID0gdXBkYXRlZDtcbiAgICByZXR1cm4gaGFzTmV3S2V5O1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlLCBzdGF0ZSkge1xuICAgIHJldHVybiB1cGRhdGVNYW55TXV0YWJseShbdXBkYXRlXSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXMsIHN0YXRlKSB7XG4gICAgY29uc3QgbmV3S2V5cyA9IHt9O1xuICAgIGNvbnN0IHVwZGF0ZXNQZXJFbnRpdHkgPSB7fTtcbiAgICB1cGRhdGVzLmZvckVhY2goKHVwZGF0ZSkgPT4ge1xuICAgICAgaWYgKHVwZGF0ZS5pZCBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgICB1cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0gPSB7XG4gICAgICAgICAgaWQ6IHVwZGF0ZS5pZCxcbiAgICAgICAgICAvLyBTcHJlYWRzIGlnbm9yZSBmYWxzeSB2YWx1ZXMsIHNvIHRoaXMgd29ya3MgZXZlbiBpZiB0aGVyZSBpc24ndFxuICAgICAgICAgIC8vIGFuIGV4aXN0aW5nIHVwZGF0ZSBhbHJlYWR5IGF0IHRoaXMga2V5XG4gICAgICAgICAgY2hhbmdlczoge1xuICAgICAgICAgICAgLi4udXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID8gdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdLmNoYW5nZXMgOiBudWxsLFxuICAgICAgICAgICAgLi4udXBkYXRlLmNoYW5nZXNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXBkYXRlcyA9IE9iamVjdC52YWx1ZXModXBkYXRlc1BlckVudGl0eSk7XG4gICAgY29uc3QgZGlkTXV0YXRlRW50aXRpZXMgPSB1cGRhdGVzLmxlbmd0aCA+IDA7XG4gICAgaWYgKGRpZE11dGF0ZUVudGl0aWVzKSB7XG4gICAgICBjb25zdCBkaWRNdXRhdGVJZHMgPSB1cGRhdGVzLmZpbHRlcigodXBkYXRlKSA9PiB0YWtlTmV3S2V5KG5ld0tleXMsIHVwZGF0ZSwgc3RhdGUpKS5sZW5ndGggPiAwO1xuICAgICAgaWYgKGRpZE11dGF0ZUlkcykge1xuICAgICAgICBzdGF0ZS5pZHMgPSBPYmplY3QudmFsdWVzKHN0YXRlLmVudGl0aWVzKS5tYXAoKGUpID0+IHNlbGVjdElkVmFsdWUoZSwgc2VsZWN0SWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwc2VydE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgY29uc3QgW2FkZGVkLCB1cGRhdGVkXSA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSk7XG4gICAgdXBkYXRlTWFueU11dGFibHkodXBkYXRlZCwgc3RhdGUpO1xuICAgIGFkZE1hbnlNdXRhYmx5KGFkZGVkLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZW1vdmVBbGw6IGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihyZW1vdmVBbGxNdXRhYmx5KSxcbiAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXG4gICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXG4gICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxuICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxuICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcbiAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXG4gICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXG4gICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxuICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpLFxuICAgIHJlbW92ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVPbmVNdXRhYmx5KSxcbiAgICByZW1vdmVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU1hbnlNdXRhYmx5KVxuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydCkge1xuICBjb25zdCB7XG4gICAgcmVtb3ZlT25lLFxuICAgIHJlbW92ZU1hbnksXG4gICAgcmVtb3ZlQWxsXG4gIH0gPSBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCk7XG4gIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiBhZGRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgY29uc3QgbW9kZWxzID0gbmV3RW50aXRpZXMuZmlsdGVyKChtb2RlbCkgPT4gIShzZWxlY3RJZFZhbHVlKG1vZGVsLCBzZWxlY3RJZCkgaW4gc3RhdGUuZW50aXRpZXMpKTtcbiAgICBpZiAobW9kZWxzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgbWVyZ2UobW9kZWxzLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiBzZXRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgaWYgKG5ld0VudGl0aWVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgbWVyZ2UobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIHN0YXRlLmVudGl0aWVzID0ge307XG4gICAgc3RhdGUuaWRzID0gW107XG4gICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xuICAgIGxldCBhcHBsaWVkVXBkYXRlcyA9IGZhbHNlO1xuICAgIGZvciAobGV0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBhcHBsaWVkVXBkYXRlcyA9IHRydWU7XG4gICAgICBPYmplY3QuYXNzaWduKGVudGl0eSwgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgY29uc3QgbmV3SWQgPSBzZWxlY3RJZChlbnRpdHkpO1xuICAgICAgaWYgKHVwZGF0ZS5pZCAhPT0gbmV3SWQpIHtcbiAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgICAgIHN0YXRlLmVudGl0aWVzW25ld0lkXSA9IGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XG4gICAgICByZXNvcnRFbnRpdGllcyhzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IFthZGRlZCwgdXBkYXRlZF0gPSBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpO1xuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGggJiYgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldID09PSBiW2ldKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBtZXJnZShtb2RlbHMsIHN0YXRlKSB7XG4gICAgbW9kZWxzLmZvckVhY2goKG1vZGVsKSA9PiB7XG4gICAgICBzdGF0ZS5lbnRpdGllc1tzZWxlY3RJZChtb2RlbCldID0gbW9kZWw7XG4gICAgfSk7XG4gICAgcmVzb3J0RW50aXRpZXMoc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29ydEVudGl0aWVzKHN0YXRlKSB7XG4gICAgY29uc3QgYWxsRW50aXRpZXMgPSBPYmplY3QudmFsdWVzKHN0YXRlLmVudGl0aWVzKTtcbiAgICBhbGxFbnRpdGllcy5zb3J0KHNvcnQpO1xuICAgIGNvbnN0IG5ld1NvcnRlZElkcyA9IGFsbEVudGl0aWVzLm1hcChzZWxlY3RJZCk7XG4gICAgY29uc3Qge1xuICAgICAgaWRzXG4gICAgfSA9IHN0YXRlO1xuICAgIGlmICghYXJlQXJyYXlzRXF1YWwoaWRzLCBuZXdTb3J0ZWRJZHMpKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBuZXdTb3J0ZWRJZHM7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlT25lLFxuICAgIHJlbW92ZU1hbnksXG4gICAgcmVtb3ZlQWxsLFxuICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcbiAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXG4gICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXG4gICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXG4gICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXG4gICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSlcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL2NyZWF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVFbnRpdHlBZGFwdGVyKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgc2VsZWN0SWQsXG4gICAgc29ydENvbXBhcmVyXG4gIH0gPSB7XG4gICAgc29ydENvbXBhcmVyOiBmYWxzZSxcbiAgICBzZWxlY3RJZDogKGluc3RhbmNlKSA9PiBpbnN0YW5jZS5pZCxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IHN0YXRlRmFjdG9yeSA9IGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3RvcnkoKTtcbiAgY29uc3Qgc2VsZWN0b3JzRmFjdG9yeSA9IGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKTtcbiAgY29uc3Qgc3RhdGVBZGFwdGVyID0gc29ydENvbXBhcmVyID8gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0Q29tcGFyZXIpIDogY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xuICByZXR1cm4ge1xuICAgIHNlbGVjdElkLFxuICAgIHNvcnRDb21wYXJlcixcbiAgICAuLi5zdGF0ZUZhY3RvcnksXG4gICAgLi4uc2VsZWN0b3JzRmFjdG9yeSxcbiAgICAuLi5zdGF0ZUFkYXB0ZXJcbiAgfTtcbn1cblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9pbmRleC50c1xuaW1wb3J0IHsgaXNBY3Rpb24gYXMgaXNBY3Rpb24zIH0gZnJvbSBcInJlZHV4XCI7XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdXRpbHMudHNcbnZhciBhc3NlcnRGdW5jdGlvbiA9IChmdW5jLCBleHBlY3RlZCkgPT4ge1xuICBpZiAodHlwZW9mIGZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMyKSA6IGAke2V4cGVjdGVkfSBpcyBub3QgYSBmdW5jdGlvbmApO1xuICB9XG59O1xudmFyIG5vb3AyID0gKCkgPT4ge1xufTtcbnZhciBjYXRjaFJlamVjdGlvbiA9IChwcm9taXNlLCBvbkVycm9yID0gbm9vcDIpID0+IHtcbiAgcHJvbWlzZS5jYXRjaChvbkVycm9yKTtcbiAgcmV0dXJuIHByb21pc2U7XG59O1xudmFyIGFkZEFib3J0U2lnbmFsTGlzdGVuZXIgPSAoYWJvcnRTaWduYWwsIGNhbGxiYWNrKSA9PiB7XG4gIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjaywge1xuICAgIG9uY2U6IHRydWVcbiAgfSk7XG4gIHJldHVybiAoKSA9PiBhYm9ydFNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgY2FsbGJhY2spO1xufTtcbnZhciBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uID0gKGFib3J0Q29udHJvbGxlciwgcmVhc29uKSA9PiB7XG4gIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIShcInJlYXNvblwiIGluIHNpZ25hbCkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2lnbmFsLCBcInJlYXNvblwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHJlYXNvbixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgO1xuICBhYm9ydENvbnRyb2xsZXIuYWJvcnQocmVhc29uKTtcbn07XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvZXhjZXB0aW9ucy50c1xudmFyIHRhc2sgPSBcInRhc2tcIjtcbnZhciBsaXN0ZW5lciA9IFwibGlzdGVuZXJcIjtcbnZhciBjb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xudmFyIGNhbmNlbGxlZCA9IFwiY2FuY2VsbGVkXCI7XG52YXIgdGFza0NhbmNlbGxlZCA9IGB0YXNrLSR7Y2FuY2VsbGVkfWA7XG52YXIgdGFza0NvbXBsZXRlZCA9IGB0YXNrLSR7Y29tcGxldGVkfWA7XG52YXIgbGlzdGVuZXJDYW5jZWxsZWQgPSBgJHtsaXN0ZW5lcn0tJHtjYW5jZWxsZWR9YDtcbnZhciBsaXN0ZW5lckNvbXBsZXRlZCA9IGAke2xpc3RlbmVyfS0ke2NvbXBsZXRlZH1gO1xudmFyIFRhc2tBYm9ydEVycm9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBgJHt0YXNrfSAke2NhbmNlbGxlZH0gKHJlYXNvbjogJHtjb2RlfSlgO1xuICB9XG4gIG5hbWUgPSBcIlRhc2tBYm9ydEVycm9yXCI7XG4gIG1lc3NhZ2U7XG59O1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL3Rhc2sudHNcbnZhciB2YWxpZGF0ZUFjdGl2ZSA9IChzaWduYWwpID0+IHtcbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVhc29uXG4gICAgfSA9IHNpZ25hbDtcbiAgICB0aHJvdyBuZXcgVGFza0Fib3J0RXJyb3IocmVhc29uKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgcHJvbWlzZSkge1xuICBsZXQgY2xlYW51cCA9IG5vb3AyO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IG5vdGlmeVJlamVjdGlvbiA9ICgpID0+IHJlamVjdChuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbikpO1xuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgbm90aWZ5UmVqZWN0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFudXAgPSBhZGRBYm9ydFNpZ25hbExpc3RlbmVyKHNpZ25hbCwgbm90aWZ5UmVqZWN0aW9uKTtcbiAgICBwcm9taXNlLmZpbmFsbHkoKCkgPT4gY2xlYW51cCgpKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgIGNsZWFudXAgPSBub29wMjtcbiAgfSk7XG59XG52YXIgcnVuVGFzayA9IGFzeW5jICh0YXNrMiwgY2xlYW5VcCkgPT4ge1xuICB0cnkge1xuICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGFzazIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBcIm9rXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogZXJyb3IgaW5zdGFuY2VvZiBUYXNrQWJvcnRFcnJvciA/IFwiY2FuY2VsbGVkXCIgOiBcInJlamVjdGVkXCIsXG4gICAgICBlcnJvclxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgY2xlYW5VcD8uKCk7XG4gIH1cbn07XG52YXIgY3JlYXRlUGF1c2UgPSAoc2lnbmFsKSA9PiB7XG4gIHJldHVybiAocHJvbWlzZSkgPT4ge1xuICAgIHJldHVybiBjYXRjaFJlamVjdGlvbihyYWNlV2l0aFNpZ25hbChzaWduYWwsIHByb21pc2UpLnRoZW4oKG91dHB1dCkgPT4ge1xuICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSkpO1xuICB9O1xufTtcbnZhciBjcmVhdGVEZWxheSA9IChzaWduYWwpID0+IHtcbiAgY29uc3QgcGF1c2UgPSBjcmVhdGVQYXVzZShzaWduYWwpO1xuICByZXR1cm4gKHRpbWVvdXRNcykgPT4ge1xuICAgIHJldHVybiBwYXVzZShuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0TXMpKSk7XG4gIH07XG59O1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2luZGV4LnRzXG52YXIge1xuICBhc3NpZ25cbn0gPSBPYmplY3Q7XG52YXIgSU5URVJOQUxfTklMX1RPS0VOID0ge307XG52YXIgYWxtID0gXCJsaXN0ZW5lck1pZGRsZXdhcmVcIjtcbnZhciBjcmVhdGVGb3JrID0gKHBhcmVudEFib3J0U2lnbmFsLCBwYXJlbnRCbG9ja2luZ1Byb21pc2VzKSA9PiB7XG4gIGNvbnN0IGxpbmtDb250cm9sbGVycyA9IChjb250cm9sbGVyKSA9PiBhZGRBYm9ydFNpZ25hbExpc3RlbmVyKHBhcmVudEFib3J0U2lnbmFsLCAoKSA9PiBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIHBhcmVudEFib3J0U2lnbmFsLnJlYXNvbikpO1xuICByZXR1cm4gKHRhc2tFeGVjdXRvciwgb3B0cykgPT4ge1xuICAgIGFzc2VydEZ1bmN0aW9uKHRhc2tFeGVjdXRvciwgXCJ0YXNrRXhlY3V0b3JcIik7XG4gICAgY29uc3QgY2hpbGRBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGlua0NvbnRyb2xsZXJzKGNoaWxkQWJvcnRDb250cm9sbGVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBydW5UYXNrKGFzeW5jICgpID0+IHtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHBhcmVudEFib3J0U2lnbmFsKTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgdGFza0V4ZWN1dG9yKHtcbiAgICAgICAgcGF1c2U6IGNyZWF0ZVBhdXNlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgIGRlbGF5OiBjcmVhdGVEZWxheShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICBzaWduYWw6IGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICAgfSk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfSwgKCkgPT4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjaGlsZEFib3J0Q29udHJvbGxlciwgdGFza0NvbXBsZXRlZCkpO1xuICAgIGlmIChvcHRzPy5hdXRvSm9pbikge1xuICAgICAgcGFyZW50QmxvY2tpbmdQcm9taXNlcy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IGNyZWF0ZVBhdXNlKHBhcmVudEFib3J0U2lnbmFsKShyZXN1bHQpLFxuICAgICAgY2FuY2VsKCkge1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ2FuY2VsbGVkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTtcbnZhciBjcmVhdGVUYWtlUGF0dGVybiA9IChzdGFydExpc3RlbmluZywgc2lnbmFsKSA9PiB7XG4gIGNvbnN0IHRha2UgPSBhc3luYyAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiB7XG4gICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICBsZXQgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgfTtcbiAgICBjb25zdCB0dXBsZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgc3RvcExpc3RlbmluZyA9IHN0YXJ0TGlzdGVuaW5nKHtcbiAgICAgICAgcHJlZGljYXRlLFxuICAgICAgICBlZmZlY3Q6IChhY3Rpb24sIGxpc3RlbmVyQXBpKSA9PiB7XG4gICAgICAgICAgbGlzdGVuZXJBcGkudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZXNvbHZlKFthY3Rpb24sIGxpc3RlbmVyQXBpLmdldFN0YXRlKCksIGxpc3RlbmVyQXBpLmdldE9yaWdpbmFsU3RhdGUoKV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICBzdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFt0dXBsZVByb21pc2VdO1xuICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCwgbnVsbCkpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgUHJvbWlzZS5yYWNlKHByb21pc2VzKSk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiBjYXRjaFJlamVjdGlvbih0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkpO1xufTtcbnZhciBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tID0gKG9wdGlvbnMpID0+IHtcbiAgbGV0IHtcbiAgICB0eXBlLFxuICAgIGFjdGlvbkNyZWF0b3IsXG4gICAgbWF0Y2hlcixcbiAgICBwcmVkaWNhdGUsXG4gICAgZWZmZWN0XG4gIH0gPSBvcHRpb25zO1xuICBpZiAodHlwZSkge1xuICAgIHByZWRpY2F0ZSA9IGNyZWF0ZUFjdGlvbih0eXBlKS5tYXRjaDtcbiAgfSBlbHNlIGlmIChhY3Rpb25DcmVhdG9yKSB7XG4gICAgdHlwZSA9IGFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICBwcmVkaWNhdGUgPSBhY3Rpb25DcmVhdG9yLm1hdGNoO1xuICB9IGVsc2UgaWYgKG1hdGNoZXIpIHtcbiAgICBwcmVkaWNhdGUgPSBtYXRjaGVyO1xuICB9IGVsc2UgaWYgKHByZWRpY2F0ZSkge1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIxKSA6IFwiQ3JlYXRpbmcgb3IgcmVtb3ZpbmcgYSBsaXN0ZW5lciByZXF1aXJlcyBvbmUgb2YgdGhlIGtub3duIGZpZWxkcyBmb3IgbWF0Y2hpbmcgYW4gYWN0aW9uXCIpO1xuICB9XG4gIGFzc2VydEZ1bmN0aW9uKGVmZmVjdCwgXCJvcHRpb25zLmxpc3RlbmVyXCIpO1xuICByZXR1cm4ge1xuICAgIHByZWRpY2F0ZSxcbiAgICB0eXBlLFxuICAgIGVmZmVjdFxuICB9O1xufTtcbnZhciBjcmVhdGVMaXN0ZW5lckVudHJ5ID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgcHJlZGljYXRlLFxuICAgIGVmZmVjdFxuICB9ID0gZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbShvcHRpb25zKTtcbiAgY29uc3QgaWQgPSBuYW5vaWQoKTtcbiAgY29uc3QgZW50cnkgPSB7XG4gICAgaWQsXG4gICAgZWZmZWN0LFxuICAgIHR5cGUsXG4gICAgcHJlZGljYXRlLFxuICAgIHBlbmRpbmc6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIyKSA6IFwiVW5zdWJzY3JpYmUgbm90IGluaXRpYWxpemVkXCIpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVudHJ5O1xufTtcbnZhciBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMgPSAoZW50cnkpID0+IHtcbiAgZW50cnkucGVuZGluZy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiB7XG4gICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gIH0pO1xufTtcbnZhciBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSA9IChsaXN0ZW5lck1hcCkgPT4ge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxpc3RlbmVyTWFwLmZvckVhY2goY2FuY2VsQWN0aXZlTGlzdGVuZXJzKTtcbiAgICBsaXN0ZW5lck1hcC5jbGVhcigpO1xuICB9O1xufTtcbnZhciBzYWZlbHlOb3RpZnlFcnJvciA9IChlcnJvckhhbmRsZXIsIGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbykgPT4ge1xuICB0cnkge1xuICAgIGVycm9ySGFuZGxlcihlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pO1xuICB9IGNhdGNoIChlcnJvckhhbmRsZXJFcnJvcikge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyb3JIYW5kbGVyRXJyb3I7XG4gICAgfSwgMCk7XG4gIH1cbn07XG52YXIgYWRkTGlzdGVuZXIgPSBjcmVhdGVBY3Rpb24oYCR7YWxtfS9hZGRgKTtcbnZhciBjbGVhckFsbExpc3RlbmVycyA9IGNyZWF0ZUFjdGlvbihgJHthbG19L3JlbW92ZUFsbGApO1xudmFyIHJlbW92ZUxpc3RlbmVyID0gY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlYCk7XG52YXIgZGVmYXVsdEVycm9ySGFuZGxlciA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoYCR7YWxtfS9lcnJvcmAsIC4uLmFyZ3MpO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZShtaWRkbGV3YXJlT3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGxpc3RlbmVyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3Qge1xuICAgIGV4dHJhLFxuICAgIG9uRXJyb3IgPSBkZWZhdWx0RXJyb3JIYW5kbGVyXG4gIH0gPSBtaWRkbGV3YXJlT3B0aW9ucztcbiAgYXNzZXJ0RnVuY3Rpb24ob25FcnJvciwgXCJvbkVycm9yXCIpO1xuICBjb25zdCBpbnNlcnRFbnRyeSA9IChlbnRyeSkgPT4ge1xuICAgIGVudHJ5LnVuc3Vic2NyaWJlID0gKCkgPT4gbGlzdGVuZXJNYXAuZGVsZXRlKGVudHJ5LmlkKTtcbiAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICByZXR1cm4gKGNhbmNlbE9wdGlvbnMpID0+IHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAoY2FuY2VsT3B0aW9ucz8uY2FuY2VsQWN0aXZlKSB7XG4gICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgY29uc3Qgc3RhcnRMaXN0ZW5pbmcgPSAob3B0aW9ucykgPT4ge1xuICAgIGxldCBlbnRyeSA9IGZpbmQoQXJyYXkuZnJvbShsaXN0ZW5lck1hcC52YWx1ZXMoKSksIChleGlzdGluZ0VudHJ5KSA9PiBleGlzdGluZ0VudHJ5LmVmZmVjdCA9PT0gb3B0aW9ucy5lZmZlY3QpO1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIGVudHJ5ID0gY3JlYXRlTGlzdGVuZXJFbnRyeShvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc2VydEVudHJ5KGVudHJ5KTtcbiAgfTtcbiAgY29uc3Qgc3RvcExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIGVmZmVjdCxcbiAgICAgIHByZWRpY2F0ZVxuICAgIH0gPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpO1xuICAgIGNvbnN0IGVudHJ5ID0gZmluZChBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKSwgKGVudHJ5MikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hQcmVkaWNhdGVPclR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVudHJ5Mi50eXBlID09PSB0eXBlIDogZW50cnkyLnByZWRpY2F0ZSA9PT0gcHJlZGljYXRlO1xuICAgICAgcmV0dXJuIG1hdGNoUHJlZGljYXRlT3JUeXBlICYmIGVudHJ5Mi5lZmZlY3QgPT09IGVmZmVjdDtcbiAgICB9KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAob3B0aW9ucy5jYW5jZWxBY3RpdmUpIHtcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEhZW50cnk7XG4gIH07XG4gIGNvbnN0IG5vdGlmeUxpc3RlbmVyID0gYXN5bmMgKGVudHJ5LCBhY3Rpb24sIGFwaSwgZ2V0T3JpZ2luYWxTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGludGVybmFsVGFza0NvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgdGFrZSA9IGNyZWF0ZVRha2VQYXR0ZXJuKHN0YXJ0TGlzdGVuaW5nLCBpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgY29uc3QgYXV0b0pvaW5Qcm9taXNlcyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBlbnRyeS5wZW5kaW5nLmFkZChpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZShlbnRyeS5lZmZlY3QoXG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgLy8gVXNlIGFzc2lnbigpIHJhdGhlciB0aGFuIC4uLiB0byBhdm9pZCBleHRyYSBoZWxwZXIgZnVuY3Rpb25zIGFkZGVkIHRvIGJ1bmRsZVxuICAgICAgICBhc3NpZ24oe30sIGFwaSwge1xuICAgICAgICAgIGdldE9yaWdpbmFsU3RhdGUsXG4gICAgICAgICAgY29uZGl0aW9uOiAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiB0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkudGhlbihCb29sZWFuKSxcbiAgICAgICAgICB0YWtlLFxuICAgICAgICAgIGRlbGF5OiBjcmVhdGVEZWxheShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgICAgcGF1c2U6IGNyZWF0ZVBhdXNlKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgICBleHRyYSxcbiAgICAgICAgICBzaWduYWw6IGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgIGZvcms6IGNyZWF0ZUZvcmsoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsIGF1dG9Kb2luUHJvbWlzZXMpLFxuICAgICAgICAgIHVuc3Vic2NyaWJlOiBlbnRyeS51bnN1YnNjcmliZSxcbiAgICAgICAgICBzdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzOiAoKSA9PiB7XG4gICAgICAgICAgICBlbnRyeS5wZW5kaW5nLmZvckVhY2goKGNvbnRyb2xsZXIsIF8sIHNldCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoY29udHJvbGxlciAhPT0gaW50ZXJuYWxUYXNrQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICAgICAgICAgICAgICAgIHNldC5kZWxldGUoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGludGVybmFsVGFza0NvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcbiAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZDogKCkgPT4ge1xuICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICkpO1xuICAgIH0gY2F0Y2ggKGxpc3RlbmVyRXJyb3IpIHtcbiAgICAgIGlmICghKGxpc3RlbmVyRXJyb3IgaW5zdGFuY2VvZiBUYXNrQWJvcnRFcnJvcikpIHtcbiAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgbGlzdGVuZXJFcnJvciwge1xuICAgICAgICAgIHJhaXNlZEJ5OiBcImVmZmVjdFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoYXV0b0pvaW5Qcm9taXNlcyk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGludGVybmFsVGFza0NvbnRyb2xsZXIsIGxpc3RlbmVyQ29tcGxldGVkKTtcbiAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZShsaXN0ZW5lck1hcCk7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAoYXBpKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmICghaXNBY3Rpb24zKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgfVxuICAgIGlmIChhZGRMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RhcnRMaXN0ZW5pbmcoYWN0aW9uLnBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAoY2xlYXJBbGxMaXN0ZW5lcnMubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlbW92ZUxpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBzdG9wTGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICB9XG4gICAgbGV0IG9yaWdpbmFsU3RhdGUgPSBhcGkuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBnZXRPcmlnaW5hbFN0YXRlID0gKCkgPT4ge1xuICAgICAgaWYgKG9yaWdpbmFsU3RhdGUgPT09IElOVEVSTkFMX05JTF9UT0tFTikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMykgOiBgJHthbG19OiBnZXRPcmlnaW5hbFN0YXRlIGNhbiBvbmx5IGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxTdGF0ZTtcbiAgICB9O1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcbiAgICAgIGlmIChsaXN0ZW5lck1hcC5zaXplID4gMCkge1xuICAgICAgICBsZXQgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyRW50cmllcyA9IEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpO1xuICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiBsaXN0ZW5lckVudHJpZXMpIHtcbiAgICAgICAgICBsZXQgcnVuTGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcnVuTGlzdGVuZXIgPSBlbnRyeS5wcmVkaWNhdGUoYWN0aW9uLCBjdXJyZW50U3RhdGUsIG9yaWdpbmFsU3RhdGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKHByZWRpY2F0ZUVycm9yKSB7XG4gICAgICAgICAgICBydW5MaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgcHJlZGljYXRlRXJyb3IsIHtcbiAgICAgICAgICAgICAgcmFpc2VkQnk6IFwicHJlZGljYXRlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJ1bkxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm90aWZ5TGlzdGVuZXIoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBvcmlnaW5hbFN0YXRlID0gSU5URVJOQUxfTklMX1RPS0VOO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgc3RhcnRMaXN0ZW5pbmcsXG4gICAgc3RvcExpc3RlbmluZyxcbiAgICBjbGVhckxpc3RlbmVyczogY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmVcbiAgfTtcbn1cblxuLy8gc3JjL2R5bmFtaWNNaWRkbGV3YXJlL2luZGV4LnRzXG5pbXBvcnQgeyBjb21wb3NlIGFzIGNvbXBvc2UzIH0gZnJvbSBcInJlZHV4XCI7XG52YXIgY3JlYXRlTWlkZGxld2FyZUVudHJ5ID0gKG1pZGRsZXdhcmUpID0+ICh7XG4gIGlkOiBuYW5vaWQoKSxcbiAgbWlkZGxld2FyZSxcbiAgYXBwbGllZDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxufSk7XG52YXIgbWF0Y2hJbnN0YW5jZSA9IChpbnN0YW5jZUlkKSA9PiAoYWN0aW9uKSA9PiBhY3Rpb24/Lm1ldGE/Lmluc3RhbmNlSWQgPT09IGluc3RhbmNlSWQ7XG52YXIgY3JlYXRlRHluYW1pY01pZGRsZXdhcmUgPSAoKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlSWQgPSBuYW5vaWQoKTtcbiAgY29uc3QgbWlkZGxld2FyZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHdpdGhNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVBY3Rpb24oXCJkeW5hbWljTWlkZGxld2FyZS9hZGRcIiwgKC4uLm1pZGRsZXdhcmVzKSA9PiAoe1xuICAgIHBheWxvYWQ6IG1pZGRsZXdhcmVzLFxuICAgIG1ldGE6IHtcbiAgICAgIGluc3RhbmNlSWRcbiAgICB9XG4gIH0pKSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gd2l0aE1pZGRsZXdhcmVcbiAgfSk7XG4gIGNvbnN0IGFkZE1pZGRsZXdhcmUgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIGFkZE1pZGRsZXdhcmUyKC4uLm1pZGRsZXdhcmVzKSB7XG4gICAgbWlkZGxld2FyZXMuZm9yRWFjaCgobWlkZGxld2FyZTIpID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IGZpbmQoQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKSwgKGVudHJ5MikgPT4gZW50cnkyLm1pZGRsZXdhcmUgPT09IG1pZGRsZXdhcmUyKTtcbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgZW50cnkgPSBjcmVhdGVNaWRkbGV3YXJlRW50cnkobWlkZGxld2FyZTIpO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZU1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICB9KTtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gYWRkTWlkZGxld2FyZVxuICB9KTtcbiAgY29uc3QgZ2V0RmluYWxNaWRkbGV3YXJlID0gKGFwaSkgPT4ge1xuICAgIGNvbnN0IGFwcGxpZWRNaWRkbGV3YXJlID0gQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKS5tYXAoKGVudHJ5KSA9PiBlbXBsYWNlKGVudHJ5LmFwcGxpZWQsIGFwaSwge1xuICAgICAgaW5zZXJ0OiAoKSA9PiBlbnRyeS5taWRkbGV3YXJlKGFwaSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIGNvbXBvc2UzKC4uLmFwcGxpZWRNaWRkbGV3YXJlKTtcbiAgfTtcbiAgY29uc3QgaXNXaXRoTWlkZGxld2FyZSA9IGlzQWxsT2Yod2l0aE1pZGRsZXdhcmUsIG1hdGNoSW5zdGFuY2UoaW5zdGFuY2VJZCkpO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoaXNXaXRoTWlkZGxld2FyZShhY3Rpb24pKSB7XG4gICAgICBhZGRNaWRkbGV3YXJlKC4uLmFjdGlvbi5wYXlsb2FkKTtcbiAgICAgIHJldHVybiBhcGkuZGlzcGF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBnZXRGaW5hbE1pZGRsZXdhcmUoYXBpKShuZXh0KShhY3Rpb24pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgYWRkTWlkZGxld2FyZSxcbiAgICB3aXRoTWlkZGxld2FyZSxcbiAgICBpbnN0YW5jZUlkXG4gIH07XG59O1xuXG4vLyBzcmMvY29tYmluZVNsaWNlcy50c1xuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIGFzIGNvbWJpbmVSZWR1Y2VyczIgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBpc1NsaWNlTGlrZSA9IChtYXliZVNsaWNlTGlrZSkgPT4gXCJyZWR1Y2VyUGF0aFwiIGluIG1heWJlU2xpY2VMaWtlICYmIHR5cGVvZiBtYXliZVNsaWNlTGlrZS5yZWR1Y2VyUGF0aCA9PT0gXCJzdHJpbmdcIjtcbnZhciBnZXRSZWR1Y2VycyA9IChzbGljZXMpID0+IHNsaWNlcy5mbGF0TWFwKChzbGljZU9yTWFwKSA9PiBpc1NsaWNlTGlrZShzbGljZU9yTWFwKSA/IFtbc2xpY2VPck1hcC5yZWR1Y2VyUGF0aCwgc2xpY2VPck1hcC5yZWR1Y2VyXV0gOiBPYmplY3QuZW50cmllcyhzbGljZU9yTWFwKSk7XG52YXIgT1JJR0lOQUxfU1RBVEUgPSBTeW1ib2wuZm9yKFwicnRrLXN0YXRlLXByb3h5LW9yaWdpbmFsXCIpO1xudmFyIGlzU3RhdGVQcm94eSA9ICh2YWx1ZSkgPT4gISF2YWx1ZSAmJiAhIXZhbHVlW09SSUdJTkFMX1NUQVRFXTtcbnZhciBzdGF0ZVByb3h5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgY3JlYXRlU3RhdGVQcm94eSA9IChzdGF0ZSwgcmVkdWNlck1hcCkgPT4gZW1wbGFjZShzdGF0ZVByb3h5TWFwLCBzdGF0ZSwge1xuICBpbnNlcnQ6ICgpID0+IG5ldyBQcm94eShzdGF0ZSwge1xuICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgIGlmIChwcm9wID09PSBPUklHSU5BTF9TVEFURSlcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IHJlZHVjZXJNYXBbcHJvcC50b1N0cmluZygpXTtcbiAgICAgICAgaWYgKHJlZHVjZXIpIHtcbiAgICAgICAgICBjb25zdCByZWR1Y2VyUmVzdWx0ID0gcmVkdWNlcih2b2lkIDAsIHtcbiAgICAgICAgICAgIHR5cGU6IG5hbm9pZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZWR1Y2VyUmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNCkgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7cHJvcC50b1N0cmluZygpfVwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIGNhbGxlZCBmb3Igc2VsZWN0b3IoKS4gSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlZHVjZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KVxufSk7XG52YXIgb3JpZ2luYWwgPSAoc3RhdGUpID0+IHtcbiAgaWYgKCFpc1N0YXRlUHJveHkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjUpIDogXCJvcmlnaW5hbCBtdXN0IGJlIHVzZWQgb24gc3RhdGUgUHJveHlcIik7XG4gIH1cbiAgcmV0dXJuIHN0YXRlW09SSUdJTkFMX1NUQVRFXTtcbn07XG5mdW5jdGlvbiBjb21iaW5lU2xpY2VzKC4uLnNsaWNlcykge1xuICBjb25zdCByZWR1Y2VyTWFwID0gT2JqZWN0LmZyb21FbnRyaWVzKGdldFJlZHVjZXJzKHNsaWNlcykpO1xuICBjb25zdCBnZXRSZWR1Y2VyID0gKCkgPT4gY29tYmluZVJlZHVjZXJzMihyZWR1Y2VyTWFwKTtcbiAgbGV0IHJlZHVjZXIgPSBnZXRSZWR1Y2VyKCk7XG4gIGZ1bmN0aW9uIGNvbWJpbmVkUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgcmV0dXJuIHJlZHVjZXIoc3RhdGUsIGFjdGlvbik7XG4gIH1cbiAgY29tYmluZWRSZWR1Y2VyLndpdGhMYXp5TG9hZGVkU2xpY2VzID0gKCkgPT4gY29tYmluZWRSZWR1Y2VyO1xuICBjb25zdCBpbmplY3QgPSAoc2xpY2UsIGNvbmZpZyA9IHt9KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcmVkdWNlclBhdGgsXG4gICAgICByZWR1Y2VyOiByZWR1Y2VyVG9JbmplY3RcbiAgICB9ID0gc2xpY2U7XG4gICAgY29uc3QgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyTWFwW3JlZHVjZXJQYXRoXTtcbiAgICBpZiAoIWNvbmZpZy5vdmVycmlkZUV4aXN0aW5nICYmIGN1cnJlbnRSZWR1Y2VyICYmIGN1cnJlbnRSZWR1Y2VyICE9PSByZWR1Y2VyVG9JbmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYGNhbGxlZCBcXGBpbmplY3RcXGAgdG8gb3ZlcnJpZGUgYWxyZWFkeS1leGlzdGluZyByZWR1Y2VyICR7cmVkdWNlclBhdGh9IHdpdGhvdXQgc3BlY2lmeWluZyBcXGBvdmVycmlkZUV4aXN0aW5nOiB0cnVlXFxgYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWRSZWR1Y2VyO1xuICAgIH1cbiAgICByZWR1Y2VyTWFwW3JlZHVjZXJQYXRoXSA9IHJlZHVjZXJUb0luamVjdDtcbiAgICByZWR1Y2VyID0gZ2V0UmVkdWNlcigpO1xuICAgIHJldHVybiBjb21iaW5lZFJlZHVjZXI7XG4gIH07XG4gIGNvbnN0IHNlbGVjdG9yID0gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiBtYWtlU2VsZWN0b3Ioc2VsZWN0b3JGbiwgc2VsZWN0U3RhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VsZWN0b3IyKHN0YXRlLCAuLi5hcmdzKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3JGbihjcmVhdGVTdGF0ZVByb3h5KHNlbGVjdFN0YXRlID8gc2VsZWN0U3RhdGUoc3RhdGUsIC4uLmFyZ3MpIDogc3RhdGUsIHJlZHVjZXJNYXApLCAuLi5hcmdzKTtcbiAgICB9O1xuICB9LCB7XG4gICAgb3JpZ2luYWxcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGNvbWJpbmVkUmVkdWNlciwge1xuICAgIGluamVjdCxcbiAgICBzZWxlY3RvclxuICB9KTtcbn1cblxuLy8gc3JjL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UudHNcbmZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZSkge1xuICByZXR1cm4gYE1pbmlmaWVkIFJlZHV4IFRvb2xraXQgZXJyb3IgIyR7Y29kZX07IHZpc2l0IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvRXJyb3JzP2NvZGU9JHtjb2RlfSBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzLiBgO1xufVxuZXhwb3J0IHtcbiAgUmVkdWNlclR5cGUsXG4gIFNIT1VMRF9BVVRPQkFUQ0gsXG4gIFRhc2tBYm9ydEVycm9yLFxuICBUdXBsZSxcbiAgYWRkTGlzdGVuZXIsXG4gIGFzeW5jVGh1bmtDcmVhdG9yLFxuICBhdXRvQmF0Y2hFbmhhbmNlcixcbiAgYnVpbGRDcmVhdGVTbGljZSxcbiAgY2xlYXJBbGxMaXN0ZW5lcnMsXG4gIGNvbWJpbmVTbGljZXMsXG4gIGNvbmZpZ3VyZVN0b3JlLFxuICBjcmVhdGVBY3Rpb24sXG4gIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVBc3luY1RodW5rLFxuICBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcixcbiAgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yLFxuICBjcmVhdGVEeW5hbWljTWlkZGxld2FyZSxcbiAgY3JlYXRlRW50aXR5QWRhcHRlcixcbiAgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsXG4gIHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlLFxuICBjcmVhdGVSZWR1Y2VyLFxuICBjcmVhdGVTZWxlY3RvcixcbiAgY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiBhcyBjcmVhdGVTZWxlY3RvckNyZWF0b3IsXG4gIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSxcbiAgY3JlYXRlU2xpY2UsXG4gIGN1cnJlbnQyIGFzIGN1cnJlbnQsXG4gIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSxcbiAgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSxcbiAgZnJlZXplLFxuICBpc0FjdGlvbkNyZWF0b3IsXG4gIGlzQWxsT2YsXG4gIGlzQW55T2YsXG4gIGlzQXN5bmNUaHVua0FjdGlvbixcbiAgaXNEcmFmdDQgYXMgaXNEcmFmdCxcbiAgaXNGU0EgYXMgaXNGbHV4U3RhbmRhcmRBY3Rpb24sXG4gIGlzRnVsZmlsbGVkLFxuICBpc0ltbXV0YWJsZURlZmF1bHQsXG4gIGlzUGVuZGluZyxcbiAgaXNQbGFpbixcbiAgaXNSZWplY3RlZCxcbiAgaXNSZWplY3RlZFdpdGhWYWx1ZSxcbiAgbHJ1TWVtb2l6ZSxcbiAgbWluaVNlcmlhbGl6ZUVycm9yLFxuICBuYW5vaWQsXG4gIG9yaWdpbmFsMiBhcyBvcmlnaW5hbCxcbiAgcHJlcGFyZUF1dG9CYXRjaGVkLFxuICByZW1vdmVMaXN0ZW5lcixcbiAgdW53cmFwUmVzdWx0LFxuICB3ZWFrTWFwTWVtb2l6ZTIgYXMgd2Vha01hcE1lbW9pemVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1eC10b29sa2l0Lm1vZGVybi5tanMubWFwIl0sIm5hbWVzIjpbInByb2R1Y2UiLCJjdXJyZW50IiwiY3VycmVudDIiLCJmcmVlemUiLCJvcmlnaW5hbCIsIm9yaWdpbmFsMiIsImlzRHJhZnQiLCJpc0RyYWZ0NCIsImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlU2VsZWN0b3JDcmVhdG9yIiwiY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiIsImxydU1lbW9pemUiLCJ3ZWFrTWFwTWVtb2l6ZSIsIndlYWtNYXBNZW1vaXplMiIsImNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvciIsImFyZ3MiLCJjcmVhdGVTZWxlY3RvcjIiLCJhcmdzMiIsInNlbGVjdG9yIiwid3JhcHBlZFNlbGVjdG9yIiwidmFsdWUiLCJyZXN0IiwiT2JqZWN0IiwiYXNzaWduIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IiLCJhcHBseU1pZGRsZXdhcmUiLCJjcmVhdGVTdG9yZSIsImNvbXBvc2UiLCJjb21wb3NlMiIsImNvbWJpbmVSZWR1Y2VycyIsImlzUGxhaW5PYmplY3QiLCJpc1BsYWluT2JqZWN0MiIsImNvbXBvc2VXaXRoRGV2VG9vbHMiLCJ3aW5kb3ciLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcHBseSIsImRldlRvb2xzRW5oYW5jZXIiLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIiwibm9vcDMiLCJ0aHVuayIsInRodW5rTWlkZGxld2FyZSIsIndpdGhFeHRyYUFyZ3VtZW50IiwiaXNBY3Rpb24iLCJoYXNNYXRjaEZ1bmN0aW9uIiwidiIsIm1hdGNoIiwiY3JlYXRlQWN0aW9uIiwidHlwZSIsInByZXBhcmVBY3Rpb24iLCJhY3Rpb25DcmVhdG9yIiwicHJlcGFyZWQiLCJFcnJvciIsInByb2Nlc3MiLCJmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIiwicGF5bG9hZCIsIm1ldGEiLCJlcnJvciIsInRvU3RyaW5nIiwiYWN0aW9uIiwiaXNBY3Rpb25DcmVhdG9yIiwiaXNGU0EiLCJrZXlzIiwiZXZlcnkiLCJpc1ZhbGlkS2V5Iiwia2V5IiwiaW5kZXhPZiIsImdldE1lc3NhZ2UiLCJzcGxpdFR5cGUiLCJzcGxpdCIsImFjdGlvbk5hbWUiLCJjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZSIsIm9wdGlvbnMiLCJuZXh0IiwiaXNBY3Rpb25DcmVhdG9yMiIsImNvbnNvbGUiLCJ3YXJuIiwiY3JlYXRlTmV4dFN0YXRlIiwiaXNEcmFmdGFibGUiLCJnZXRUaW1lTWVhc3VyZVV0aWxzIiwibWF4RGVsYXkiLCJmbk5hbWUiLCJlbGFwc2VkIiwibWVhc3VyZVRpbWUiLCJmbiIsInN0YXJ0ZWQiLCJEYXRlIiwibm93IiwiZmluaXNoZWQiLCJ3YXJuSWZFeGNlZWRlZCIsImZpbmQiLCJpdGVyYWJsZSIsImNvbXBhcmF0b3IiLCJlbnRyeSIsIlR1cGxlIiwiX1R1cGxlIiwiQXJyYXkiLCJjb25zdHJ1Y3RvciIsIml0ZW1zIiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJTeW1ib2wiLCJzcGVjaWVzIiwiY29uY2F0IiwiYXJyIiwicHJlcGVuZCIsImlzQXJyYXkiLCJmcmVlemVEcmFmdGFibGUiLCJ2YWwiLCJlbXBsYWNlIiwibWFwIiwiaGFuZGxlciIsImhhcyIsImdldCIsInVwZGF0ZSIsInNldCIsImluc2VydCIsImluc2VydGVkIiwiaXNJbW11dGFibGVEZWZhdWx0IiwiaXNGcm96ZW4iLCJ0cmFja0Zvck11dGF0aW9ucyIsImlzSW1tdXRhYmxlIiwiaWdub3JlUGF0aHMiLCJvYmoiLCJ0cmFja2VkUHJvcGVydGllcyIsInRyYWNrUHJvcGVydGllcyIsImRldGVjdE11dGF0aW9ucyIsInBhdGgiLCJjaGVja2VkT2JqZWN0cyIsIlNldCIsInRyYWNrZWQiLCJhZGQiLCJjaGlsZHJlbiIsImNoaWxkUGF0aCIsImlnbm9yZWRQYXRocyIsInRyYWNrZWRQcm9wZXJ0eSIsInNhbWVQYXJlbnRSZWYiLCJwcmV2T2JqIiwic2FtZVJlZiIsIk51bWJlciIsImlzTmFOIiwid2FzTXV0YXRlZCIsImtleXNUb0RldGVjdCIsImhhc0lnbm9yZWRQYXRocyIsIm5lc3RlZFBhdGgiLCJoYXNNYXRjaGVzIiwic29tZSIsImlnbm9yZWQiLCJSZWdFeHAiLCJ0ZXN0IiwicmVzdWx0IiwiY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIiwic3RyaW5naWZ5MiIsInNlcmlhbGl6ZXIiLCJpbmRlbnQiLCJkZWN5Y2xlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRTZXJpYWxpemUyIiwic3RhY2siLCJfIiwic2xpY2UiLCJqb2luIiwidGhpc1BvcyIsInNwbGljZSIsInB1c2giLCJJbmZpbml0eSIsImNhbGwiLCJnZXRTZXJpYWxpemUiLCJ3YXJuQWZ0ZXIiLCJ0cmFjayIsImJpbmQiLCJnZXRTdGF0ZSIsInN0YXRlIiwidHJhY2tlciIsIm1lYXN1cmVVdGlscyIsImRpc3BhdGNoZWRBY3Rpb24iLCJpc0FjdGlvbjIiLCJpc1BsYWluIiwiZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlIiwiaXNTZXJpYWxpemFibGUiLCJnZXRFbnRyaWVzIiwiY2FjaGUiLCJmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSIsImtleVBhdGgiLCJlbnRyaWVzIiwibmVzdGVkVmFsdWUiLCJpc05lc3RlZEZyb3plbiIsInZhbHVlcyIsImNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSIsImlnbm9yZWRBY3Rpb25zIiwiaWdub3JlZEFjdGlvblBhdGhzIiwiaWdub3JlU3RhdGUiLCJpZ25vcmVBY3Rpb25zIiwiZGlzYWJsZUNhY2hlIiwiV2Vha1NldCIsInN0b3JlQVBJIiwiZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZSIsImZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSIsImlzQm9vbGVhbiIsIngiLCJidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlIiwiZ2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJpbW11dGFibGVDaGVjayIsInNlcmlhbGl6YWJsZUNoZWNrIiwiYWN0aW9uQ3JlYXRvckNoZWNrIiwibWlkZGxld2FyZUFycmF5IiwiZXh0cmFBcmd1bWVudCIsImltbXV0YWJsZU9wdGlvbnMiLCJ1bnNoaWZ0Iiwic2VyaWFsaXphYmxlT3B0aW9ucyIsImFjdGlvbkNyZWF0b3JPcHRpb25zIiwiU0hPVUxEX0FVVE9CQVRDSCIsInByZXBhcmVBdXRvQmF0Y2hlZCIsImNyZWF0ZVF1ZXVlV2l0aFRpbWVyIiwidGltZW91dCIsIm5vdGlmeSIsInNldFRpbWVvdXQiLCJyQUYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhdXRvQmF0Y2hFbmhhbmNlciIsInN0b3JlIiwibm90aWZ5aW5nIiwic2hvdWxkTm90aWZ5QXRFbmRPZlRpY2siLCJub3RpZmljYXRpb25RdWV1ZWQiLCJsaXN0ZW5lcnMiLCJxdWV1ZUNhbGxiYWNrIiwicXVldWVNaWNyb3Rhc2siLCJxdWV1ZU5vdGlmaWNhdGlvbiIsIm5vdGlmeUxpc3RlbmVycyIsImZvckVhY2giLCJsIiwic3Vic2NyaWJlIiwibGlzdGVuZXIyIiwid3JhcHBlZExpc3RlbmVyIiwidW5zdWJzY3JpYmUiLCJkZWxldGUiLCJkaXNwYXRjaCIsImJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyIsIm1pZGRsZXdhcmVFbmhhbmNlciIsImdldERlZmF1bHRFbmhhbmNlcnMiLCJhdXRvQmF0Y2giLCJlbmhhbmNlckFycmF5IiwiSVNfUFJPRFVDVElPTiIsImNvbmZpZ3VyZVN0b3JlIiwicmVkdWNlciIsIm1pZGRsZXdhcmUiLCJkZXZUb29scyIsInByZWxvYWRlZFN0YXRlIiwiZW5oYW5jZXJzIiwicm9vdFJlZHVjZXIiLCJmaW5hbE1pZGRsZXdhcmUiLCJpdGVtIiwiZmluYWxDb21wb3NlIiwidHJhY2UiLCJzdG9yZUVuaGFuY2VycyIsImluY2x1ZGVzIiwiY29tcG9zZWRFbmhhbmNlciIsImNyZWF0ZU5leHRTdGF0ZTIiLCJpc0RyYWZ0MiIsImlzRHJhZnRhYmxlMiIsImV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrIiwiYnVpbGRlckNhbGxiYWNrIiwiYWN0aW9uc01hcCIsImFjdGlvbk1hdGNoZXJzIiwiZGVmYXVsdENhc2VSZWR1Y2VyIiwiYnVpbGRlciIsImFkZENhc2UiLCJ0eXBlT3JBY3Rpb25DcmVhdG9yIiwiYWRkTWF0Y2hlciIsIm1hdGNoZXIiLCJhZGREZWZhdWx0Q2FzZSIsImlzU3RhdGVGdW5jdGlvbiIsImNyZWF0ZVJlZHVjZXIiLCJpbml0aWFsU3RhdGUiLCJtYXBPckJ1aWxkZXJDYWxsYmFjayIsImZpbmFsQWN0aW9uTWF0Y2hlcnMiLCJmaW5hbERlZmF1bHRDYXNlUmVkdWNlciIsImdldEluaXRpYWxTdGF0ZSIsImZyb3plbkluaXRpYWxTdGF0ZSIsImNhc2VSZWR1Y2VycyIsImZpbHRlciIsInJlZHVjZXIyIiwiY3IiLCJyZWR1Y2UiLCJwcmV2aW91c1N0YXRlIiwiY2FzZVJlZHVjZXIiLCJkcmFmdCIsInVybEFscGhhYmV0IiwibmFub2lkIiwic2l6ZSIsImlkIiwiaSIsIk1hdGgiLCJyYW5kb20iLCJtYXRjaGVzIiwiaXNBbnlPZiIsIm1hdGNoZXJzIiwiaXNBbGxPZiIsImhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhIiwidmFsaWRTdGF0dXMiLCJoYXNWYWxpZFJlcXVlc3RJZCIsInJlcXVlc3RJZCIsImhhc1ZhbGlkUmVxdWVzdFN0YXR1cyIsInJlcXVlc3RTdGF0dXMiLCJpc0FzeW5jVGh1bmtBcnJheSIsImEiLCJpc1BlbmRpbmciLCJhc3luY1RodW5rcyIsImFzeW5jVGh1bmsiLCJwZW5kaW5nIiwiY29tYmluZWRNYXRjaGVyIiwiaXNSZWplY3RlZCIsInJlamVjdGVkIiwiaXNSZWplY3RlZFdpdGhWYWx1ZSIsImhhc0ZsYWciLCJyZWplY3RlZFdpdGhWYWx1ZSIsImlzRnVsZmlsbGVkIiwiZnVsZmlsbGVkIiwiaXNBc3luY1RodW5rQWN0aW9uIiwiY29tbW9uUHJvcGVydGllcyIsIlJlamVjdFdpdGhWYWx1ZSIsIkZ1bGZpbGxXaXRoTWV0YSIsIm1pbmlTZXJpYWxpemVFcnJvciIsInNpbXBsZUVycm9yIiwicHJvcGVydHkiLCJtZXNzYWdlIiwiU3RyaW5nIiwiY3JlYXRlQXN5bmNUaHVuayIsImNyZWF0ZUFzeW5jVGh1bmsyIiwidHlwZVByZWZpeCIsInBheWxvYWRDcmVhdG9yIiwiYXJnIiwic2VyaWFsaXplRXJyb3IiLCJhYm9ydGVkIiwibmFtZSIsImNvbmRpdGlvbiIsImV4dHJhIiwiaWRHZW5lcmF0b3IiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJhYm9ydFJlYXNvbiIsImFib3J0IiwicmVhc29uIiwicHJvbWlzZSIsImZpbmFsQWN0aW9uIiwiY29uZGl0aW9uUmVzdWx0IiwiaXNUaGVuYWJsZSIsInNpZ25hbCIsImFib3J0ZWRQcm9taXNlIiwiUHJvbWlzZSIsInJlamVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJnZXRQZW5kaW5nTWV0YSIsInJhY2UiLCJyZXNvbHZlIiwicmVqZWN0V2l0aFZhbHVlIiwiZnVsZmlsbFdpdGhWYWx1ZSIsInRoZW4iLCJlcnIiLCJza2lwRGlzcGF0Y2giLCJkaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiIsInVud3JhcCIsInVud3JhcFJlc3VsdCIsInNldHRsZWQiLCJ3aXRoVHlwZXMiLCJhc3luY1RodW5rU3ltYm9sIiwiZm9yIiwiYXN5bmNUaHVua0NyZWF0b3IiLCJSZWR1Y2VyVHlwZSIsIlJlZHVjZXJUeXBlMiIsImdldFR5cGUiLCJhY3Rpb25LZXkiLCJidWlsZENyZWF0ZVNsaWNlIiwiY3JlYXRvcnMiLCJjQVQiLCJjcmVhdGVTbGljZTIiLCJyZWR1Y2VyUGF0aCIsInJlZHVjZXJzIiwiYnVpbGRSZWR1Y2VyQ3JlYXRvcnMiLCJyZWR1Y2VyTmFtZXMiLCJjb250ZXh0Iiwic2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUiLCJzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSIsImFjdGlvbkNyZWF0b3JzIiwic2xpY2VNYXRjaGVycyIsImNvbnRleHRNZXRob2RzIiwiZXhwb3NlQWN0aW9uIiwibmFtZTIiLCJleHBvc2VDYXNlUmVkdWNlciIsInJlZHVjZXJOYW1lIiwicmVkdWNlckRlZmluaXRpb24iLCJyZWR1Y2VyRGV0YWlscyIsImNyZWF0ZU5vdGF0aW9uIiwiaXNBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbiIsImhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uIiwiaGFuZGxlTm9ybWFsUmVkdWNlckRlZmluaXRpb24iLCJidWlsZFJlZHVjZXIiLCJleHRyYVJlZHVjZXJzIiwiZmluYWxDYXNlUmVkdWNlcnMiLCJzTSIsIm0iLCJzZWxlY3RTZWxmIiwiaW5qZWN0ZWRTZWxlY3RvckNhY2hlIiwiV2Vha01hcCIsIl9yZWR1Y2VyIiwiYWN0aW9ucyIsImdldFNlbGVjdG9ycyIsInNlbGVjdFN0YXRlIiwic2VsZWN0b3JDYWNoZSIsInNlbGVjdG9ycyIsIndyYXBTZWxlY3RvciIsInNlbGVjdFNsaWNlIiwic2xpY2VTdGF0ZSIsImluamVjdEludG8iLCJpbmplY3RhYmxlIiwicGF0aE9wdCIsImNvbmZpZyIsInJlZHVjZXJQYXRoMiIsImluamVjdCIsImluamVjdGVkIiwid3JhcHBlciIsInJvb3RTdGF0ZSIsInVud3JhcHBlZCIsImNyZWF0ZVNsaWNlIiwiX3JlZHVjZXJEZWZpbml0aW9uVHlwZSIsInByZXBhcmVkUmVkdWNlciIsInByZXBhcmUiLCJtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSIsInByZXBhcmVDYWxsYmFjayIsImlzQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZURlZmluaXRpb24iLCJub29wIiwiZ2V0SW5pdGlhbEVudGl0eVN0YXRlIiwiaWRzIiwiZW50aXRpZXMiLCJjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5IiwiYWRkaXRpb25hbFN0YXRlIiwiY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSIsInNlbGVjdElkcyIsInNlbGVjdEVudGl0aWVzIiwic2VsZWN0QWxsIiwic2VsZWN0SWQiLCJzZWxlY3RCeUlkIiwic2VsZWN0VG90YWwiLCJzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMiLCJjcmVhdGVOZXh0U3RhdGUzIiwiaXNEcmFmdDMiLCJpc0RyYWZ0VHlwZWQiLCJjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IiLCJtdXRhdG9yIiwib3BlcmF0b3IiLCJjcmVhdGVTdGF0ZU9wZXJhdG9yIiwib3BlcmF0aW9uIiwiaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQiLCJhcmcyIiwicnVuTXV0YXRvciIsInNlbGVjdElkVmFsdWUiLCJlbnRpdHkiLCJlbnN1cmVFbnRpdGllc0FycmF5Iiwic3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyIsIm5ld0VudGl0aWVzIiwiYWRkZWQiLCJ1cGRhdGVkIiwiY2hhbmdlcyIsImNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyIiwiYWRkT25lTXV0YWJseSIsImFkZE1hbnlNdXRhYmx5Iiwic2V0T25lTXV0YWJseSIsInNldE1hbnlNdXRhYmx5Iiwic2V0QWxsTXV0YWJseSIsInJlbW92ZU9uZU11dGFibHkiLCJyZW1vdmVNYW55TXV0YWJseSIsImRpZE11dGF0ZSIsInJlbW92ZUFsbE11dGFibHkiLCJ0YWtlTmV3S2V5Iiwib3JpZ2luYWwzIiwibmV3S2V5IiwiaGFzTmV3S2V5IiwidXBkYXRlT25lTXV0YWJseSIsInVwZGF0ZU1hbnlNdXRhYmx5IiwidXBkYXRlcyIsIm5ld0tleXMiLCJ1cGRhdGVzUGVyRW50aXR5IiwiZGlkTXV0YXRlRW50aXRpZXMiLCJkaWRNdXRhdGVJZHMiLCJlIiwidXBzZXJ0T25lTXV0YWJseSIsInVwc2VydE1hbnlNdXRhYmx5IiwicmVtb3ZlQWxsIiwiYWRkT25lIiwiYWRkTWFueSIsInNldE9uZSIsInNldE1hbnkiLCJzZXRBbGwiLCJ1cGRhdGVPbmUiLCJ1cGRhdGVNYW55IiwidXBzZXJ0T25lIiwidXBzZXJ0TWFueSIsInJlbW92ZU9uZSIsInJlbW92ZU1hbnkiLCJjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJzb3J0IiwibW9kZWxzIiwibW9kZWwiLCJtZXJnZSIsImFwcGxpZWRVcGRhdGVzIiwibmV3SWQiLCJyZXNvcnRFbnRpdGllcyIsImFyZUFycmF5c0VxdWFsIiwiYiIsImFsbEVudGl0aWVzIiwibmV3U29ydGVkSWRzIiwiY3JlYXRlRW50aXR5QWRhcHRlciIsInNvcnRDb21wYXJlciIsImluc3RhbmNlIiwic3RhdGVGYWN0b3J5Iiwic2VsZWN0b3JzRmFjdG9yeSIsInN0YXRlQWRhcHRlciIsImlzQWN0aW9uMyIsImFzc2VydEZ1bmN0aW9uIiwiZnVuYyIsImV4cGVjdGVkIiwibm9vcDIiLCJjYXRjaFJlamVjdGlvbiIsIm9uRXJyb3IiLCJjYXRjaCIsImFkZEFib3J0U2lnbmFsTGlzdGVuZXIiLCJhYm9ydFNpZ25hbCIsImNhbGxiYWNrIiwib25jZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ0YXNrIiwibGlzdGVuZXIiLCJjb21wbGV0ZWQiLCJjYW5jZWxsZWQiLCJ0YXNrQ2FuY2VsbGVkIiwidGFza0NvbXBsZXRlZCIsImxpc3RlbmVyQ2FuY2VsbGVkIiwibGlzdGVuZXJDb21wbGV0ZWQiLCJUYXNrQWJvcnRFcnJvciIsImNvZGUiLCJ2YWxpZGF0ZUFjdGl2ZSIsInJhY2VXaXRoU2lnbmFsIiwiY2xlYW51cCIsIm5vdGlmeVJlamVjdGlvbiIsImZpbmFsbHkiLCJydW5UYXNrIiwidGFzazIiLCJjbGVhblVwIiwic3RhdHVzIiwiY3JlYXRlUGF1c2UiLCJvdXRwdXQiLCJjcmVhdGVEZWxheSIsInBhdXNlIiwidGltZW91dE1zIiwiSU5URVJOQUxfTklMX1RPS0VOIiwiYWxtIiwiY3JlYXRlRm9yayIsInBhcmVudEFib3J0U2lnbmFsIiwicGFyZW50QmxvY2tpbmdQcm9taXNlcyIsImxpbmtDb250cm9sbGVycyIsImNvbnRyb2xsZXIiLCJ0YXNrRXhlY3V0b3IiLCJvcHRzIiwiY2hpbGRBYm9ydENvbnRyb2xsZXIiLCJyZXN1bHQyIiwiZGVsYXkiLCJhdXRvSm9pbiIsImNhbmNlbCIsImNyZWF0ZVRha2VQYXR0ZXJuIiwic3RhcnRMaXN0ZW5pbmciLCJ0YWtlIiwicHJlZGljYXRlIiwidHVwbGVQcm9taXNlIiwic3RvcExpc3RlbmluZyIsImVmZmVjdCIsImxpc3RlbmVyQXBpIiwiZ2V0T3JpZ2luYWxTdGF0ZSIsInByb21pc2VzIiwiZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbSIsImNyZWF0ZUxpc3RlbmVyRW50cnkiLCJjYW5jZWxBY3RpdmVMaXN0ZW5lcnMiLCJjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSIsImxpc3RlbmVyTWFwIiwiY2xlYXIiLCJzYWZlbHlOb3RpZnlFcnJvciIsImVycm9ySGFuZGxlciIsImVycm9yVG9Ob3RpZnkiLCJlcnJvckluZm8iLCJlcnJvckhhbmRsZXJFcnJvciIsImFkZExpc3RlbmVyIiwiY2xlYXJBbGxMaXN0ZW5lcnMiLCJyZW1vdmVMaXN0ZW5lciIsImRlZmF1bHRFcnJvckhhbmRsZXIiLCJjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlT3B0aW9ucyIsIk1hcCIsImluc2VydEVudHJ5IiwiY2FuY2VsT3B0aW9ucyIsImNhbmNlbEFjdGl2ZSIsImZyb20iLCJleGlzdGluZ0VudHJ5IiwiZW50cnkyIiwibWF0Y2hQcmVkaWNhdGVPclR5cGUiLCJub3RpZnlMaXN0ZW5lciIsImFwaSIsImludGVybmFsVGFza0NvbnRyb2xsZXIiLCJhdXRvSm9pblByb21pc2VzIiwiQm9vbGVhbiIsImZvcmsiLCJ0aHJvd0lmQ2FuY2VsbGVkIiwibGlzdGVuZXJFcnJvciIsInJhaXNlZEJ5IiwiYWxsU2V0dGxlZCIsImNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlIiwib3JpZ2luYWxTdGF0ZSIsImN1cnJlbnRTdGF0ZSIsImxpc3RlbmVyRW50cmllcyIsInJ1bkxpc3RlbmVyIiwicHJlZGljYXRlRXJyb3IiLCJjbGVhckxpc3RlbmVycyIsImNvbXBvc2UzIiwiY3JlYXRlTWlkZGxld2FyZUVudHJ5IiwiYXBwbGllZCIsIm1hdGNoSW5zdGFuY2UiLCJpbnN0YW5jZUlkIiwiY3JlYXRlRHluYW1pY01pZGRsZXdhcmUiLCJtaWRkbGV3YXJlTWFwIiwid2l0aE1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlcyIsImFkZE1pZGRsZXdhcmUiLCJhZGRNaWRkbGV3YXJlMiIsIm1pZGRsZXdhcmUyIiwiZ2V0RmluYWxNaWRkbGV3YXJlIiwiYXBwbGllZE1pZGRsZXdhcmUiLCJpc1dpdGhNaWRkbGV3YXJlIiwiY29tYmluZVJlZHVjZXJzMiIsImlzU2xpY2VMaWtlIiwibWF5YmVTbGljZUxpa2UiLCJnZXRSZWR1Y2VycyIsInNsaWNlcyIsImZsYXRNYXAiLCJzbGljZU9yTWFwIiwiT1JJR0lOQUxfU1RBVEUiLCJpc1N0YXRlUHJveHkiLCJzdGF0ZVByb3h5TWFwIiwiY3JlYXRlU3RhdGVQcm94eSIsInJlZHVjZXJNYXAiLCJQcm94eSIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsIlJlZmxlY3QiLCJyZWR1Y2VyUmVzdWx0IiwiY29tYmluZVNsaWNlcyIsImZyb21FbnRyaWVzIiwiZ2V0UmVkdWNlciIsImNvbWJpbmVkUmVkdWNlciIsIndpdGhMYXp5TG9hZGVkU2xpY2VzIiwicmVkdWNlclRvSW5qZWN0IiwiY3VycmVudFJlZHVjZXIiLCJvdmVycmlkZUV4aXN0aW5nIiwibWFrZVNlbGVjdG9yIiwic2VsZWN0b3JGbiIsInNlbGVjdG9yMiIsImlzRmx1eFN0YW5kYXJkQWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\n");

/***/ })

};
;