"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reduxjs";
exports.ids = ["vendor-chunks/@reduxjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnhancerArray: () => (/* binding */ EnhancerArray),\n/* harmony export */   MiddlewareArray: () => (/* binding */ MiddlewareArray),\n/* harmony export */   SHOULD_AUTOBATCH: () => (/* binding */ SHOULD_AUTOBATCH),\n/* harmony export */   TaskAbortError: () => (/* binding */ TaskAbortError),\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),\n/* harmony export */   addListener: () => (/* binding */ addListener),\n/* harmony export */   applyMiddleware: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),\n/* harmony export */   autoBatchEnhancer: () => (/* binding */ autoBatchEnhancer),\n/* harmony export */   bindActionCreators: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),\n/* harmony export */   clearAllListeners: () => (/* binding */ clearAllListeners),\n/* harmony export */   combineReducers: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),\n/* harmony export */   compose: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),\n/* harmony export */   configureStore: () => (/* binding */ configureStore),\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   createActionCreatorInvariantMiddleware: () => (/* binding */ createActionCreatorInvariantMiddleware),\n/* harmony export */   createAsyncThunk: () => (/* binding */ createAsyncThunk),\n/* harmony export */   createDraftSafeSelector: () => (/* binding */ createDraftSafeSelector),\n/* harmony export */   createEntityAdapter: () => (/* binding */ createEntityAdapter),\n/* harmony export */   createImmutableStateInvariantMiddleware: () => (/* binding */ createImmutableStateInvariantMiddleware),\n/* harmony export */   createListenerMiddleware: () => (/* binding */ createListenerMiddleware),\n/* harmony export */   createNextState: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   createReducer: () => (/* binding */ createReducer),\n/* harmony export */   createSelector: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),\n/* harmony export */   createSerializableStateInvariantMiddleware: () => (/* binding */ createSerializableStateInvariantMiddleware),\n/* harmony export */   createSlice: () => (/* binding */ createSlice),\n/* harmony export */   createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   current: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),\n/* harmony export */   findNonSerializableValue: () => (/* binding */ findNonSerializableValue),\n/* harmony export */   freeze: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),\n/* harmony export */   getDefaultMiddleware: () => (/* binding */ getDefaultMiddleware),\n/* harmony export */   getType: () => (/* binding */ getType),\n/* harmony export */   isAction: () => (/* binding */ isAction),\n/* harmony export */   isActionCreator: () => (/* binding */ isActionCreator),\n/* harmony export */   isAllOf: () => (/* binding */ isAllOf),\n/* harmony export */   isAnyOf: () => (/* binding */ isAnyOf),\n/* harmony export */   isAsyncThunkAction: () => (/* binding */ isAsyncThunkAction),\n/* harmony export */   isDraft: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),\n/* harmony export */   isFluxStandardAction: () => (/* binding */ isFSA),\n/* harmony export */   isFulfilled: () => (/* binding */ isFulfilled),\n/* harmony export */   isImmutableDefault: () => (/* binding */ isImmutableDefault),\n/* harmony export */   isPending: () => (/* binding */ isPending),\n/* harmony export */   isPlain: () => (/* binding */ isPlain),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRejected: () => (/* binding */ isRejected),\n/* harmony export */   isRejectedWithValue: () => (/* binding */ isRejectedWithValue),\n/* harmony export */   legacy_createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),\n/* harmony export */   miniSerializeError: () => (/* binding */ miniSerializeError),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   original: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),\n/* harmony export */   prepareAutoBatched: () => (/* binding */ prepareAutoBatched),\n/* harmony export */   removeListener: () => (/* binding */ removeListener),\n/* harmony export */   unwrapResult: () => (/* binding */ unwrapResult)\n/* harmony export */ });\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.esm.mjs\");\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/@reduxjs/toolkit/node_modules/redux/es/redux.js\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/es/index.js\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/@reduxjs/toolkit/node_modules/redux-thunk/es/index.js\");\nvar __extends = undefined && undefined.__extends || function() {\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    return function(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar __generator = undefined && undefined.__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar __spreadArray = undefined && undefined.__spreadArray || function(to, from) {\n    for(var i = 0, il = from.length, j = to.length; i < il; i++, j++)to[j] = from[i];\n    return to;\n};\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = function(obj, key, value) {\n    return key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __spreadValues = function(a, b) {\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for(var _i = 0, _c = __getOwnPropSymbols(b); _i < _c.length; _i++){\n        var prop = _c[_i];\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __spreadProps = function(a, b) {\n    return __defProps(a, __getOwnPropDescs(b));\n};\nvar __async = function(__this, __arguments, generator) {\n    return new Promise(function(resolve, reject) {\n        var fulfilled = function(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var rejected = function(value) {\n            try {\n                step(generator.throw(value));\n            } catch (e) {\n                reject(e);\n            }\n        };\n        var step = function(x) {\n            return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n        };\n        step((generator = generator.apply(__this, __arguments)).next());\n    });\n};\n// src/index.ts\n\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelector = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    var selector = reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector.apply(void 0, args);\n    var wrappedSelector = function(value) {\n        var rest = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            rest[_i - 1] = arguments[_i];\n        }\n        return selector.apply(void 0, __spreadArray([\n            (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value\n        ], rest));\n    };\n    return wrappedSelector;\n};\n// src/configureStore.ts\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools =  false ? 0 : function() {\n    if (arguments.length === 0) return void 0;\n    if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer =  false ? 0 : function() {\n    return function(noop2) {\n        return noop2;\n    };\n};\n// src/isPlainObject.ts\nfunction isPlainObject(value) {\n    if (typeof value !== \"object\" || value === null) return false;\n    var proto = Object.getPrototypeOf(value);\n    if (proto === null) return true;\n    var baseProto = proto;\n    while(Object.getPrototypeOf(baseProto) !== null){\n        baseProto = Object.getPrototypeOf(baseProto);\n    }\n    return proto === baseProto;\n}\n// src/getDefaultMiddleware.ts\n\n// src/tsHelpers.ts\nvar hasMatchFunction = function(v) {\n    return v && typeof v.match === \"function\";\n};\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n    function actionCreator() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        if (prepareAction) {\n            var prepared = prepareAction.apply(void 0, args);\n            if (!prepared) {\n                throw new Error(\"prepareAction did not return an object\");\n            }\n            return __spreadValues(__spreadValues({\n                type: type,\n                payload: prepared.payload\n            }, \"meta\" in prepared && {\n                meta: prepared.meta\n            }), \"error\" in prepared && {\n                error: prepared.error\n            });\n        }\n        return {\n            type: type,\n            payload: args[0]\n        };\n    }\n    actionCreator.toString = function() {\n        return \"\" + type;\n    };\n    actionCreator.type = type;\n    actionCreator.match = function(action) {\n        return action.type === type;\n    };\n    return actionCreator;\n}\nfunction isAction(action) {\n    return isPlainObject(action) && \"type\" in action;\n}\nfunction isActionCreator(action) {\n    return typeof action === \"function\" && \"type\" in action && hasMatchFunction(action);\n}\nfunction isFSA(action) {\n    return isAction(action) && typeof action.type === \"string\" && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n    return [\n        \"type\",\n        \"payload\",\n        \"error\",\n        \"meta\"\n    ].indexOf(key) > -1;\n}\nfunction getType(actionCreator) {\n    return \"\" + actionCreator;\n}\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n    var splitType = type ? (\"\" + type).split(\"/\") : [];\n    var actionName = splitType[splitType.length - 1] || \"actionCreator\";\n    return 'Detected an action creator with type \"' + (type || \"unknown\") + \"\\\" being dispatched. \\nMake sure you're calling the action creator before dispatching, i.e. `dispatch(\" + actionName + \"())` instead of `dispatch(\" + actionName + \")`. This is necessary even if the action has no payload.\";\n}\nfunction createActionCreatorInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isActionCreator, isActionCreator2 = _c === void 0 ? isActionCreator : _c;\n    return function() {\n        return function(next) {\n            return function(action) {\n                if (isActionCreator2(action)) {\n                    console.warn(getMessage(action.type));\n                }\n                return next(action);\n            };\n        };\n    };\n}\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n    var elapsed = 0;\n    return {\n        measureTime: function(fn) {\n            var started = Date.now();\n            try {\n                return fn();\n            } finally{\n                var finished = Date.now();\n                elapsed += finished - started;\n            }\n        },\n        warnIfExceeded: function() {\n            if (elapsed > maxDelay) {\n                console.warn(fnName + \" took \" + elapsed + \"ms, which is more than the warning threshold of \" + maxDelay + \"ms. \\nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\\nIt is disabled in production builds, so you don't need to worry about that.\");\n            }\n        }\n    };\n}\nvar MiddlewareArray = /** @class */ function(_super) {\n    __extends(MiddlewareArray, _super);\n    function MiddlewareArray() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        var _this = _super.apply(this, args) || this;\n        Object.setPrototypeOf(_this, MiddlewareArray.prototype);\n        return _this;\n    }\n    Object.defineProperty(MiddlewareArray, Symbol.species, {\n        get: function() {\n            return MiddlewareArray;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    MiddlewareArray.prototype.concat = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        return _super.prototype.concat.apply(this, arr);\n    };\n    MiddlewareArray.prototype.prepend = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([\n                void 0\n            ], arr[0].concat(this))))();\n        }\n        return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([\n            void 0\n        ], arr.concat(this))))();\n    };\n    return MiddlewareArray;\n}(Array);\nvar EnhancerArray = /** @class */ function(_super) {\n    __extends(EnhancerArray, _super);\n    function EnhancerArray() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        var _this = _super.apply(this, args) || this;\n        Object.setPrototypeOf(_this, EnhancerArray.prototype);\n        return _this;\n    }\n    Object.defineProperty(EnhancerArray, Symbol.species, {\n        get: function() {\n            return EnhancerArray;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    EnhancerArray.prototype.concat = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        return _super.prototype.concat.apply(this, arr);\n    };\n    EnhancerArray.prototype.prepend = function() {\n        var arr = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            arr[_i] = arguments[_i];\n        }\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new (EnhancerArray.bind.apply(EnhancerArray, __spreadArray([\n                void 0\n            ], arr[0].concat(this))))();\n        }\n        return new (EnhancerArray.bind.apply(EnhancerArray, __spreadArray([\n            void 0\n        ], arr.concat(this))))();\n    };\n    return EnhancerArray;\n}(Array);\nfunction freezeDraftable(val) {\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(val, function() {}) : val;\n}\n// src/immutableStateInvariantMiddleware.ts\nvar isProduction = \"development\" === \"production\";\nvar prefix = \"Invariant failed\";\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    throw new Error(prefix + \": \" + (message || \"\"));\n}\nfunction stringify(obj, serializer, indent, decycler) {\n    return JSON.stringify(obj, getSerialize(serializer, decycler), indent);\n}\nfunction getSerialize(serializer, decycler) {\n    var stack = [], keys = [];\n    if (!decycler) decycler = function(_, value) {\n        if (stack[0] === value) return \"[Circular ~]\";\n        return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n    };\n    return function(key, value) {\n        if (stack.length > 0) {\n            var thisPos = stack.indexOf(this);\n            ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n            ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n            if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n        } else stack.push(value);\n        return serializer == null ? value : serializer.call(this, key, value);\n    };\n}\nfunction isImmutableDefault(value) {\n    return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n    var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n    return {\n        detectMutations: function() {\n            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n        }\n    };\n}\nfunction trackProperties(isImmutable, ignorePaths, obj, path, checkedObjects) {\n    if (ignorePaths === void 0) {\n        ignorePaths = [];\n    }\n    if (path === void 0) {\n        path = \"\";\n    }\n    if (checkedObjects === void 0) {\n        checkedObjects = new Set();\n    }\n    var tracked = {\n        value: obj\n    };\n    if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n        checkedObjects.add(obj);\n        tracked.children = {};\n        for(var key in obj){\n            var childPath = path ? path + \".\" + key : key;\n            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n                continue;\n            }\n            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n        }\n    }\n    return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths, trackedProperty, obj, sameParentRef, path) {\n    if (ignoredPaths === void 0) {\n        ignoredPaths = [];\n    }\n    if (sameParentRef === void 0) {\n        sameParentRef = false;\n    }\n    if (path === void 0) {\n        path = \"\";\n    }\n    var prevObj = trackedProperty ? trackedProperty.value : void 0;\n    var sameRef = prevObj === obj;\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n        return {\n            wasMutated: true,\n            path: path\n        };\n    }\n    if (isImmutable(prevObj) || isImmutable(obj)) {\n        return {\n            wasMutated: false\n        };\n    }\n    var keysToDetect = {};\n    for(var key in trackedProperty.children){\n        keysToDetect[key] = true;\n    }\n    for(var key in obj){\n        keysToDetect[key] = true;\n    }\n    var hasIgnoredPaths = ignoredPaths.length > 0;\n    var _loop_1 = function(key) {\n        var nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            var hasMatches = ignoredPaths.some(function(ignored) {\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                return \"continue\";\n            }\n        }\n        var result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n        if (result.wasMutated) {\n            return {\n                value: result\n            };\n        }\n    };\n    for(var key in keysToDetect){\n        var state_1 = _loop_1(key);\n        if (typeof state_1 === \"object\") return state_1.value;\n    }\n    return {\n        wasMutated: false\n    };\n}\nfunction createImmutableStateInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isImmutable, isImmutable = _c === void 0 ? isImmutableDefault : _c, ignoredPaths = options.ignoredPaths, _d = options.warnAfter, warnAfter = _d === void 0 ? 32 : _d, ignore = options.ignore;\n    ignoredPaths = ignoredPaths || ignore;\n    var track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n    return function(_c) {\n        var getState = _c.getState;\n        var state = getState();\n        var tracker = track(state);\n        var result;\n        return function(next) {\n            return function(action) {\n                var measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n                measureUtils.measureTime(function() {\n                    state = getState();\n                    result = tracker.detectMutations();\n                    tracker = track(state);\n                    invariant(!result.wasMutated, \"A state mutation was detected between dispatches, in the path '\" + (result.path || \"\") + \"'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\");\n                });\n                var dispatchedAction = next(action);\n                measureUtils.measureTime(function() {\n                    state = getState();\n                    result = tracker.detectMutations();\n                    tracker = track(state);\n                    result.wasMutated && invariant(!result.wasMutated, \"A state mutation was detected inside a dispatch, in the path: \" + (result.path || \"\") + \". Take a look at the reducer(s) handling the action \" + stringify(action) + \". (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)\");\n                });\n                measureUtils.warnIfExceeded();\n                return dispatchedAction;\n            };\n        };\n    };\n}\n// src/serializableStateInvariantMiddleware.ts\nfunction isPlain(val) {\n    var type = typeof val;\n    return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || isPlainObject(val);\n}\nfunction findNonSerializableValue(value, path, isSerializable, getEntries, ignoredPaths, cache) {\n    if (path === void 0) {\n        path = \"\";\n    }\n    if (isSerializable === void 0) {\n        isSerializable = isPlain;\n    }\n    if (ignoredPaths === void 0) {\n        ignoredPaths = [];\n    }\n    var foundNestedSerializable;\n    if (!isSerializable(value)) {\n        return {\n            keyPath: path || \"<root>\",\n            value: value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    if (cache == null ? void 0 : cache.has(value)) return false;\n    var entries = getEntries != null ? getEntries(value) : Object.entries(value);\n    var hasIgnoredPaths = ignoredPaths.length > 0;\n    var _loop_2 = function(key, nestedValue) {\n        var nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            var hasMatches = ignoredPaths.some(function(ignored) {\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                return \"continue\";\n            }\n        }\n        if (!isSerializable(nestedValue)) {\n            return {\n                value: {\n                    keyPath: nestedPath,\n                    value: nestedValue\n                }\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n            if (foundNestedSerializable) {\n                return {\n                    value: foundNestedSerializable\n                };\n            }\n        }\n    };\n    for(var _i = 0, entries_1 = entries; _i < entries_1.length; _i++){\n        var _c = entries_1[_i], key = _c[0], nestedValue = _c[1];\n        var state_2 = _loop_2(key, nestedValue);\n        if (typeof state_2 === \"object\") return state_2.value;\n    }\n    if (cache && isNestedFrozen(value)) cache.add(value);\n    return false;\n}\nfunction isNestedFrozen(value) {\n    if (!Object.isFrozen(value)) return false;\n    for(var _i = 0, _c = Object.values(value); _i < _c.length; _i++){\n        var nestedValue = _c[_i];\n        if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n        if (!isNestedFrozen(nestedValue)) return false;\n    }\n    return true;\n}\nfunction createSerializableStateInvariantMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    if (false) {}\n    var _c = options.isSerializable, isSerializable = _c === void 0 ? isPlain : _c, getEntries = options.getEntries, _d = options.ignoredActions, ignoredActions = _d === void 0 ? [] : _d, _e = options.ignoredActionPaths, ignoredActionPaths = _e === void 0 ? [\n        \"meta.arg\",\n        \"meta.baseQueryMeta\"\n    ] : _e, _f = options.ignoredPaths, ignoredPaths = _f === void 0 ? [] : _f, _g = options.warnAfter, warnAfter = _g === void 0 ? 32 : _g, _h = options.ignoreState, ignoreState = _h === void 0 ? false : _h, _j = options.ignoreActions, ignoreActions = _j === void 0 ? false : _j, _k = options.disableCache, disableCache = _k === void 0 ? false : _k;\n    var cache = !disableCache && WeakSet ? new WeakSet() : void 0;\n    return function(storeAPI) {\n        return function(next) {\n            return function(action) {\n                var result = next(action);\n                var measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n                if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n                    measureUtils.measureTime(function() {\n                        var foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n                        if (foundActionNonSerializableValue) {\n                            var keyPath = foundActionNonSerializableValue.keyPath, value = foundActionNonSerializableValue.value;\n                            console.error(\"A non-serializable value was detected in an action, in the path: `\" + keyPath + \"`. Value:\", value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n                        }\n                    });\n                }\n                if (!ignoreState) {\n                    measureUtils.measureTime(function() {\n                        var state = storeAPI.getState();\n                        var foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n                        if (foundStateNonSerializableValue) {\n                            var keyPath = foundStateNonSerializableValue.keyPath, value = foundStateNonSerializableValue.value;\n                            console.error(\"A non-serializable value was detected in the state, in the path: `\" + keyPath + \"`. Value:\", value, \"\\nTake a look at the reducer(s) handling this action type: \" + action.type + \".\\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)\");\n                        }\n                    });\n                    measureUtils.warnIfExceeded();\n                }\n                return result;\n            };\n        };\n    };\n}\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nfunction curryGetDefaultMiddleware() {\n    return function curriedGetDefaultMiddleware(options) {\n        return getDefaultMiddleware(options);\n    };\n}\nfunction getDefaultMiddleware(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _c = options.thunk, thunk = _c === void 0 ? true : _c, _d = options.immutableCheck, immutableCheck = _d === void 0 ? true : _d, _e = options.serializableCheck, serializableCheck = _e === void 0 ? true : _e, _f = options.actionCreatorCheck, actionCreatorCheck = _f === void 0 ? true : _f;\n    var middlewareArray = new MiddlewareArray();\n    if (thunk) {\n        if (isBoolean(thunk)) {\n            middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n        } else {\n            middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__[\"default\"].withExtraArgument(thunk.extraArgument));\n        }\n    }\n    if (true) {\n        if (immutableCheck) {\n            var immutableOptions = {};\n            if (!isBoolean(immutableCheck)) {\n                immutableOptions = immutableCheck;\n            }\n            middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n        }\n        if (serializableCheck) {\n            var serializableOptions = {};\n            if (!isBoolean(serializableCheck)) {\n                serializableOptions = serializableCheck;\n            }\n            middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n        }\n        if (actionCreatorCheck) {\n            var actionCreatorOptions = {};\n            if (!isBoolean(actionCreatorCheck)) {\n                actionCreatorOptions = actionCreatorCheck;\n            }\n            middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n        }\n    }\n    return middlewareArray;\n}\n// src/configureStore.ts\nvar IS_PRODUCTION = \"development\" === \"production\";\nfunction configureStore(options) {\n    var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();\n    var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;\n    var rootReducer;\n    if (typeof reducer === \"function\") {\n        rootReducer = reducer;\n    } else if (isPlainObject(reducer)) {\n        rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n    } else {\n        throw new Error('\"reducer\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');\n    }\n    var finalMiddleware = middleware;\n    if (typeof finalMiddleware === \"function\") {\n        finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);\n        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n            throw new Error(\"when using a middleware builder function, an array of middleware must be returned\");\n        }\n    }\n    if (!IS_PRODUCTION && finalMiddleware.some(function(item) {\n        return typeof item !== \"function\";\n    })) {\n        throw new Error(\"each middleware provided to configureStore must be a function\");\n    }\n    var middlewareEnhancer = redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware.apply(void 0, finalMiddleware);\n    var finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    if (devTools) {\n        finalCompose = composeWithDevTools(__spreadValues({\n            trace: !IS_PRODUCTION\n        }, typeof devTools === \"object\" && devTools));\n    }\n    var defaultEnhancers = new EnhancerArray(middlewareEnhancer);\n    var storeEnhancers = defaultEnhancers;\n    if (Array.isArray(enhancers)) {\n        storeEnhancers = __spreadArray([\n            middlewareEnhancer\n        ], enhancers);\n    } else if (typeof enhancers === \"function\") {\n        storeEnhancers = enhancers(defaultEnhancers);\n    }\n    var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n// src/createReducer.ts\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n    var actionsMap = {};\n    var actionMatchers = [];\n    var defaultCaseReducer;\n    var builder = {\n        addCase: function(typeOrActionCreator, reducer) {\n            if (true) {\n                if (actionMatchers.length > 0) {\n                    throw new Error(\"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n                }\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            var type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n            if (!type) {\n                throw new Error(\"`builder.addCase` cannot be called with an empty action type\");\n            }\n            if (type in actionsMap) {\n                throw new Error(\"`builder.addCase` cannot be called with two reducers for the same action type\");\n            }\n            actionsMap[type] = reducer;\n            return builder;\n        },\n        addMatcher: function(matcher, reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            actionMatchers.push({\n                matcher: matcher,\n                reducer: reducer\n            });\n            return builder;\n        },\n        addDefaultCase: function(reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error(\"`builder.addDefaultCase` can only be called once\");\n                }\n            }\n            defaultCaseReducer = reducer;\n            return builder;\n        }\n    };\n    builderCallback(builder);\n    return [\n        actionsMap,\n        actionMatchers,\n        defaultCaseReducer\n    ];\n}\n// src/createReducer.ts\nfunction isStateFunction(x) {\n    return typeof x === \"function\";\n}\nvar hasWarnedAboutObjectNotation = false;\nfunction createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {\n    if (actionMatchers === void 0) {\n        actionMatchers = [];\n    }\n    if (true) {\n        if (typeof mapOrBuilderCallback === \"object\") {\n            if (!hasWarnedAboutObjectNotation) {\n                hasWarnedAboutObjectNotation = true;\n                console.warn(\"The object notation for `createReducer` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n            }\n        }\n    }\n    var _c = typeof mapOrBuilderCallback === \"function\" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [\n        mapOrBuilderCallback,\n        actionMatchers,\n        defaultCaseReducer\n    ], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];\n    var getInitialState;\n    if (isStateFunction(initialState)) {\n        getInitialState = function() {\n            return freezeDraftable(initialState());\n        };\n    } else {\n        var frozenInitialState_1 = freezeDraftable(initialState);\n        getInitialState = function() {\n            return frozenInitialState_1;\n        };\n    }\n    function reducer(state, action) {\n        if (state === void 0) {\n            state = getInitialState();\n        }\n        var caseReducers = __spreadArray([\n            actionsMap[action.type]\n        ], finalActionMatchers.filter(function(_c) {\n            var matcher = _c.matcher;\n            return matcher(action);\n        }).map(function(_c) {\n            var reducer2 = _c.reducer;\n            return reducer2;\n        }));\n        if (caseReducers.filter(function(cr) {\n            return !!cr;\n        }).length === 0) {\n            caseReducers = [\n                finalDefaultCaseReducer\n            ];\n        }\n        return caseReducers.reduce(function(previousState, caseReducer) {\n            if (caseReducer) {\n                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n                    var draft = previousState;\n                    var result = caseReducer(draft, action);\n                    if (result === void 0) {\n                        return previousState;\n                    }\n                    return result;\n                } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n                    var result = caseReducer(previousState, action);\n                    if (result === void 0) {\n                        if (previousState === null) {\n                            return previousState;\n                        }\n                        throw Error(\"A case reducer on a non-draftable value must not return undefined\");\n                    }\n                    return result;\n                } else {\n                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(previousState, function(draft) {\n                        return caseReducer(draft, action);\n                    });\n                }\n            }\n            return previousState;\n        }, state);\n    }\n    reducer.getInitialState = getInitialState;\n    return reducer;\n}\n// src/createSlice.ts\nvar hasWarnedAboutObjectNotation2 = false;\nfunction getType2(slice, actionKey) {\n    return slice + \"/\" + actionKey;\n}\nfunction createSlice(options) {\n    var name = options.name;\n    if (!name) {\n        throw new Error(\"`name` is a required option for createSlice\");\n    }\n    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n        if (options.initialState === void 0) {\n            console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n        }\n    }\n    var initialState = typeof options.initialState == \"function\" ? options.initialState : freezeDraftable(options.initialState);\n    var reducers = options.reducers || {};\n    var reducerNames = Object.keys(reducers);\n    var sliceCaseReducersByName = {};\n    var sliceCaseReducersByType = {};\n    var actionCreators = {};\n    reducerNames.forEach(function(reducerName) {\n        var maybeReducerWithPrepare = reducers[reducerName];\n        var type = getType2(name, reducerName);\n        var caseReducer;\n        var prepareCallback;\n        if (\"reducer\" in maybeReducerWithPrepare) {\n            caseReducer = maybeReducerWithPrepare.reducer;\n            prepareCallback = maybeReducerWithPrepare.prepare;\n        } else {\n            caseReducer = maybeReducerWithPrepare;\n        }\n        sliceCaseReducersByName[reducerName] = caseReducer;\n        sliceCaseReducersByType[type] = caseReducer;\n        actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);\n    });\n    function buildReducer() {\n        if (true) {\n            if (typeof options.extraReducers === \"object\") {\n                if (!hasWarnedAboutObjectNotation2) {\n                    hasWarnedAboutObjectNotation2 = true;\n                    console.warn(\"The object notation for `createSlice.extraReducers` is deprecated, and will be removed in RTK 2.0. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n                }\n            }\n        }\n        var _c = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [\n            options.extraReducers\n        ], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e = _c[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;\n        var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);\n        return createReducer(initialState, function(builder) {\n            for(var key in finalCaseReducers){\n                builder.addCase(key, finalCaseReducers[key]);\n            }\n            for(var _i = 0, actionMatchers_1 = actionMatchers; _i < actionMatchers_1.length; _i++){\n                var m = actionMatchers_1[_i];\n                builder.addMatcher(m.matcher, m.reducer);\n            }\n            if (defaultCaseReducer) {\n                builder.addDefaultCase(defaultCaseReducer);\n            }\n        });\n    }\n    var _reducer;\n    return {\n        name: name,\n        reducer: function(state, action) {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer(state, action);\n        },\n        actions: actionCreators,\n        caseReducers: sliceCaseReducersByName,\n        getInitialState: function() {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer.getInitialState();\n        }\n    };\n}\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n    return {\n        ids: [],\n        entities: {}\n    };\n}\nfunction createInitialStateFactory() {\n    function getInitialState(additionalState) {\n        if (additionalState === void 0) {\n            additionalState = {};\n        }\n        return Object.assign(getInitialEntityState(), additionalState);\n    }\n    return {\n        getInitialState: getInitialState\n    };\n}\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n    function getSelectors(selectState) {\n        var selectIds = function(state) {\n            return state.ids;\n        };\n        var selectEntities = function(state) {\n            return state.entities;\n        };\n        var selectAll = createDraftSafeSelector(selectIds, selectEntities, function(ids, entities) {\n            return ids.map(function(id) {\n                return entities[id];\n            });\n        });\n        var selectId = function(_, id) {\n            return id;\n        };\n        var selectById = function(entities, id) {\n            return entities[id];\n        };\n        var selectTotal = createDraftSafeSelector(selectIds, function(ids) {\n            return ids.length;\n        });\n        if (!selectState) {\n            return {\n                selectIds: selectIds,\n                selectEntities: selectEntities,\n                selectAll: selectAll,\n                selectTotal: selectTotal,\n                selectById: createDraftSafeSelector(selectEntities, selectId, selectById)\n            };\n        }\n        var selectGlobalizedEntities = createDraftSafeSelector(selectState, selectEntities);\n        return {\n            selectIds: createDraftSafeSelector(selectState, selectIds),\n            selectEntities: selectGlobalizedEntities,\n            selectAll: createDraftSafeSelector(selectState, selectAll),\n            selectTotal: createDraftSafeSelector(selectState, selectTotal),\n            selectById: createDraftSafeSelector(selectGlobalizedEntities, selectId, selectById)\n        };\n    }\n    return {\n        getSelectors: getSelectors\n    };\n}\n// src/entities/state_adapter.ts\n\nfunction createSingleArgumentStateOperator(mutator) {\n    var operator = createStateOperator(function(_, state) {\n        return mutator(state);\n    });\n    return function operation(state) {\n        return operator(state, void 0);\n    };\n}\nfunction createStateOperator(mutator) {\n    return function operation(state, arg) {\n        function isPayloadActionArgument(arg2) {\n            return isFSA(arg2);\n        }\n        var runMutator = function(draft) {\n            if (isPayloadActionArgument(arg)) {\n                mutator(arg.payload, draft);\n            } else {\n                mutator(arg, draft);\n            }\n        };\n        if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(state)) {\n            runMutator(state);\n            return state;\n        } else {\n            return (0,immer__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state, runMutator);\n        }\n    };\n}\n// src/entities/utils.ts\nfunction selectIdValue(entity, selectId) {\n    var key = selectId(entity);\n    if ( true && key === void 0) {\n        console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n    }\n    return key;\n}\nfunction ensureEntitiesArray(entities) {\n    if (!Array.isArray(entities)) {\n        entities = Object.values(entities);\n    }\n    return entities;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    var added = [];\n    var updated = [];\n    for(var _i = 0, newEntities_1 = newEntities; _i < newEntities_1.length; _i++){\n        var entity = newEntities_1[_i];\n        var id = selectIdValue(entity, selectId);\n        if (id in state.entities) {\n            updated.push({\n                id: id,\n                changes: entity\n            });\n        } else {\n            added.push(entity);\n        }\n    }\n    return [\n        added,\n        updated\n    ];\n}\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n    function addOneMutably(entity, state) {\n        var key = selectIdValue(entity, selectId);\n        if (key in state.entities) {\n            return;\n        }\n        state.ids.push(key);\n        state.entities[key] = entity;\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for(var _i = 0, newEntities_2 = newEntities; _i < newEntities_2.length; _i++){\n            var entity = newEntities_2[_i];\n            addOneMutably(entity, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        var key = selectIdValue(entity, selectId);\n        if (!(key in state.entities)) {\n            state.ids.push(key);\n        }\n        state.entities[key] = entity;\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for(var _i = 0, newEntities_3 = newEntities; _i < newEntities_3.length; _i++){\n            var entity = newEntities_3[_i];\n            setOneMutably(entity, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.ids = [];\n        state.entities = {};\n        addManyMutably(newEntities, state);\n    }\n    function removeOneMutably(key, state) {\n        return removeManyMutably([\n            key\n        ], state);\n    }\n    function removeManyMutably(keys, state) {\n        var didMutate = false;\n        keys.forEach(function(key) {\n            if (key in state.entities) {\n                delete state.entities[key];\n                didMutate = true;\n            }\n        });\n        if (didMutate) {\n            state.ids = state.ids.filter(function(id) {\n                return id in state.entities;\n            });\n        }\n    }\n    function removeAllMutably(state) {\n        Object.assign(state, {\n            ids: [],\n            entities: {}\n        });\n    }\n    function takeNewKey(keys, update, state) {\n        var original2 = state.entities[update.id];\n        var updated = Object.assign({}, original2, update.changes);\n        var newKey = selectIdValue(updated, selectId);\n        var hasNewKey = newKey !== update.id;\n        if (hasNewKey) {\n            keys[update.id] = newKey;\n            delete state.entities[update.id];\n        }\n        state.entities[newKey] = updated;\n        return hasNewKey;\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        var newKeys = {};\n        var updatesPerEntity = {};\n        updates.forEach(function(update) {\n            if (update.id in state.entities) {\n                updatesPerEntity[update.id] = {\n                    id: update.id,\n                    changes: __spreadValues(__spreadValues({}, updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null), update.changes)\n                };\n            }\n        });\n        updates = Object.values(updatesPerEntity);\n        var didMutateEntities = updates.length > 0;\n        if (didMutateEntities) {\n            var didMutateIds = updates.filter(function(update) {\n                return takeNewKey(newKeys, update, state);\n            }).length > 0;\n            if (didMutateIds) {\n                state.ids = Object.keys(state.entities);\n            }\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    return {\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\n        addOne: createStateOperator(addOneMutably),\n        addMany: createStateOperator(addManyMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        upsertMany: createStateOperator(upsertManyMutably),\n        removeOne: createStateOperator(removeOneMutably),\n        removeMany: createStateOperator(removeManyMutably)\n    };\n}\n// src/entities/sorted_state_adapter.ts\nfunction createSortedStateAdapter(selectId, sort) {\n    var _c = createUnsortedStateAdapter(selectId), removeOne = _c.removeOne, removeMany = _c.removeMany, removeAll = _c.removeAll;\n    function addOneMutably(entity, state) {\n        return addManyMutably([\n            entity\n        ], state);\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        var models = newEntities.filter(function(model) {\n            return !(selectIdValue(model, selectId) in state.entities);\n        });\n        if (models.length !== 0) {\n            merge(models, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        return setManyMutably([\n            entity\n        ], state);\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        if (newEntities.length !== 0) {\n            merge(newEntities, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.entities = {};\n        state.ids = [];\n        addManyMutably(newEntities, state);\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        var appliedUpdates = false;\n        for(var _i = 0, updates_1 = updates; _i < updates_1.length; _i++){\n            var update = updates_1[_i];\n            var entity = state.entities[update.id];\n            if (!entity) {\n                continue;\n            }\n            appliedUpdates = true;\n            Object.assign(entity, update.changes);\n            var newId = selectId(entity);\n            if (update.id !== newId) {\n                delete state.entities[update.id];\n                state.entities[newId] = entity;\n            }\n        }\n        if (appliedUpdates) {\n            resortEntities(state);\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        var _c = splitAddedUpdatedEntities(newEntities, selectId, state), added = _c[0], updated = _c[1];\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    function areArraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(var i = 0; i < a.length && i < b.length; i++){\n            if (a[i] === b[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    function merge(models, state) {\n        models.forEach(function(model) {\n            state.entities[selectId(model)] = model;\n        });\n        resortEntities(state);\n    }\n    function resortEntities(state) {\n        var allEntities = Object.values(state.entities);\n        allEntities.sort(sort);\n        var newSortedIds = allEntities.map(selectId);\n        var ids = state.ids;\n        if (!areArraysEqual(ids, newSortedIds)) {\n            state.ids = newSortedIds;\n        }\n    }\n    return {\n        removeOne: removeOne,\n        removeMany: removeMany,\n        removeAll: removeAll,\n        addOne: createStateOperator(addOneMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        addMany: createStateOperator(addManyMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertMany: createStateOperator(upsertManyMutably)\n    };\n}\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _c = __spreadValues({\n        sortComparer: false,\n        selectId: function(instance) {\n            return instance.id;\n        }\n    }, options), selectId = _c.selectId, sortComparer = _c.sortComparer;\n    var stateFactory = createInitialStateFactory();\n    var selectorsFactory = createSelectorsFactory();\n    var stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n    return __spreadValues(__spreadValues(__spreadValues({\n        selectId: selectId,\n        sortComparer: sortComparer\n    }, stateFactory), selectorsFactory), stateAdapter);\n}\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = function(size) {\n    if (size === void 0) {\n        size = 21;\n    }\n    var id = \"\";\n    var i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/createAsyncThunk.ts\nvar commonProperties = [\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\"\n];\nvar RejectWithValue = /** @class */ function() {\n    function RejectWithValue(payload, meta) {\n        this.payload = payload;\n        this.meta = meta;\n    }\n    return RejectWithValue;\n}();\nvar FulfillWithMeta = /** @class */ function() {\n    function FulfillWithMeta(payload, meta) {\n        this.payload = payload;\n        this.meta = meta;\n    }\n    return FulfillWithMeta;\n}();\nvar miniSerializeError = function(value) {\n    if (typeof value === \"object\" && value !== null) {\n        var simpleError = {};\n        for(var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++){\n            var property = commonProperties_1[_i];\n            if (typeof value[property] === \"string\") {\n                simpleError[property] = value[property];\n            }\n        }\n        return simpleError;\n    }\n    return {\n        message: String(value)\n    };\n};\nvar createAsyncThunk = function() {\n    function createAsyncThunk2(typePrefix, payloadCreator, options) {\n        var fulfilled = createAction(typePrefix + \"/fulfilled\", function(payload, requestId, arg, meta) {\n            return {\n                payload: payload,\n                meta: __spreadProps(__spreadValues({}, meta || {}), {\n                    arg: arg,\n                    requestId: requestId,\n                    requestStatus: \"fulfilled\"\n                })\n            };\n        });\n        var pending = createAction(typePrefix + \"/pending\", function(requestId, arg, meta) {\n            return {\n                payload: void 0,\n                meta: __spreadProps(__spreadValues({}, meta || {}), {\n                    arg: arg,\n                    requestId: requestId,\n                    requestStatus: \"pending\"\n                })\n            };\n        });\n        var rejected = createAction(typePrefix + \"/rejected\", function(error, requestId, arg, payload, meta) {\n            return {\n                payload: payload,\n                error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n                meta: __spreadProps(__spreadValues({}, meta || {}), {\n                    arg: arg,\n                    requestId: requestId,\n                    rejectedWithValue: !!payload,\n                    requestStatus: \"rejected\",\n                    aborted: (error == null ? void 0 : error.name) === \"AbortError\",\n                    condition: (error == null ? void 0 : error.name) === \"ConditionError\"\n                })\n            };\n        });\n        var displayedWarning = false;\n        var AC = typeof AbortController !== \"undefined\" ? AbortController : /** @class */ function() {\n            function class_1() {\n                this.signal = {\n                    aborted: false,\n                    addEventListener: function() {},\n                    dispatchEvent: function() {\n                        return false;\n                    },\n                    onabort: function() {},\n                    removeEventListener: function() {},\n                    reason: void 0,\n                    throwIfAborted: function() {}\n                };\n            }\n            class_1.prototype.abort = function() {\n                if (true) {\n                    if (!displayedWarning) {\n                        displayedWarning = true;\n                        console.info(\"This platform does not implement AbortController. \\nIf you want to use the AbortController to react to `abort` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.\");\n                    }\n                }\n            };\n            return class_1;\n        }();\n        function actionCreator(arg) {\n            return function(dispatch, getState, extra) {\n                var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();\n                var abortController = new AC();\n                var abortReason;\n                var started = false;\n                function abort(reason) {\n                    abortReason = reason;\n                    abortController.abort();\n                }\n                var promise2 = function() {\n                    return __async(this, null, function() {\n                        var _a, _b, finalAction, conditionResult, abortedPromise, err_1, skipDispatch;\n                        return __generator(this, function(_c) {\n                            switch(_c.label){\n                                case 0:\n                                    _c.trys.push([\n                                        0,\n                                        4,\n                                        ,\n                                        5\n                                    ]);\n                                    conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, {\n                                        getState: getState,\n                                        extra: extra\n                                    });\n                                    if (!isThenable(conditionResult)) return [\n                                        3 /*break*/ ,\n                                        2\n                                    ];\n                                    return [\n                                        4 /*yield*/ ,\n                                        conditionResult\n                                    ];\n                                case 1:\n                                    conditionResult = _c.sent();\n                                    _c.label = 2;\n                                case 2:\n                                    if (conditionResult === false || abortController.signal.aborted) {\n                                        throw {\n                                            name: \"ConditionError\",\n                                            message: \"Aborted due to condition callback returning false.\"\n                                        };\n                                    }\n                                    started = true;\n                                    abortedPromise = new Promise(function(_, reject) {\n                                        return abortController.signal.addEventListener(\"abort\", function() {\n                                            return reject({\n                                                name: \"AbortError\",\n                                                message: abortReason || \"Aborted\"\n                                            });\n                                        });\n                                    });\n                                    dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, {\n                                        requestId: requestId,\n                                        arg: arg\n                                    }, {\n                                        getState: getState,\n                                        extra: extra\n                                    })));\n                                    return [\n                                        4 /*yield*/ ,\n                                        Promise.race([\n                                            abortedPromise,\n                                            Promise.resolve(payloadCreator(arg, {\n                                                dispatch: dispatch,\n                                                getState: getState,\n                                                extra: extra,\n                                                requestId: requestId,\n                                                signal: abortController.signal,\n                                                abort: abort,\n                                                rejectWithValue: function(value, meta) {\n                                                    return new RejectWithValue(value, meta);\n                                                },\n                                                fulfillWithValue: function(value, meta) {\n                                                    return new FulfillWithMeta(value, meta);\n                                                }\n                                            })).then(function(result) {\n                                                if (result instanceof RejectWithValue) {\n                                                    throw result;\n                                                }\n                                                if (result instanceof FulfillWithMeta) {\n                                                    return fulfilled(result.payload, requestId, arg, result.meta);\n                                                }\n                                                return fulfilled(result, requestId, arg);\n                                            })\n                                        ])\n                                    ];\n                                case 3:\n                                    finalAction = _c.sent();\n                                    return [\n                                        3 /*break*/ ,\n                                        5\n                                    ];\n                                case 4:\n                                    err_1 = _c.sent();\n                                    finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);\n                                    return [\n                                        3 /*break*/ ,\n                                        5\n                                    ];\n                                case 5:\n                                    skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n                                    if (!skipDispatch) {\n                                        dispatch(finalAction);\n                                    }\n                                    return [\n                                        2 /*return*/ ,\n                                        finalAction\n                                    ];\n                            }\n                        });\n                    });\n                }();\n                return Object.assign(promise2, {\n                    abort: abort,\n                    requestId: requestId,\n                    arg: arg,\n                    unwrap: function() {\n                        return promise2.then(unwrapResult);\n                    }\n                });\n            };\n        }\n        return Object.assign(actionCreator, {\n            pending: pending,\n            rejected: rejected,\n            fulfilled: fulfilled,\n            typePrefix: typePrefix\n        });\n    }\n    createAsyncThunk2.withTypes = function() {\n        return createAsyncThunk2;\n    };\n    return createAsyncThunk2;\n}();\nfunction unwrapResult(action) {\n    if (action.meta && action.meta.rejectedWithValue) {\n        throw action.payload;\n    }\n    if (action.error) {\n        throw action.error;\n    }\n    return action.payload;\n}\nfunction isThenable(value) {\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n// src/matchers.ts\nvar matches = function(matcher, action) {\n    if (hasMatchFunction(matcher)) {\n        return matcher.match(action);\n    } else {\n        return matcher(action);\n    }\n};\nfunction isAnyOf() {\n    var matchers = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        matchers[_i] = arguments[_i];\n    }\n    return function(action) {\n        return matchers.some(function(matcher) {\n            return matches(matcher, action);\n        });\n    };\n}\nfunction isAllOf() {\n    var matchers = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        matchers[_i] = arguments[_i];\n    }\n    return function(action) {\n        return matchers.every(function(matcher) {\n            return matches(matcher, action);\n        });\n    };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n    if (!action || !action.meta) return false;\n    var hasValidRequestId = typeof action.meta.requestId === \"string\";\n    var hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n    return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"pending\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isPending()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.pending;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejected() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"rejected\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejected()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.rejected;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejectedWithValue() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    var hasFlag = function(action) {\n        return action && action.meta && action.meta.rejectedWithValue;\n    };\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\n            return combinedMatcher(action);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejectedWithValue()(asyncThunks[0]);\n    }\n    return function(action) {\n        var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);\n        return combinedMatcher(action);\n    };\n}\nfunction isFulfilled() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"fulfilled\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isFulfilled()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = asyncThunks.map(function(asyncThunk) {\n            return asyncThunk.fulfilled;\n        });\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isAsyncThunkAction() {\n    var asyncThunks = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        asyncThunks[_i] = arguments[_i];\n    }\n    if (asyncThunks.length === 0) {\n        return function(action) {\n            return hasExpectedRequestMetadata(action, [\n                \"pending\",\n                \"fulfilled\",\n                \"rejected\"\n            ]);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isAsyncThunkAction()(asyncThunks[0]);\n    }\n    return function(action) {\n        var matchers = [];\n        for(var _i = 0, asyncThunks_1 = asyncThunks; _i < asyncThunks_1.length; _i++){\n            var asyncThunk = asyncThunks_1[_i];\n            matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);\n        }\n        var combinedMatcher = isAnyOf.apply(void 0, matchers);\n        return combinedMatcher(action);\n    };\n}\n// src/listenerMiddleware/utils.ts\nvar assertFunction = function(func, expected) {\n    if (typeof func !== \"function\") {\n        throw new TypeError(expected + \" is not a function\");\n    }\n};\nvar noop = function() {};\nvar catchRejection = function(promise2, onError) {\n    if (onError === void 0) {\n        onError = noop;\n    }\n    promise2.catch(onError);\n    return promise2;\n};\nvar addAbortSignalListener = function(abortSignal, callback) {\n    abortSignal.addEventListener(\"abort\", callback, {\n        once: true\n    });\n    return function() {\n        return abortSignal.removeEventListener(\"abort\", callback);\n    };\n};\nvar abortControllerWithReason = function(abortController, reason) {\n    var signal = abortController.signal;\n    if (signal.aborted) {\n        return;\n    }\n    if (!(\"reason\" in signal)) {\n        Object.defineProperty(signal, \"reason\", {\n            enumerable: true,\n            value: reason,\n            configurable: true,\n            writable: true\n        });\n    }\n    ;\n    abortController.abort(reason);\n};\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = \"task-\" + cancelled;\nvar taskCompleted = \"task-\" + completed;\nvar listenerCancelled = listener + \"-\" + cancelled;\nvar listenerCompleted = listener + \"-\" + completed;\nvar TaskAbortError = /** @class */ function() {\n    function TaskAbortError(code) {\n        this.code = code;\n        this.name = \"TaskAbortError\";\n        this.message = task + \" \" + cancelled + \" (reason: \" + code + \")\";\n    }\n    return TaskAbortError;\n}();\n// src/listenerMiddleware/task.ts\nvar validateActive = function(signal) {\n    if (signal.aborted) {\n        throw new TaskAbortError(signal.reason);\n    }\n};\nfunction raceWithSignal(signal, promise2) {\n    var cleanup = noop;\n    return new Promise(function(resolve, reject) {\n        var notifyRejection = function() {\n            return reject(new TaskAbortError(signal.reason));\n        };\n        if (signal.aborted) {\n            notifyRejection();\n            return;\n        }\n        cleanup = addAbortSignalListener(signal, notifyRejection);\n        promise2.finally(function() {\n            return cleanup();\n        }).then(resolve, reject);\n    }).finally(function() {\n        cleanup = noop;\n    });\n}\nvar runTask = function(task2, cleanUp) {\n    return __async(void 0, null, function() {\n        var value, error_1;\n        return __generator(this, function(_c) {\n            switch(_c.label){\n                case 0:\n                    _c.trys.push([\n                        0,\n                        3,\n                        4,\n                        5\n                    ]);\n                    return [\n                        4 /*yield*/ ,\n                        Promise.resolve()\n                    ];\n                case 1:\n                    _c.sent();\n                    return [\n                        4 /*yield*/ ,\n                        task2()\n                    ];\n                case 2:\n                    value = _c.sent();\n                    return [\n                        2 /*return*/ ,\n                        {\n                            status: \"ok\",\n                            value: value\n                        }\n                    ];\n                case 3:\n                    error_1 = _c.sent();\n                    return [\n                        2 /*return*/ ,\n                        {\n                            status: error_1 instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n                            error: error_1\n                        }\n                    ];\n                case 4:\n                    cleanUp == null ? void 0 : cleanUp();\n                    return [\n                        7 /*endfinally*/ \n                    ];\n                case 5:\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    });\n};\nvar createPause = function(signal) {\n    return function(promise2) {\n        return catchRejection(raceWithSignal(signal, promise2).then(function(output) {\n            validateActive(signal);\n            return output;\n        }));\n    };\n};\nvar createDelay = function(signal) {\n    var pause = createPause(signal);\n    return function(timeoutMs) {\n        return pause(new Promise(function(resolve) {\n            return setTimeout(resolve, timeoutMs);\n        }));\n    };\n};\n// src/listenerMiddleware/index.ts\nvar assign = Object.assign;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = function(parentAbortSignal, parentBlockingPromises) {\n    var linkControllers = function(controller) {\n        return addAbortSignalListener(parentAbortSignal, function() {\n            return abortControllerWithReason(controller, parentAbortSignal.reason);\n        });\n    };\n    return function(taskExecutor, opts) {\n        assertFunction(taskExecutor, \"taskExecutor\");\n        var childAbortController = new AbortController();\n        linkControllers(childAbortController);\n        var result = runTask(function() {\n            return __async(void 0, null, function() {\n                var result2;\n                return __generator(this, function(_c) {\n                    switch(_c.label){\n                        case 0:\n                            validateActive(parentAbortSignal);\n                            validateActive(childAbortController.signal);\n                            return [\n                                4 /*yield*/ ,\n                                taskExecutor({\n                                    pause: createPause(childAbortController.signal),\n                                    delay: createDelay(childAbortController.signal),\n                                    signal: childAbortController.signal\n                                })\n                            ];\n                        case 1:\n                            result2 = _c.sent();\n                            validateActive(childAbortController.signal);\n                            return [\n                                2 /*return*/ ,\n                                result2\n                            ];\n                    }\n                });\n            });\n        }, function() {\n            return abortControllerWithReason(childAbortController, taskCompleted);\n        });\n        if (opts == null ? void 0 : opts.autoJoin) {\n            parentBlockingPromises.push(result);\n        }\n        return {\n            result: createPause(parentAbortSignal)(result),\n            cancel: function() {\n                abortControllerWithReason(childAbortController, taskCancelled);\n            }\n        };\n    };\n};\nvar createTakePattern = function(startListening, signal) {\n    var take = function(predicate, timeout) {\n        return __async(void 0, null, function() {\n            var unsubscribe, tuplePromise, promises, output;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        validateActive(signal);\n                        unsubscribe = function() {};\n                        tuplePromise = new Promise(function(resolve, reject) {\n                            var stopListening = startListening({\n                                predicate: predicate,\n                                effect: function(action, listenerApi) {\n                                    listenerApi.unsubscribe();\n                                    resolve([\n                                        action,\n                                        listenerApi.getState(),\n                                        listenerApi.getOriginalState()\n                                    ]);\n                                }\n                            });\n                            unsubscribe = function() {\n                                stopListening();\n                                reject();\n                            };\n                        });\n                        promises = [\n                            tuplePromise\n                        ];\n                        if (timeout != null) {\n                            promises.push(new Promise(function(resolve) {\n                                return setTimeout(resolve, timeout, null);\n                            }));\n                        }\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([\n                            1,\n                            ,\n                            3,\n                            4\n                        ]);\n                        return [\n                            4 /*yield*/ ,\n                            raceWithSignal(signal, Promise.race(promises))\n                        ];\n                    case 2:\n                        output = _c.sent();\n                        validateActive(signal);\n                        return [\n                            2 /*return*/ ,\n                            output\n                        ];\n                    case 3:\n                        unsubscribe();\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 4:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    return function(predicate, timeout) {\n        return catchRejection(take(predicate, timeout));\n    };\n};\nvar getListenerEntryPropsFrom = function(options) {\n    var type = options.type, actionCreator = options.actionCreator, matcher = options.matcher, predicate = options.predicate, effect = options.effect;\n    if (type) {\n        predicate = createAction(type).match;\n    } else if (actionCreator) {\n        type = actionCreator.type;\n        predicate = actionCreator.match;\n    } else if (matcher) {\n        predicate = matcher;\n    } else if (predicate) {} else {\n        throw new Error(\"Creating or removing a listener requires one of the known fields for matching an action\");\n    }\n    assertFunction(effect, \"options.listener\");\n    return {\n        predicate: predicate,\n        type: type,\n        effect: effect\n    };\n};\nvar createListenerEntry = function(options) {\n    var _c = getListenerEntryPropsFrom(options), type = _c.type, predicate = _c.predicate, effect = _c.effect;\n    var id = nanoid();\n    var entry = {\n        id: id,\n        effect: effect,\n        type: type,\n        predicate: predicate,\n        pending: new Set(),\n        unsubscribe: function() {\n            throw new Error(\"Unsubscribe not initialized\");\n        }\n    };\n    return entry;\n};\nvar cancelActiveListeners = function(entry) {\n    entry.pending.forEach(function(controller) {\n        abortControllerWithReason(controller, listenerCancelled);\n    });\n};\nvar createClearListenerMiddleware = function(listenerMap) {\n    return function() {\n        listenerMap.forEach(cancelActiveListeners);\n        listenerMap.clear();\n    };\n};\nvar safelyNotifyError = function(errorHandler, errorToNotify, errorInfo) {\n    try {\n        errorHandler(errorToNotify, errorInfo);\n    } catch (errorHandlerError) {\n        setTimeout(function() {\n            throw errorHandlerError;\n        }, 0);\n    }\n};\nvar addListener = createAction(alm + \"/add\");\nvar clearAllListeners = createAction(alm + \"/removeAll\");\nvar removeListener = createAction(alm + \"/remove\");\nvar defaultErrorHandler = function() {\n    var args = [];\n    for(var _i = 0; _i < arguments.length; _i++){\n        args[_i] = arguments[_i];\n    }\n    console.error.apply(console, __spreadArray([\n        alm + \"/error\"\n    ], args));\n};\nfunction createListenerMiddleware(middlewareOptions) {\n    var _this = this;\n    if (middlewareOptions === void 0) {\n        middlewareOptions = {};\n    }\n    var listenerMap = new Map();\n    var extra = middlewareOptions.extra, _c = middlewareOptions.onError, onError = _c === void 0 ? defaultErrorHandler : _c;\n    assertFunction(onError, \"onError\");\n    var insertEntry = function(entry) {\n        entry.unsubscribe = function() {\n            return listenerMap.delete(entry.id);\n        };\n        listenerMap.set(entry.id, entry);\n        return function(cancelOptions) {\n            entry.unsubscribe();\n            if (cancelOptions == null ? void 0 : cancelOptions.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        };\n    };\n    var findListenerEntry = function(comparator) {\n        for(var _i = 0, _c = Array.from(listenerMap.values()); _i < _c.length; _i++){\n            var entry = _c[_i];\n            if (comparator(entry)) {\n                return entry;\n            }\n        }\n        return void 0;\n    };\n    var startListening = function(options) {\n        var entry = findListenerEntry(function(existingEntry) {\n            return existingEntry.effect === options.effect;\n        });\n        if (!entry) {\n            entry = createListenerEntry(options);\n        }\n        return insertEntry(entry);\n    };\n    var stopListening = function(options) {\n        var _c = getListenerEntryPropsFrom(options), type = _c.type, effect = _c.effect, predicate = _c.predicate;\n        var entry = findListenerEntry(function(entry2) {\n            var matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n            return matchPredicateOrType && entry2.effect === effect;\n        });\n        if (entry) {\n            entry.unsubscribe();\n            if (options.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        }\n        return !!entry;\n    };\n    var notifyListener = function(entry, action, api, getOriginalState) {\n        return __async(_this, null, function() {\n            var internalTaskController, take, autoJoinPromises, listenerError_1;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        internalTaskController = new AbortController();\n                        take = createTakePattern(startListening, internalTaskController.signal);\n                        autoJoinPromises = [];\n                        _c.label = 1;\n                    case 1:\n                        _c.trys.push([\n                            1,\n                            3,\n                            4,\n                            6\n                        ]);\n                        entry.pending.add(internalTaskController);\n                        return [\n                            4 /*yield*/ ,\n                            Promise.resolve(entry.effect(action, assign({}, api, {\n                                getOriginalState: getOriginalState,\n                                condition: function(predicate, timeout) {\n                                    return take(predicate, timeout).then(Boolean);\n                                },\n                                take: take,\n                                delay: createDelay(internalTaskController.signal),\n                                pause: createPause(internalTaskController.signal),\n                                extra: extra,\n                                signal: internalTaskController.signal,\n                                fork: createFork(internalTaskController.signal, autoJoinPromises),\n                                unsubscribe: entry.unsubscribe,\n                                subscribe: function() {\n                                    listenerMap.set(entry.id, entry);\n                                },\n                                cancelActiveListeners: function() {\n                                    entry.pending.forEach(function(controller, _, set) {\n                                        if (controller !== internalTaskController) {\n                                            abortControllerWithReason(controller, listenerCancelled);\n                                            set.delete(controller);\n                                        }\n                                    });\n                                }\n                            })))\n                        ];\n                    case 2:\n                        _c.sent();\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 3:\n                        listenerError_1 = _c.sent();\n                        if (!(listenerError_1 instanceof TaskAbortError)) {\n                            safelyNotifyError(onError, listenerError_1, {\n                                raisedBy: \"effect\"\n                            });\n                        }\n                        return [\n                            3 /*break*/ ,\n                            6\n                        ];\n                    case 4:\n                        return [\n                            4 /*yield*/ ,\n                            Promise.allSettled(autoJoinPromises)\n                        ];\n                    case 5:\n                        _c.sent();\n                        abortControllerWithReason(internalTaskController, listenerCompleted);\n                        entry.pending.delete(internalTaskController);\n                        return [\n                            7 /*endfinally*/ \n                        ];\n                    case 6:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    var clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n    var middleware = function(api) {\n        return function(next) {\n            return function(action) {\n                if (!isAction(action)) {\n                    return next(action);\n                }\n                if (addListener.match(action)) {\n                    return startListening(action.payload);\n                }\n                if (clearAllListeners.match(action)) {\n                    clearListenerMiddleware();\n                    return;\n                }\n                if (removeListener.match(action)) {\n                    return stopListening(action.payload);\n                }\n                var originalState = api.getState();\n                var getOriginalState = function() {\n                    if (originalState === INTERNAL_NIL_TOKEN) {\n                        throw new Error(alm + \": getOriginalState can only be called synchronously\");\n                    }\n                    return originalState;\n                };\n                var result;\n                try {\n                    result = next(action);\n                    if (listenerMap.size > 0) {\n                        var currentState = api.getState();\n                        var listenerEntries = Array.from(listenerMap.values());\n                        for(var _i = 0, listenerEntries_1 = listenerEntries; _i < listenerEntries_1.length; _i++){\n                            var entry = listenerEntries_1[_i];\n                            var runListener = false;\n                            try {\n                                runListener = entry.predicate(action, currentState, originalState);\n                            } catch (predicateError) {\n                                runListener = false;\n                                safelyNotifyError(onError, predicateError, {\n                                    raisedBy: \"predicate\"\n                                });\n                            }\n                            if (!runListener) {\n                                continue;\n                            }\n                            notifyListener(entry, action, api, getOriginalState);\n                        }\n                    }\n                } finally{\n                    originalState = INTERNAL_NIL_TOKEN;\n                }\n                return result;\n            };\n        };\n    };\n    return {\n        middleware: middleware,\n        startListening: startListening,\n        stopListening: stopListening,\n        clearListeners: clearListenerMiddleware\n    };\n}\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = function() {\n    return function(payload) {\n        var _c;\n        return {\n            payload: payload,\n            meta: (_c = {}, _c[SHOULD_AUTOBATCH] = true, _c)\n        };\n    };\n};\nvar promise;\nvar queueMicrotaskShim = typeof queueMicrotask === \"function\" ? queueMicrotask.bind( false ? 0 : typeof global !== \"undefined\" ? global : globalThis) : function(cb) {\n    return (promise || (promise = Promise.resolve())).then(cb).catch(function(err) {\n        return setTimeout(function() {\n            throw err;\n        }, 0);\n    });\n};\nvar createQueueWithTimer = function(timeout) {\n    return function(notify) {\n        setTimeout(notify, timeout);\n    };\n};\nvar rAF =  false ? 0 : createQueueWithTimer(10);\nvar autoBatchEnhancer = function(options) {\n    if (options === void 0) {\n        options = {\n            type: \"raf\"\n        };\n    }\n    return function(next) {\n        return function() {\n            var args = [];\n            for(var _i = 0; _i < arguments.length; _i++){\n                args[_i] = arguments[_i];\n            }\n            var store = next.apply(void 0, args);\n            var notifying = true;\n            var shouldNotifyAtEndOfTick = false;\n            var notificationQueued = false;\n            var listeners = new Set();\n            var queueCallback = options.type === \"tick\" ? queueMicrotaskShim : options.type === \"raf\" ? rAF : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n            var notifyListeners = function() {\n                notificationQueued = false;\n                if (shouldNotifyAtEndOfTick) {\n                    shouldNotifyAtEndOfTick = false;\n                    listeners.forEach(function(l) {\n                        return l();\n                    });\n                }\n            };\n            return Object.assign({}, store, {\n                subscribe: function(listener2) {\n                    var wrappedListener = function() {\n                        return notifying && listener2();\n                    };\n                    var unsubscribe = store.subscribe(wrappedListener);\n                    listeners.add(listener2);\n                    return function() {\n                        unsubscribe();\n                        listeners.delete(listener2);\n                    };\n                },\n                dispatch: function(action) {\n                    var _a;\n                    try {\n                        notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);\n                        shouldNotifyAtEndOfTick = !notifying;\n                        if (shouldNotifyAtEndOfTick) {\n                            if (!notificationQueued) {\n                                notificationQueued = true;\n                                queueCallback(notifyListeners);\n                            }\n                        }\n                        return store.dispatch(action);\n                    } finally{\n                        notifying = true;\n                    }\n                }\n            });\n        };\n    };\n};\n// src/index.ts\n(0,immer__WEBPACK_IMPORTED_MODULE_2__.enableES5)();\n //# sourceMappingURL=redux-toolkit.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUs7SUFDeEMsSUFBSUMsZ0JBQWdCLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztRQUM5QkYsZ0JBQWdCRyxPQUFPQyxjQUFjLElBQ2hDO1lBQUVDLFdBQVcsRUFBRTtRQUFDLGNBQWFDLFNBQVMsU0FBVUwsQ0FBQyxFQUFFQyxDQUFDO1lBQUlELEVBQUVJLFNBQVMsR0FBR0g7UUFBRyxLQUMxRSxTQUFVRCxDQUFDLEVBQUVDLENBQUM7WUFBSSxJQUFLLElBQUlLLEtBQUtMLEVBQUcsSUFBSUMsT0FBT0ssU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1IsR0FBR0ssSUFBSU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtRQUFFO1FBQ3BHLE9BQU9QLGNBQWNDLEdBQUdDO0lBQzVCO0lBQ0EsT0FBTyxTQUFVRCxDQUFDLEVBQUVDLENBQUM7UUFDakIsSUFBSSxPQUFPQSxNQUFNLGNBQWNBLE1BQU0sTUFDakMsTUFBTSxJQUFJUyxVQUFVLHlCQUF5QkMsT0FBT1YsS0FBSztRQUM3REYsY0FBY0MsR0FBR0M7UUFDakIsU0FBU1c7WUFBTyxJQUFJLENBQUNDLFdBQVcsR0FBR2I7UUFBRztRQUN0Q0EsRUFBRU8sU0FBUyxHQUFHTixNQUFNLE9BQU9DLE9BQU9ZLE1BQU0sQ0FBQ2IsS0FBTVcsQ0FBQUEsR0FBR0wsU0FBUyxHQUFHTixFQUFFTSxTQUFTLEVBQUUsSUFBSUssSUFBRztJQUN0RjtBQUNKO0FBQ0EsSUFBSUcsY0FBYyxTQUFLLElBQUksU0FBSSxDQUFDQSxXQUFXLElBQUssU0FBVUMsT0FBTyxFQUFFQyxJQUFJ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U0FBVWtDLFNBQVM7b0JBQzFCLElBQUlDLGtCQUFrQjt3QkFBYyxPQUFPVCxhQUFhUTtvQkFBYTtvQkFDckUsSUFBSTdFLGNBQWNvRSxNQUFNekIsU0FBUyxDQUFDbUM7b0JBQ2xDTixVQUFVN2IsR0FBRyxDQUFDa2M7b0JBQ2QsT0FBTzt3QkFDSDdFO3dCQUNBd0UsVUFBVTdDLE1BQU0sQ0FBQ2tEO29CQUNyQjtnQkFDSjtnQkFDQS9LLFVBQVUsU0FBVTlWLE1BQU07b0JBQ3RCLElBQUlvVztvQkFDSixJQUFJO3dCQUNBaUssWUFBWSxDQUFFLEVBQUNqSyxLQUFLcFcsVUFBVSxPQUFPLEtBQUssSUFBSUEsT0FBT0gsSUFBSSxLQUFLLE9BQU8sS0FBSyxJQUFJdVcsRUFBRSxDQUFDa0osaUJBQWlCO3dCQUNsR2dCLDBCQUEwQixDQUFDRDt3QkFDM0IsSUFBSUMseUJBQXlCOzRCQUN6QixJQUFJLENBQUNDLG9CQUFvQjtnQ0FDckJBLHFCQUFxQjtnQ0FDckJFLGNBQWNFOzRCQUNsQjt3QkFDSjt3QkFDQSxPQUFPUCxNQUFNdEssUUFBUSxDQUFDOVY7b0JBQzFCLFNBQ1E7d0JBQ0pxZ0IsWUFBWTtvQkFDaEI7Z0JBQ0o7WUFDSjtRQUNKO0lBQUc7QUFDUDtBQUNBLGVBQWU7QUFDZmxqQixnREFBU0E7QUFDKzBCLENBQ3gxQiw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYWdlLnN0b3JlLy4vbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvZGlzdC9yZWR1eC10b29sa2l0LmVzbS5qcz84Y2NjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn07XHJcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20pIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxyXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcclxuICAgIHJldHVybiB0bztcclxufTtcclxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcclxudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcclxudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XHJcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcclxudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xyXG52YXIgX19kZWZOb3JtYWxQcm9wID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlOyB9O1xyXG52YXIgX19zcHJlYWRWYWx1ZXMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxyXG4gICAgICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcclxuICAgICAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xyXG4gICAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYyA9IF9fZ2V0T3duUHJvcFN5bWJvbHMoYik7IF9pIDwgX2MubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wID0gX2NbX2ldO1xyXG4gICAgICAgICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXHJcbiAgICAgICAgICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn07XHJcbnZhciBfX3NwcmVhZFByb3BzID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpOyB9O1xyXG52YXIgX19hc3luYyA9IGZ1bmN0aW9uIChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdmFyIGZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH07XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbi8vIHNyYy9pbmRleC50c1xyXG5pbXBvcnQgeyBlbmFibGVFUzUgfSBmcm9tIFwiaW1tZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcInJlZHV4XCI7XHJcbmltcG9ydCB7IGRlZmF1bHQgYXMgZGVmYXVsdDIsIGN1cnJlbnQgYXMgY3VycmVudDIsIGZyZWV6ZSwgb3JpZ2luYWwsIGlzRHJhZnQgYXMgaXNEcmFmdDQgfSBmcm9tIFwiaW1tZXJcIjtcclxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgYXMgY3JlYXRlU2VsZWN0b3IyIH0gZnJvbSBcInJlc2VsZWN0XCI7XHJcbi8vIHNyYy9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvci50c1xyXG5pbXBvcnQgeyBjdXJyZW50LCBpc0RyYWZ0IH0gZnJvbSBcImltbWVyXCI7XHJcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSBcInJlc2VsZWN0XCI7XHJcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yLmFwcGx5KHZvaWQgMCwgYXJncyk7XHJcbiAgICB2YXIgd3JhcHBlZFNlbGVjdG9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHJlc3QgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICByZXN0W19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VsZWN0b3IuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWVdLCByZXN0KSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvcjtcclxufTtcclxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXHJcbmltcG9ydCB7IGNyZWF0ZVN0b3JlLCBjb21wb3NlIGFzIGNvbXBvc2UyLCBhcHBseU1pZGRsZXdhcmUsIGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gXCJyZWR1eFwiO1xyXG4vLyBzcmMvZGV2dG9vbHNFeHRlbnNpb24udHNcclxuaW1wb3J0IHsgY29tcG9zZSB9IGZyb20gXCJyZWR1eFwiO1xyXG52YXIgY29tcG9zZVdpdGhEZXZUb29scyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2U7XHJcbiAgICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59O1xyXG52YXIgZGV2VG9vbHNFbmhhbmNlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobm9vcDIpIHtcclxuICAgICAgICByZXR1cm4gbm9vcDI7XHJcbiAgICB9O1xyXG59O1xyXG4vLyBzcmMvaXNQbGFpbk9iamVjdC50c1xyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XHJcbiAgICBpZiAocHJvdG8gPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB2YXIgYmFzZVByb3RvID0gcHJvdG87XHJcbiAgICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90bykgIT09IG51bGwpIHtcclxuICAgICAgICBiYXNlUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm90byA9PT0gYmFzZVByb3RvO1xyXG59XHJcbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xyXG5pbXBvcnQgdGh1bmtNaWRkbGV3YXJlIGZyb20gXCJyZWR1eC10aHVua1wiO1xyXG4vLyBzcmMvdHNIZWxwZXJzLnRzXHJcbnZhciBoYXNNYXRjaEZ1bmN0aW9uID0gZnVuY3Rpb24gKHYpIHtcclxuICAgIHJldHVybiB2ICYmIHR5cGVvZiB2Lm1hdGNoID09PSBcImZ1bmN0aW9uXCI7XHJcbn07XHJcbi8vIHNyYy9jcmVhdGVBY3Rpb24udHNcclxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVBY3Rpb24pIHtcclxuICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmVwYXJlQWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBwcmVwYXJlZCA9IHByZXBhcmVBY3Rpb24uYXBwbHkodm9pZCAwLCBhcmdzKTtcclxuICAgICAgICAgICAgaWYgKCFwcmVwYXJlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJlcGFyZUFjdGlvbiBkaWQgbm90IHJldHVybiBhbiBvYmplY3RcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBwcmVwYXJlZC5wYXlsb2FkXHJcbiAgICAgICAgICAgIH0sIFwibWV0YVwiIGluIHByZXBhcmVkICYmIHsgbWV0YTogcHJlcGFyZWQubWV0YSB9KSwgXCJlcnJvclwiIGluIHByZXBhcmVkICYmIHsgZXJyb3I6IHByZXBhcmVkLmVycm9yIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBhcmdzWzBdIH07XHJcbiAgICB9XHJcbiAgICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJcIiArIHR5cGU7IH07XHJcbiAgICBhY3Rpb25DcmVhdG9yLnR5cGUgPSB0eXBlO1xyXG4gICAgYWN0aW9uQ3JlYXRvci5tYXRjaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGFjdGlvbi50eXBlID09PSB0eXBlOyB9O1xyXG4gICAgcmV0dXJuIGFjdGlvbkNyZWF0b3I7XHJcbn1cclxuZnVuY3Rpb24gaXNBY3Rpb24oYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdChhY3Rpb24pICYmIFwidHlwZVwiIGluIGFjdGlvbjtcclxufVxyXG5mdW5jdGlvbiBpc0FjdGlvbkNyZWF0b3IoYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gXCJmdW5jdGlvblwiICYmIFwidHlwZVwiIGluIGFjdGlvbiAmJiBoYXNNYXRjaEZ1bmN0aW9uKGFjdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gaXNGU0EoYWN0aW9uKSB7XHJcbiAgICByZXR1cm4gaXNBY3Rpb24oYWN0aW9uKSAmJiB0eXBlb2YgYWN0aW9uLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcclxufVxyXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIFtcInR5cGVcIiwgXCJwYXlsb2FkXCIsIFwiZXJyb3JcIiwgXCJtZXRhXCJdLmluZGV4T2Yoa2V5KSA+IC0xO1xyXG59XHJcbmZ1bmN0aW9uIGdldFR5cGUoYWN0aW9uQ3JlYXRvcikge1xyXG4gICAgcmV0dXJuIFwiXCIgKyBhY3Rpb25DcmVhdG9yO1xyXG59XHJcbi8vIHNyYy9hY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZS50c1xyXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHR5cGUpIHtcclxuICAgIHZhciBzcGxpdFR5cGUgPSB0eXBlID8gKFwiXCIgKyB0eXBlKS5zcGxpdChcIi9cIikgOiBbXTtcclxuICAgIHZhciBhY3Rpb25OYW1lID0gc3BsaXRUeXBlW3NwbGl0VHlwZS5sZW5ndGggLSAxXSB8fCBcImFjdGlvbkNyZWF0b3JcIjtcclxuICAgIHJldHVybiBcIkRldGVjdGVkIGFuIGFjdGlvbiBjcmVhdG9yIHdpdGggdHlwZSBcXFwiXCIgKyAodHlwZSB8fCBcInVua25vd25cIikgKyBcIlxcXCIgYmVpbmcgZGlzcGF0Y2hlZC4gXFxuTWFrZSBzdXJlIHlvdSdyZSBjYWxsaW5nIHRoZSBhY3Rpb24gY3JlYXRvciBiZWZvcmUgZGlzcGF0Y2hpbmcsIGkuZS4gYGRpc3BhdGNoKFwiICsgYWN0aW9uTmFtZSArIFwiKCkpYCBpbnN0ZWFkIG9mIGBkaXNwYXRjaChcIiArIGFjdGlvbk5hbWUgKyBcIilgLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBhY3Rpb24gaGFzIG5vIHBheWxvYWQuXCI7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUob3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIG5leHQoYWN0aW9uKTsgfTsgfTsgfTtcclxuICAgIH1cclxuICAgIHZhciBfYyA9IG9wdGlvbnMuaXNBY3Rpb25DcmVhdG9yLCBpc0FjdGlvbkNyZWF0b3IyID0gX2MgPT09IHZvaWQgMCA/IGlzQWN0aW9uQ3JlYXRvciA6IF9jO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGlzQWN0aW9uQ3JlYXRvcjIoYWN0aW9uKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZ2V0TWVzc2FnZShhY3Rpb24udHlwZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xyXG4gICAgfTsgfTsgfTtcclxufVxyXG4vLyBzcmMvdXRpbHMudHNcclxuaW1wb3J0IGNyZWF0ZU5leHRTdGF0ZSwgeyBpc0RyYWZ0YWJsZSB9IGZyb20gXCJpbW1lclwiO1xyXG5mdW5jdGlvbiBnZXRUaW1lTWVhc3VyZVV0aWxzKG1heERlbGF5LCBmbk5hbWUpIHtcclxuICAgIHZhciBlbGFwc2VkID0gMDtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWVhc3VyZVRpbWU6IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRlZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHZhciBmaW5pc2hlZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICBlbGFwc2VkICs9IGZpbmlzaGVkIC0gc3RhcnRlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2FybklmRXhjZWVkZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGVsYXBzZWQgPiBtYXhEZWxheSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGZuTmFtZSArIFwiIHRvb2sgXCIgKyBlbGFwc2VkICsgXCJtcywgd2hpY2ggaXMgbW9yZSB0aGFuIHRoZSB3YXJuaW5nIHRocmVzaG9sZCBvZiBcIiArIG1heERlbGF5ICsgXCJtcy4gXFxuSWYgeW91ciBzdGF0ZSBvciBhY3Rpb25zIGFyZSB2ZXJ5IGxhcmdlLCB5b3UgbWF5IHdhbnQgdG8gZGlzYWJsZSB0aGUgbWlkZGxld2FyZSBhcyBpdCBtaWdodCBjYXVzZSB0b28gbXVjaCBvZiBhIHNsb3dkb3duIGluIGRldmVsb3BtZW50IG1vZGUuIFNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9nZXREZWZhdWx0TWlkZGxld2FyZSBmb3IgaW5zdHJ1Y3Rpb25zLlxcbkl0IGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLCBzbyB5b3UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGF0LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxudmFyIE1pZGRsZXdhcmVBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNaWRkbGV3YXJlQXJyYXksIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNaWRkbGV3YXJlQXJyYXkoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmdzKSB8fCB0aGlzO1xyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgTWlkZGxld2FyZUFycmF5LnByb3RvdHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1pZGRsZXdhcmVBcnJheSwgU3ltYm9sLnNwZWNpZXMsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1pZGRsZXdhcmVBcnJheTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNaWRkbGV3YXJlQXJyYXkucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xyXG4gICAgfTtcclxuICAgIE1pZGRsZXdhcmVBcnJheS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcnIubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyWzBdKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IChNaWRkbGV3YXJlQXJyYXkuYmluZC5hcHBseShNaWRkbGV3YXJlQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyclswXS5jb25jYXQodGhpcykpKSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoTWlkZGxld2FyZUFycmF5LmJpbmQuYXBwbHkoTWlkZGxld2FyZUFycmF5LCBfX3NwcmVhZEFycmF5KFt2b2lkIDBdLCBhcnIuY29uY2F0KHRoaXMpKSkpKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1pZGRsZXdhcmVBcnJheTtcclxufShBcnJheSkpO1xyXG52YXIgRW5oYW5jZXJBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFbmhhbmNlckFycmF5LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRW5oYW5jZXJBcnJheSgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3MpIHx8IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBFbmhhbmNlckFycmF5LnByb3RvdHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVuaGFuY2VyQXJyYXksIFN5bWJvbC5zcGVjaWVzLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFbmhhbmNlckFycmF5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEVuaGFuY2VyQXJyYXkucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJyW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xyXG4gICAgfTtcclxuICAgIEVuaGFuY2VyQXJyYXkucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFycltfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyclswXSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyAoRW5oYW5jZXJBcnJheS5iaW5kLmFwcGx5KEVuaGFuY2VyQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyclswXS5jb25jYXQodGhpcykpKSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoRW5oYW5jZXJBcnJheS5iaW5kLmFwcGx5KEVuaGFuY2VyQXJyYXksIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyci5jb25jYXQodGhpcykpKSkoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW5oYW5jZXJBcnJheTtcclxufShBcnJheSkpO1xyXG5mdW5jdGlvbiBmcmVlemVEcmFmdGFibGUodmFsKSB7XHJcbiAgICByZXR1cm4gaXNEcmFmdGFibGUodmFsKSA/IGNyZWF0ZU5leHRTdGF0ZSh2YWwsIGZ1bmN0aW9uICgpIHtcclxuICAgIH0pIDogdmFsO1xyXG59XHJcbi8vIHNyYy9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcclxudmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcclxudmFyIHByZWZpeCA9IFwiSW52YXJpYW50IGZhaWxlZFwiO1xyXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XHJcbiAgICBpZiAoY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXgpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArIFwiOiBcIiArIChtZXNzYWdlIHx8IFwiXCIpKTtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCBzZXJpYWxpemVyLCBpbmRlbnQsIGRlY3ljbGVyKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBnZXRTZXJpYWxpemUoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFNlcmlhbGl6ZShzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xyXG4gICAgdmFyIHN0YWNrID0gW10sIGtleXMgPSBbXTtcclxuICAgIGlmICghZGVjeWNsZXIpXHJcbiAgICAgICAgZGVjeWNsZXIgPSBmdW5jdGlvbiAoXywgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIltDaXJjdWxhciB+XVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfi5cIiArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oXCIuXCIpICsgXCJdXCI7XHJcbiAgICAgICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcclxuICAgICAgICAgICAgfnRoaXNQb3MgPyBrZXlzLnNwbGljZSh0aGlzUG9zLCBJbmZpbml0eSwga2V5KSA6IGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWN5Y2xlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09IG51bGwgfHwgT2JqZWN0LmlzRnJvemVuKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiB0cmFja0Zvck11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaikge1xyXG4gICAgdmFyIHRyYWNrZWRQcm9wZXJ0aWVzID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGV0ZWN0TXV0YXRpb25zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCB0cmFja2VkUHJvcGVydGllcywgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaiwgcGF0aCwgY2hlY2tlZE9iamVjdHMpIHtcclxuICAgIGlmIChpZ25vcmVQYXRocyA9PT0gdm9pZCAwKSB7IGlnbm9yZVBhdGhzID0gW107IH1cclxuICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IFwiXCI7IH1cclxuICAgIGlmIChjaGVja2VkT2JqZWN0cyA9PT0gdm9pZCAwKSB7IGNoZWNrZWRPYmplY3RzID0gbmV3IFNldCgpOyB9XHJcbiAgICB2YXIgdHJhY2tlZCA9IHsgdmFsdWU6IG9iaiB9O1xyXG4gICAgaWYgKCFpc0ltbXV0YWJsZShvYmopICYmICFjaGVja2VkT2JqZWN0cy5oYXMob2JqKSkge1xyXG4gICAgICAgIGNoZWNrZWRPYmplY3RzLmFkZChvYmopO1xyXG4gICAgICAgIHRyYWNrZWQuY2hpbGRyZW4gPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xyXG4gICAgICAgICAgICBpZiAoaWdub3JlUGF0aHMubGVuZ3RoICYmIGlnbm9yZVBhdGhzLmluZGV4T2YoY2hpbGRQYXRoKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyYWNrZWQuY2hpbGRyZW5ba2V5XSA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9ialtrZXldLCBjaGlsZFBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cmFja2VkO1xyXG59XHJcbmZ1bmN0aW9uIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzLCB0cmFja2VkUHJvcGVydHksIG9iaiwgc2FtZVBhcmVudFJlZiwgcGF0aCkge1xyXG4gICAgaWYgKGlnbm9yZWRQYXRocyA9PT0gdm9pZCAwKSB7IGlnbm9yZWRQYXRocyA9IFtdOyB9XHJcbiAgICBpZiAoc2FtZVBhcmVudFJlZiA9PT0gdm9pZCAwKSB7IHNhbWVQYXJlbnRSZWYgPSBmYWxzZTsgfVxyXG4gICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gXCJcIjsgfVxyXG4gICAgdmFyIHByZXZPYmogPSB0cmFja2VkUHJvcGVydHkgPyB0cmFja2VkUHJvcGVydHkudmFsdWUgOiB2b2lkIDA7XHJcbiAgICB2YXIgc2FtZVJlZiA9IHByZXZPYmogPT09IG9iajtcclxuICAgIGlmIChzYW1lUGFyZW50UmVmICYmICFzYW1lUmVmICYmICFOdW1iZXIuaXNOYU4ob2JqKSkge1xyXG4gICAgICAgIHJldHVybiB7IHdhc011dGF0ZWQ6IHRydWUsIHBhdGg6IHBhdGggfTtcclxuICAgIH1cclxuICAgIGlmIChpc0ltbXV0YWJsZShwcmV2T2JqKSB8fCBpc0ltbXV0YWJsZShvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2FzTXV0YXRlZDogZmFsc2UgfTtcclxuICAgIH1cclxuICAgIHZhciBrZXlzVG9EZXRlY3QgPSB7fTtcclxuICAgIGZvciAodmFyIGtleSBpbiB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW4pIHtcclxuICAgICAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xyXG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xyXG4gICAgICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcclxuICAgICAgICAgICAgdmFyIGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZShmdW5jdGlvbiAoaWdub3JlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaGFzTWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMsIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbltrZXldLCBvYmpba2V5XSwgc2FtZVJlZiwgbmVzdGVkUGF0aCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIGtleXNUb0RldGVjdCkge1xyXG4gICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMShrZXkpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGVfMSA9PT0gXCJvYmplY3RcIilcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlXzEudmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyB3YXNNdXRhdGVkOiBmYWxzZSB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAobmV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gbmV4dChhY3Rpb24pOyB9OyB9OyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIF9jID0gb3B0aW9ucy5pc0ltbXV0YWJsZSwgaXNJbW11dGFibGUgPSBfYyA9PT0gdm9pZCAwID8gaXNJbW11dGFibGVEZWZhdWx0IDogX2MsIGlnbm9yZWRQYXRocyA9IG9wdGlvbnMuaWdub3JlZFBhdGhzLCBfZCA9IG9wdGlvbnMud2FybkFmdGVyLCB3YXJuQWZ0ZXIgPSBfZCA9PT0gdm9pZCAwID8gMzIgOiBfZCwgaWdub3JlID0gb3B0aW9ucy5pZ25vcmU7XHJcbiAgICBpZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMgfHwgaWdub3JlO1xyXG4gICAgdmFyIHRyYWNrID0gdHJhY2tGb3JNdXRhdGlvbnMuYmluZChudWxsLCBpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICB2YXIgZ2V0U3RhdGUgPSBfYy5nZXRTdGF0ZTtcclxuICAgICAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZSgpO1xyXG4gICAgICAgIHZhciB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XHJcbiAgICAgICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIGludmFyaWFudCghcmVzdWx0Lndhc011dGF0ZWQsIFwiQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgYmV0d2VlbiBkaXNwYXRjaGVzLCBpbiB0aGUgcGF0aCAnXCIgKyAocmVzdWx0LnBhdGggfHwgXCJcIikgKyBcIicuICBUaGlzIG1heSBjYXVzZSBpbmNvcnJlY3QgYmVoYXZpb3IuIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKVwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBkaXNwYXRjaGVkQWN0aW9uID0gbmV4dChhY3Rpb24pO1xyXG4gICAgICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQud2FzTXV0YXRlZCAmJiBpbnZhcmlhbnQoIXJlc3VsdC53YXNNdXRhdGVkLCBcIkEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGluc2lkZSBhIGRpc3BhdGNoLCBpbiB0aGUgcGF0aDogXCIgKyAocmVzdWx0LnBhdGggfHwgXCJcIikgKyBcIi4gVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhlIGFjdGlvbiBcIiArIHN0cmluZ2lmeShhY3Rpb24pICsgXCIuIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKVwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hlZEFjdGlvbjtcclxuICAgICAgICB9OyB9O1xyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvc2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXHJcbmZ1bmN0aW9uIGlzUGxhaW4odmFsKSB7XHJcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XHJcbiAgICByZXR1cm4gdmFsID09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsKSB8fCBpc1BsYWluT2JqZWN0KHZhbCk7XHJcbn1cclxuZnVuY3Rpb24gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHZhbHVlLCBwYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSkge1xyXG4gICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gXCJcIjsgfVxyXG4gICAgaWYgKGlzU2VyaWFsaXphYmxlID09PSB2b2lkIDApIHsgaXNTZXJpYWxpemFibGUgPSBpc1BsYWluOyB9XHJcbiAgICBpZiAoaWdub3JlZFBhdGhzID09PSB2b2lkIDApIHsgaWdub3JlZFBhdGhzID0gW107IH1cclxuICAgIHZhciBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcclxuICAgIGlmICghaXNTZXJpYWxpemFibGUodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAga2V5UGF0aDogcGF0aCB8fCBcIjxyb290PlwiLFxyXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChjYWNoZSA9PSBudWxsID8gdm9pZCAwIDogY2FjaGUuaGFzKHZhbHVlKSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB2YXIgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xyXG4gICAgdmFyIGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xyXG4gICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoa2V5LCBuZXN0ZWRWYWx1ZSkge1xyXG4gICAgICAgIHZhciBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcclxuICAgICAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XHJcbiAgICAgICAgICAgIHZhciBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGhhc01hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1NlcmlhbGl6YWJsZShuZXN0ZWRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlQYXRoOiBuZXN0ZWRQYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxyXG4gICAgICAgICAgICAgICAgfSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5lc3RlZFZhbHVlLCBuZXN0ZWRQYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XHJcbiAgICAgICAgICAgIGlmIChmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBlbnRyaWVzXzEgPSBlbnRyaWVzOyBfaSA8IGVudHJpZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgX2MgPSBlbnRyaWVzXzFbX2ldLCBrZXkgPSBfY1swXSwgbmVzdGVkVmFsdWUgPSBfY1sxXTtcclxuICAgICAgICB2YXIgc3RhdGVfMiA9IF9sb29wXzIoa2V5LCBuZXN0ZWRWYWx1ZSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZV8yID09PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGVfMi52YWx1ZTtcclxuICAgIH1cclxuICAgIGlmIChjYWNoZSAmJiBpc05lc3RlZEZyb3plbih2YWx1ZSkpXHJcbiAgICAgICAgY2FjaGUuYWRkKHZhbHVlKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc05lc3RlZEZyb3plbih2YWx1ZSkge1xyXG4gICAgaWYgKCFPYmplY3QuaXNGcm96ZW4odmFsdWUpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgX2MgPSBPYmplY3QudmFsdWVzKHZhbHVlKTsgX2kgPCBfYy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgbmVzdGVkVmFsdWUgPSBfY1tfaV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXN0ZWRWYWx1ZSA9PT0gbnVsbClcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgaWYgKCFpc05lc3RlZEZyb3plbihuZXN0ZWRWYWx1ZSkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAobmV4dCkgeyByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gbmV4dChhY3Rpb24pOyB9OyB9OyB9O1xyXG4gICAgfVxyXG4gICAgdmFyIF9jID0gb3B0aW9ucy5pc1NlcmlhbGl6YWJsZSwgaXNTZXJpYWxpemFibGUgPSBfYyA9PT0gdm9pZCAwID8gaXNQbGFpbiA6IF9jLCBnZXRFbnRyaWVzID0gb3B0aW9ucy5nZXRFbnRyaWVzLCBfZCA9IG9wdGlvbnMuaWdub3JlZEFjdGlvbnMsIGlnbm9yZWRBY3Rpb25zID0gX2QgPT09IHZvaWQgMCA/IFtdIDogX2QsIF9lID0gb3B0aW9ucy5pZ25vcmVkQWN0aW9uUGF0aHMsIGlnbm9yZWRBY3Rpb25QYXRocyA9IF9lID09PSB2b2lkIDAgPyBbXCJtZXRhLmFyZ1wiLCBcIm1ldGEuYmFzZVF1ZXJ5TWV0YVwiXSA6IF9lLCBfZiA9IG9wdGlvbnMuaWdub3JlZFBhdGhzLCBpZ25vcmVkUGF0aHMgPSBfZiA9PT0gdm9pZCAwID8gW10gOiBfZiwgX2cgPSBvcHRpb25zLndhcm5BZnRlciwgd2FybkFmdGVyID0gX2cgPT09IHZvaWQgMCA/IDMyIDogX2csIF9oID0gb3B0aW9ucy5pZ25vcmVTdGF0ZSwgaWdub3JlU3RhdGUgPSBfaCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaCwgX2ogPSBvcHRpb25zLmlnbm9yZUFjdGlvbnMsIGlnbm9yZUFjdGlvbnMgPSBfaiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaiwgX2sgPSBvcHRpb25zLmRpc2FibGVDYWNoZSwgZGlzYWJsZUNhY2hlID0gX2sgPT09IHZvaWQgMCA/IGZhbHNlIDogX2s7XHJcbiAgICB2YXIgY2FjaGUgPSAhZGlzYWJsZUNhY2hlICYmIFdlYWtTZXQgPyBuZXcgV2Vha1NldCgpIDogdm9pZCAwO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZUFQSSkgeyByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xyXG4gICAgICAgIHZhciBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XHJcbiAgICAgICAgaWYgKCFpZ25vcmVBY3Rpb25zICYmICEoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocywgY2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5UGF0aCA9IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUua2V5UGF0aCwgdmFsdWUgPSBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgd2FzIGRldGVjdGVkIGluIGFuIGFjdGlvbiwgaW4gdGhlIHBhdGg6IGBcIiArIGtleVBhdGggKyBcImAuIFZhbHVlOlwiLCB2YWx1ZSwgXCJcXG5UYWtlIGEgbG9vayBhdCB0aGUgbG9naWMgdGhhdCBkaXNwYXRjaGVkIHRoaXMgYWN0aW9uOiBcIiwgYWN0aW9uLCBcIlxcbihTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvZmFxL2FjdGlvbnMjd2h5LXNob3VsZC10eXBlLWJlLWEtc3RyaW5nLW9yLWF0LWxlYXN0LXNlcmlhbGl6YWJsZS13aHktc2hvdWxkLW15LWFjdGlvbi10eXBlcy1iZS1jb25zdGFudHMpXCIsIFwiXFxuKFRvIGFsbG93IG5vbi1zZXJpYWxpemFibGUgdmFsdWVzIHNlZTogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy91c2FnZS91c2FnZS1ndWlkZSN3b3JraW5nLXdpdGgtbm9uLXNlcmlhbGl6YWJsZS1kYXRhKVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaWdub3JlU3RhdGUpIHtcclxuICAgICAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0b3JlQVBJLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHN0YXRlLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleVBhdGggPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUua2V5UGF0aCwgdmFsdWUgPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gdGhlIHN0YXRlLCBpbiB0aGUgcGF0aDogYFwiICsga2V5UGF0aCArIFwiYC4gVmFsdWU6XCIsIHZhbHVlLCBcIlxcblRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoaXMgYWN0aW9uIHR5cGU6IFwiICsgYWN0aW9uLnR5cGUgKyBcIi5cXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9vcmdhbml6aW5nLXN0YXRlI2Nhbi1pLXB1dC1mdW5jdGlvbnMtcHJvbWlzZXMtb3Itb3RoZXItbm9uLXNlcmlhbGl6YWJsZS1pdGVtcy1pbi1teS1zdG9yZS1zdGF0ZSlcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07IH07IH07XHJcbn1cclxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXHJcbmZ1bmN0aW9uIGlzQm9vbGVhbih4KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwiYm9vbGVhblwiO1xyXG59XHJcbmZ1bmN0aW9uIGN1cnJ5R2V0RGVmYXVsdE1pZGRsZXdhcmUoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdE1pZGRsZXdhcmUob3B0aW9ucyk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICB2YXIgX2MgPSBvcHRpb25zLnRodW5rLCB0aHVuayA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gb3B0aW9ucy5pbW11dGFibGVDaGVjaywgaW1tdXRhYmxlQ2hlY2sgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLCBfZSA9IG9wdGlvbnMuc2VyaWFsaXphYmxlQ2hlY2ssIHNlcmlhbGl6YWJsZUNoZWNrID0gX2UgPT09IHZvaWQgMCA/IHRydWUgOiBfZSwgX2YgPSBvcHRpb25zLmFjdGlvbkNyZWF0b3JDaGVjaywgYWN0aW9uQ3JlYXRvckNoZWNrID0gX2YgPT09IHZvaWQgMCA/IHRydWUgOiBfZjtcclxuICAgIHZhciBtaWRkbGV3YXJlQXJyYXkgPSBuZXcgTWlkZGxld2FyZUFycmF5KCk7XHJcbiAgICBpZiAodGh1bmspIHtcclxuICAgICAgICBpZiAoaXNCb29sZWFuKHRodW5rKSkge1xyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh0aHVua01pZGRsZXdhcmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2godGh1bmtNaWRkbGV3YXJlLndpdGhFeHRyYUFyZ3VtZW50KHRodW5rLmV4dHJhQXJndW1lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgaWYgKGltbXV0YWJsZUNoZWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbW11dGFibGVPcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIGlmICghaXNCb29sZWFuKGltbXV0YWJsZUNoZWNrKSkge1xyXG4gICAgICAgICAgICAgICAgaW1tdXRhYmxlT3B0aW9ucyA9IGltbXV0YWJsZUNoZWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShpbW11dGFibGVPcHRpb25zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXJpYWxpemFibGVDaGVjaykge1xyXG4gICAgICAgICAgICB2YXIgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWlzQm9vbGVhbihzZXJpYWxpemFibGVDaGVjaykpIHtcclxuICAgICAgICAgICAgICAgIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSBzZXJpYWxpemFibGVDaGVjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaChjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoc2VyaWFsaXphYmxlT3B0aW9ucykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWN0aW9uQ3JlYXRvckNoZWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWlzQm9vbGVhbihhY3Rpb25DcmVhdG9yQ2hlY2spKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IGFjdGlvbkNyZWF0b3JDaGVjaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZShhY3Rpb25DcmVhdG9yT3B0aW9ucykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtaWRkbGV3YXJlQXJyYXk7XHJcbn1cclxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXHJcbnZhciBJU19QUk9EVUNUSU9OID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiO1xyXG5mdW5jdGlvbiBjb25maWd1cmVTdG9yZShvcHRpb25zKSB7XHJcbiAgICB2YXIgY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlID0gY3VycnlHZXREZWZhdWx0TWlkZGxld2FyZSgpO1xyXG4gICAgdmFyIF9jID0gb3B0aW9ucyB8fCB7fSwgX2QgPSBfYy5yZWR1Y2VyLCByZWR1Y2VyID0gX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLCBfZSA9IF9jLm1pZGRsZXdhcmUsIG1pZGRsZXdhcmUgPSBfZSA9PT0gdm9pZCAwID8gY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlKCkgOiBfZSwgX2YgPSBfYy5kZXZUb29scywgZGV2VG9vbHMgPSBfZiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9mLCBfZyA9IF9jLnByZWxvYWRlZFN0YXRlLCBwcmVsb2FkZWRTdGF0ZSA9IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZywgX2ggPSBfYy5lbmhhbmNlcnMsIGVuaGFuY2VycyA9IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaDtcclxuICAgIHZhciByb290UmVkdWNlcjtcclxuICAgIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcm9vdFJlZHVjZXIgPSByZWR1Y2VyO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChyZWR1Y2VyKSkge1xyXG4gICAgICAgIHJvb3RSZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHJlZHVjZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInJlZHVjZXJcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2VycycpO1xyXG4gICAgfVxyXG4gICAgdmFyIGZpbmFsTWlkZGxld2FyZSA9IG1pZGRsZXdhcmU7XHJcbiAgICBpZiAodHlwZW9mIGZpbmFsTWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgZmluYWxNaWRkbGV3YXJlID0gZmluYWxNaWRkbGV3YXJlKGN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZSk7XHJcbiAgICAgICAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KGZpbmFsTWlkZGxld2FyZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2hlbiB1c2luZyBhIG1pZGRsZXdhcmUgYnVpbGRlciBmdW5jdGlvbiwgYW4gYXJyYXkgb2YgbWlkZGxld2FyZSBtdXN0IGJlIHJldHVybmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghSVNfUFJPRFVDVElPTiAmJiBmaW5hbE1pZGRsZXdhcmUuc29tZShmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIjsgfSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlYWNoIG1pZGRsZXdhcmUgcHJvdmlkZWQgdG8gY29uZmlndXJlU3RvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIG1pZGRsZXdhcmVFbmhhbmNlciA9IGFwcGx5TWlkZGxld2FyZS5hcHBseSh2b2lkIDAsIGZpbmFsTWlkZGxld2FyZSk7XHJcbiAgICB2YXIgZmluYWxDb21wb3NlID0gY29tcG9zZTI7XHJcbiAgICBpZiAoZGV2VG9vbHMpIHtcclxuICAgICAgICBmaW5hbENvbXBvc2UgPSBjb21wb3NlV2l0aERldlRvb2xzKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICAgICAgdHJhY2U6ICFJU19QUk9EVUNUSU9OXHJcbiAgICAgICAgfSwgdHlwZW9mIGRldlRvb2xzID09PSBcIm9iamVjdFwiICYmIGRldlRvb2xzKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgZGVmYXVsdEVuaGFuY2VycyA9IG5ldyBFbmhhbmNlckFycmF5KG1pZGRsZXdhcmVFbmhhbmNlcik7XHJcbiAgICB2YXIgc3RvcmVFbmhhbmNlcnMgPSBkZWZhdWx0RW5oYW5jZXJzO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZW5oYW5jZXJzKSkge1xyXG4gICAgICAgIHN0b3JlRW5oYW5jZXJzID0gX19zcHJlYWRBcnJheShbbWlkZGxld2FyZUVuaGFuY2VyXSwgZW5oYW5jZXJzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBlbmhhbmNlcnMgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHN0b3JlRW5oYW5jZXJzID0gZW5oYW5jZXJzKGRlZmF1bHRFbmhhbmNlcnMpO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbXBvc2VkRW5oYW5jZXIgPSBmaW5hbENvbXBvc2UuYXBwbHkodm9pZCAwLCBzdG9yZUVuaGFuY2Vycyk7XHJcbiAgICByZXR1cm4gY3JlYXRlU3RvcmUocm9vdFJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBjb21wb3NlZEVuaGFuY2VyKTtcclxufVxyXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xyXG5pbXBvcnQgY3JlYXRlTmV4dFN0YXRlMiwgeyBpc0RyYWZ0IGFzIGlzRHJhZnQyLCBpc0RyYWZ0YWJsZSBhcyBpc0RyYWZ0YWJsZTIgfSBmcm9tIFwiaW1tZXJcIjtcclxuLy8gc3JjL21hcEJ1aWxkZXJzLnRzXHJcbmZ1bmN0aW9uIGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKGJ1aWxkZXJDYWxsYmFjaykge1xyXG4gICAgdmFyIGFjdGlvbnNNYXAgPSB7fTtcclxuICAgIHZhciBhY3Rpb25NYXRjaGVycyA9IFtdO1xyXG4gICAgdmFyIGRlZmF1bHRDYXNlUmVkdWNlcjtcclxuICAgIHZhciBidWlsZGVyID0ge1xyXG4gICAgICAgIGFkZENhc2U6IGZ1bmN0aW9uICh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25NYXRjaGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZE1hdGNoZXJgXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XHJcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlIGluIGFjdGlvbnNNYXApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBidWlsZGVyLmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGlvbnNNYXBbdHlwZV0gPSByZWR1Y2VyO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZE1hdGNoZXI6IGZ1bmN0aW9uIChtYXRjaGVyLCByZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgYnVpbGRlci5hZGRNYXRjaGVyYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGlvbk1hdGNoZXJzLnB1c2goeyBtYXRjaGVyOiBtYXRjaGVyLCByZWR1Y2VyOiByZWR1Y2VyIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZERlZmF1bHRDYXNlOiBmdW5jdGlvbiAocmVkdWNlcikge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHJlZHVjZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBidWlsZGVyQ2FsbGJhY2soYnVpbGRlcik7XHJcbiAgICByZXR1cm4gW2FjdGlvbnNNYXAsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdO1xyXG59XHJcbi8vIHNyYy9jcmVhdGVSZWR1Y2VyLnRzXHJcbmZ1bmN0aW9uIGlzU3RhdGVGdW5jdGlvbih4KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG52YXIgaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbiA9IGZhbHNlO1xyXG5mdW5jdGlvbiBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgbWFwT3JCdWlsZGVyQ2FsbGJhY2ssIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcclxuICAgIGlmIChhY3Rpb25NYXRjaGVycyA9PT0gdm9pZCAwKSB7IGFjdGlvbk1hdGNoZXJzID0gW107IH1cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgb2JqZWN0IG5vdGF0aW9uIGZvciBgY3JlYXRlUmVkdWNlcmAgaXMgZGVwcmVjYXRlZCwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSVEsgMi4wLiBQbGVhc2UgdXNlIHRoZSAnYnVpbGRlciBjYWxsYmFjaycgbm90YXRpb24gaW5zdGVhZDogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvY3JlYXRlUmVkdWNlclwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBfYyA9IHR5cGVvZiBtYXBPckJ1aWxkZXJDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiID8gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sobWFwT3JCdWlsZGVyQ2FsbGJhY2spIDogW21hcE9yQnVpbGRlckNhbGxiYWNrLCBhY3Rpb25NYXRjaGVycywgZGVmYXVsdENhc2VSZWR1Y2VyXSwgYWN0aW9uc01hcCA9IF9jWzBdLCBmaW5hbEFjdGlvbk1hdGNoZXJzID0gX2NbMV0sIGZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyID0gX2NbMl07XHJcbiAgICB2YXIgZ2V0SW5pdGlhbFN0YXRlO1xyXG4gICAgaWYgKGlzU3RhdGVGdW5jdGlvbihpbml0aWFsU3RhdGUpKSB7XHJcbiAgICAgICAgZ2V0SW5pdGlhbFN0YXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSgpKTsgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBmcm96ZW5Jbml0aWFsU3RhdGVfMSA9IGZyZWV6ZURyYWZ0YWJsZShpbml0aWFsU3RhdGUpO1xyXG4gICAgICAgIGdldEluaXRpYWxTdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb3plbkluaXRpYWxTdGF0ZV8xOyB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHsgc3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTsgfVxyXG4gICAgICAgIHZhciBjYXNlUmVkdWNlcnMgPSBfX3NwcmVhZEFycmF5KFtcclxuICAgICAgICAgICAgYWN0aW9uc01hcFthY3Rpb24udHlwZV1cclxuICAgICAgICBdLCBmaW5hbEFjdGlvbk1hdGNoZXJzLmZpbHRlcihmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoZXIgPSBfYy5tYXRjaGVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgdmFyIHJlZHVjZXIyID0gX2MucmVkdWNlcjtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZHVjZXIyO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBpZiAoY2FzZVJlZHVjZXJzLmZpbHRlcihmdW5jdGlvbiAoY3IpIHsgcmV0dXJuICEhY3I7IH0pLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjYXNlUmVkdWNlcnMgPSBbZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXJzLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXNTdGF0ZSwgY2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgICAgaWYgKGNhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEcmFmdDIocHJldmlvdXNTdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHJhZnQgPSBwcmV2aW91c1N0YXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNEcmFmdGFibGUyKHByZXZpb3VzU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGNhc2VSZWR1Y2VyKHByZXZpb3VzU3RhdGUsIGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1N0YXRlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkEgY2FzZSByZWR1Y2VyIG9uIGEgbm9uLWRyYWZ0YWJsZSB2YWx1ZSBtdXN0IG5vdCByZXR1cm4gdW5kZWZpbmVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTIocHJldmlvdXNTdGF0ZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcclxuICAgICAgICB9LCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICByZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZTtcclxuICAgIHJldHVybiByZWR1Y2VyO1xyXG59XHJcbi8vIHNyYy9jcmVhdGVTbGljZS50c1xyXG52YXIgaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbjIgPSBmYWxzZTtcclxuZnVuY3Rpb24gZ2V0VHlwZTIoc2xpY2UsIGFjdGlvbktleSkge1xyXG4gICAgcmV0dXJuIHNsaWNlICsgXCIvXCIgKyBhY3Rpb25LZXk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2xpY2Uob3B0aW9ucykge1xyXG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWU7XHJcbiAgICBpZiAoIW5hbWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgbmFtZWAgaXMgYSByZXF1aXJlZCBvcHRpb24gZm9yIGNyZWF0ZVNsaWNlXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5pbml0aWFsU3RhdGUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhbiBgaW5pdGlhbFN0YXRlYCB2YWx1ZSB0aGF0IGlzIG5vdCBgdW5kZWZpbmVkYC4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYGluaXRpYWxTdGF0ZWBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHR5cGVvZiBvcHRpb25zLmluaXRpYWxTdGF0ZSA9PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLmluaXRpYWxTdGF0ZSA6IGZyZWV6ZURyYWZ0YWJsZShvcHRpb25zLmluaXRpYWxTdGF0ZSk7XHJcbiAgICB2YXIgcmVkdWNlcnMgPSBvcHRpb25zLnJlZHVjZXJzIHx8IHt9O1xyXG4gICAgdmFyIHJlZHVjZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcclxuICAgIHZhciBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSA9IHt9O1xyXG4gICAgdmFyIHNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlID0ge307XHJcbiAgICB2YXIgYWN0aW9uQ3JlYXRvcnMgPSB7fTtcclxuICAgIHJlZHVjZXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWR1Y2VyTmFtZSkge1xyXG4gICAgICAgIHZhciBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSA9IHJlZHVjZXJzW3JlZHVjZXJOYW1lXTtcclxuICAgICAgICB2YXIgdHlwZSA9IGdldFR5cGUyKG5hbWUsIHJlZHVjZXJOYW1lKTtcclxuICAgICAgICB2YXIgY2FzZVJlZHVjZXI7XHJcbiAgICAgICAgdmFyIHByZXBhcmVDYWxsYmFjaztcclxuICAgICAgICBpZiAoXCJyZWR1Y2VyXCIgaW4gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpIHtcclxuICAgICAgICAgICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5yZWR1Y2VyO1xyXG4gICAgICAgICAgICBwcmVwYXJlQ2FsbGJhY2sgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5wcmVwYXJlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWVbcmVkdWNlck5hbWVdID0gY2FzZVJlZHVjZXI7XHJcbiAgICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGVbdHlwZV0gPSBjYXNlUmVkdWNlcjtcclxuICAgICAgICBhY3Rpb25DcmVhdG9yc1tyZWR1Y2VyTmFtZV0gPSBwcmVwYXJlQ2FsbGJhY2sgPyBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUNhbGxiYWNrKSA6IGNyZWF0ZUFjdGlvbih0eXBlKTtcclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gYnVpbGRSZWR1Y2VyKCkge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRPYmplY3ROb3RhdGlvbjIpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWRBYm91dE9iamVjdE5vdGF0aW9uMiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVNsaWNlLmV4dHJhUmVkdWNlcnNgIGlzIGRlcHJlY2F0ZWQsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUlRLIDIuMC4gUGxlYXNlIHVzZSB0aGUgJ2J1aWxkZXIgY2FsbGJhY2snIG5vdGF0aW9uIGluc3RlYWQ6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2NyZWF0ZVNsaWNlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfYyA9IHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG9wdGlvbnMuZXh0cmFSZWR1Y2VycykgOiBbb3B0aW9ucy5leHRyYVJlZHVjZXJzXSwgX2QgPSBfY1swXSwgZXh0cmFSZWR1Y2VycyA9IF9kID09PSB2b2lkIDAgPyB7fSA6IF9kLCBfZSA9IF9jWzFdLCBhY3Rpb25NYXRjaGVycyA9IF9lID09PSB2b2lkIDAgPyBbXSA6IF9lLCBfZiA9IF9jWzJdLCBkZWZhdWx0Q2FzZVJlZHVjZXIgPSBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Y7XHJcbiAgICAgICAgdmFyIGZpbmFsQ2FzZVJlZHVjZXJzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGV4dHJhUmVkdWNlcnMpLCBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlZHVjZXIoaW5pdGlhbFN0YXRlLCBmdW5jdGlvbiAoYnVpbGRlcikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZmluYWxDYXNlUmVkdWNlcnMpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShrZXksIGZpbmFsQ2FzZVJlZHVjZXJzW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgYWN0aW9uTWF0Y2hlcnNfMSA9IGFjdGlvbk1hdGNoZXJzOyBfaSA8IGFjdGlvbk1hdGNoZXJzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IGFjdGlvbk1hdGNoZXJzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGRNYXRjaGVyKG0ubWF0Y2hlciwgbS5yZWR1Y2VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZERlZmF1bHRDYXNlKGRlZmF1bHRDYXNlUmVkdWNlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHZhciBfcmVkdWNlcjtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICByZWR1Y2VyOiBmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoIV9yZWR1Y2VyKVxyXG4gICAgICAgICAgICAgICAgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9yZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWN0aW9uczogYWN0aW9uQ3JlYXRvcnMsXHJcbiAgICAgICAgY2FzZVJlZHVjZXJzOiBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSxcclxuICAgICAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFfcmVkdWNlcilcclxuICAgICAgICAgICAgICAgIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVkdWNlci5nZXRJbml0aWFsU3RhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8vIHNyYy9lbnRpdGllcy9lbnRpdHlfc3RhdGUudHNcclxuZnVuY3Rpb24gZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpZHM6IFtdLFxyXG4gICAgICAgIGVudGl0aWVzOiB7fVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KCkge1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKGFkZGl0aW9uYWxTdGF0ZSkge1xyXG4gICAgICAgIGlmIChhZGRpdGlvbmFsU3RhdGUgPT09IHZvaWQgMCkgeyBhZGRpdGlvbmFsU3RhdGUgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGdldEluaXRpYWxFbnRpdHlTdGF0ZSgpLCBhZGRpdGlvbmFsU3RhdGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgZ2V0SW5pdGlhbFN0YXRlOiBnZXRJbml0aWFsU3RhdGUgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvc3RhdGVfc2VsZWN0b3JzLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKSB7XHJcbiAgICBmdW5jdGlvbiBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGUpIHtcclxuICAgICAgICB2YXIgc2VsZWN0SWRzID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5pZHM7IH07XHJcbiAgICAgICAgdmFyIHNlbGVjdEVudGl0aWVzID0gZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5lbnRpdGllczsgfTtcclxuICAgICAgICB2YXIgc2VsZWN0QWxsID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3Ioc2VsZWN0SWRzLCBzZWxlY3RFbnRpdGllcywgZnVuY3Rpb24gKGlkcywgZW50aXRpZXMpIHsgcmV0dXJuIGlkcy5tYXAoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBlbnRpdGllc1tpZF07IH0pOyB9KTtcclxuICAgICAgICB2YXIgc2VsZWN0SWQgPSBmdW5jdGlvbiAoXywgaWQpIHsgcmV0dXJuIGlkOyB9O1xyXG4gICAgICAgIHZhciBzZWxlY3RCeUlkID0gZnVuY3Rpb24gKGVudGl0aWVzLCBpZCkgeyByZXR1cm4gZW50aXRpZXNbaWRdOyB9O1xyXG4gICAgICAgIHZhciBzZWxlY3RUb3RhbCA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdElkcywgZnVuY3Rpb24gKGlkcykgeyByZXR1cm4gaWRzLmxlbmd0aDsgfSk7XHJcbiAgICAgICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0SWRzOiBzZWxlY3RJZHMsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RFbnRpdGllczogc2VsZWN0RW50aXRpZXMsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RBbGw6IHNlbGVjdEFsbCxcclxuICAgICAgICAgICAgICAgIHNlbGVjdFRvdGFsOiBzZWxlY3RUb3RhbCxcclxuICAgICAgICAgICAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RFbnRpdGllcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2VsZWN0SWRzOiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0SWRzKSxcclxuICAgICAgICAgICAgc2VsZWN0RW50aXRpZXM6IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyxcclxuICAgICAgICAgICAgc2VsZWN0QWxsOiBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0QWxsKSxcclxuICAgICAgICAgICAgc2VsZWN0VG90YWw6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RUb3RhbCksXHJcbiAgICAgICAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yKHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGdldFNlbGVjdG9yczogZ2V0U2VsZWN0b3JzIH07XHJcbn1cclxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX2FkYXB0ZXIudHNcclxuaW1wb3J0IGNyZWF0ZU5leHRTdGF0ZTMsIHsgaXNEcmFmdCBhcyBpc0RyYWZ0MyB9IGZyb20gXCJpbW1lclwiO1xyXG5mdW5jdGlvbiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xyXG4gICAgdmFyIG9wZXJhdG9yID0gY3JlYXRlU3RhdGVPcGVyYXRvcihmdW5jdGlvbiAoXywgc3RhdGUpIHsgcmV0dXJuIG11dGF0b3Ioc3RhdGUpOyB9KTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gb3BlcmF0b3Ioc3RhdGUsIHZvaWQgMCk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSwgYXJnKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnMikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNGU0EoYXJnMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBydW5NdXRhdG9yID0gZnVuY3Rpb24gKGRyYWZ0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1BheWxvYWRBY3Rpb25Bcmd1bWVudChhcmcpKSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdG9yKGFyZy5wYXlsb2FkLCBkcmFmdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdG9yKGFyZywgZHJhZnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaXNEcmFmdDMoc3RhdGUpKSB7XHJcbiAgICAgICAgICAgIHJ1bk11dGF0b3Ioc3RhdGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlMyhzdGF0ZSwgcnVuTXV0YXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvdXRpbHMudHNcclxuZnVuY3Rpb24gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKSB7XHJcbiAgICB2YXIga2V5ID0gc2VsZWN0SWQoZW50aXR5KTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYga2V5ID09PSB2b2lkIDApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgZW50aXR5IHBhc3NlZCB0byB0aGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCB1bmRlZmluZWQuXCIsIFwiWW91IHNob3VsZCBwcm9iYWJseSBwcm92aWRlIHlvdXIgb3duIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24uXCIsIFwiVGhlIGVudGl0eSB0aGF0IHdhcyBwYXNzZWQ6XCIsIGVudGl0eSwgXCJUaGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbjpcIiwgc2VsZWN0SWQudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5O1xyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZUVudGl0aWVzQXJyYXkoZW50aXRpZXMpIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRpdGllcykpIHtcclxuICAgICAgICBlbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoZW50aXRpZXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVudGl0aWVzO1xyXG59XHJcbmZ1bmN0aW9uIHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSkge1xyXG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgIHZhciBhZGRlZCA9IFtdO1xyXG4gICAgdmFyIHVwZGF0ZWQgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgbmV3RW50aXRpZXNfMSA9IG5ld0VudGl0aWVzOyBfaSA8IG5ld0VudGl0aWVzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGVudGl0eSA9IG5ld0VudGl0aWVzXzFbX2ldO1xyXG4gICAgICAgIHZhciBpZCA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XHJcbiAgICAgICAgaWYgKGlkIGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZWQucHVzaCh7IGlkOiBpZCwgY2hhbmdlczogZW50aXR5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWRkZWQucHVzaChlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbYWRkZWQsIHVwZGF0ZWRdO1xyXG59XHJcbi8vIHNyYy9lbnRpdGllcy91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXHJcbmZ1bmN0aW9uIGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKSB7XHJcbiAgICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICB2YXIga2V5ID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcclxuICAgICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcclxuICAgICAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5ld0VudGl0aWVzXzIgPSBuZXdFbnRpdGllczsgX2kgPCBuZXdFbnRpdGllc18yLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gbmV3RW50aXRpZXNfMltfaV07XHJcbiAgICAgICAgICAgIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHN0YXRlLmVudGl0aWVzKSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5ld0VudGl0aWVzXzMgPSBuZXdFbnRpdGllczsgX2kgPCBuZXdFbnRpdGllc18zLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5ID0gbmV3RW50aXRpZXNfM1tfaV07XHJcbiAgICAgICAgICAgIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcclxuICAgICAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xyXG4gICAgICAgIHN0YXRlLmlkcyA9IFtdO1xyXG4gICAgICAgIHN0YXRlLmVudGl0aWVzID0ge307XHJcbiAgICAgICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZU9uZU11dGFibHkoa2V5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiByZW1vdmVNYW55TXV0YWJseShba2V5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlTWFueU11dGFibHkoa2V5cywgc3RhdGUpIHtcclxuICAgICAgICB2YXIgZGlkTXV0YXRlID0gZmFsc2U7XHJcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW2tleV07XHJcbiAgICAgICAgICAgICAgICBkaWRNdXRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGRpZE11dGF0ZSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5pZHMgPSBzdGF0ZS5pZHMuZmlsdGVyKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQgaW4gc3RhdGUuZW50aXRpZXM7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbE11dGFibHkoc3RhdGUpIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHN0YXRlLCB7XHJcbiAgICAgICAgICAgIGlkczogW10sXHJcbiAgICAgICAgICAgIGVudGl0aWVzOiB7fVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdGFrZU5ld0tleShrZXlzLCB1cGRhdGUsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIG9yaWdpbmFsMiA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XHJcbiAgICAgICAgdmFyIHVwZGF0ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbDIsIHVwZGF0ZS5jaGFuZ2VzKTtcclxuICAgICAgICB2YXIgbmV3S2V5ID0gc2VsZWN0SWRWYWx1ZSh1cGRhdGVkLCBzZWxlY3RJZCk7XHJcbiAgICAgICAgdmFyIGhhc05ld0tleSA9IG5ld0tleSAhPT0gdXBkYXRlLmlkO1xyXG4gICAgICAgIGlmIChoYXNOZXdLZXkpIHtcclxuICAgICAgICAgICAga2V5c1t1cGRhdGUuaWRdID0gbmV3S2V5O1xyXG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUuZW50aXRpZXNbbmV3S2V5XSA9IHVwZGF0ZWQ7XHJcbiAgICAgICAgcmV0dXJuIGhhc05ld0tleTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlLCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB1cGRhdGVNYW55TXV0YWJseShbdXBkYXRlXSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlcywgc3RhdGUpIHtcclxuICAgICAgICB2YXIgbmV3S2V5cyA9IHt9O1xyXG4gICAgICAgIHZhciB1cGRhdGVzUGVyRW50aXR5ID0ge307XHJcbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh1cGRhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5pZCBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiB1cGRhdGUuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA/IHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXS5jaGFuZ2VzIDogbnVsbCksIHVwZGF0ZS5jaGFuZ2VzKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHVwZGF0ZXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZXNQZXJFbnRpdHkpO1xyXG4gICAgICAgIHZhciBkaWRNdXRhdGVFbnRpdGllcyA9IHVwZGF0ZXMubGVuZ3RoID4gMDtcclxuICAgICAgICBpZiAoZGlkTXV0YXRlRW50aXRpZXMpIHtcclxuICAgICAgICAgICAgdmFyIGRpZE11dGF0ZUlkcyA9IHVwZGF0ZXMuZmlsdGVyKGZ1bmN0aW9uICh1cGRhdGUpIHsgcmV0dXJuIHRha2VOZXdLZXkobmV3S2V5cywgdXBkYXRlLCBzdGF0ZSk7IH0pLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgIGlmIChkaWRNdXRhdGVJZHMpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmlkcyA9IE9iamVjdC5rZXlzKHN0YXRlLmVudGl0aWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIF9jID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKSwgYWRkZWQgPSBfY1swXSwgdXBkYXRlZCA9IF9jWzFdO1xyXG4gICAgICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcclxuICAgICAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZW1vdmVBbGw6IGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihyZW1vdmVBbGxNdXRhYmx5KSxcclxuICAgICAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXHJcbiAgICAgICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXHJcbiAgICAgICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxyXG4gICAgICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcclxuICAgICAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXHJcbiAgICAgICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXHJcbiAgICAgICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxyXG4gICAgICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHJlbW92ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVPbmVNdXRhYmx5KSxcclxuICAgICAgICByZW1vdmVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU1hbnlNdXRhYmx5KVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcclxuZnVuY3Rpb24gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0KSB7XHJcbiAgICB2YXIgX2MgPSBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCksIHJlbW92ZU9uZSA9IF9jLnJlbW92ZU9uZSwgcmVtb3ZlTWFueSA9IF9jLnJlbW92ZU1hbnksIHJlbW92ZUFsbCA9IF9jLnJlbW92ZUFsbDtcclxuICAgIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBhZGRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICB2YXIgbW9kZWxzID0gbmV3RW50aXRpZXMuZmlsdGVyKGZ1bmN0aW9uIChtb2RlbCkgeyByZXR1cm4gIShzZWxlY3RJZFZhbHVlKG1vZGVsLCBzZWxlY3RJZCkgaW4gc3RhdGUuZW50aXRpZXMpOyB9KTtcclxuICAgICAgICBpZiAobW9kZWxzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBtZXJnZShtb2RlbHMsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gc2V0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XHJcbiAgICAgICAgaWYgKG5ld0VudGl0aWVzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICBtZXJnZShuZXdFbnRpdGllcywgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcclxuICAgICAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xyXG4gICAgICAgIHN0YXRlLmlkcyA9IFtdO1xyXG4gICAgICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXMsIHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGFwcGxpZWRVcGRhdGVzID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB1cGRhdGVzXzEgPSB1cGRhdGVzOyBfaSA8IHVwZGF0ZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IHVwZGF0ZXNfMVtfaV07XHJcbiAgICAgICAgICAgIHZhciBlbnRpdHkgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xyXG4gICAgICAgICAgICBpZiAoIWVudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXBwbGllZFVwZGF0ZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGVudGl0eSwgdXBkYXRlLmNoYW5nZXMpO1xyXG4gICAgICAgICAgICB2YXIgbmV3SWQgPSBzZWxlY3RJZChlbnRpdHkpO1xyXG4gICAgICAgICAgICBpZiAodXBkYXRlLmlkICE9PSBuZXdJZCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5lbnRpdGllc1tuZXdJZF0gPSBlbnRpdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XHJcbiAgICAgICAgICAgIHJlc29ydEVudGl0aWVzKHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBfYyA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSksIGFkZGVkID0gX2NbMF0sIHVwZGF0ZWQgPSBfY1sxXTtcclxuICAgICAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XHJcbiAgICAgICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aCAmJiBpIDwgYi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYVtpXSA9PT0gYltpXSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lcmdlKG1vZGVscywgc3RhdGUpIHtcclxuICAgICAgICBtb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAobW9kZWwpIHtcclxuICAgICAgICAgICAgc3RhdGUuZW50aXRpZXNbc2VsZWN0SWQobW9kZWwpXSA9IG1vZGVsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlc29ydEVudGl0aWVzKHN0YXRlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc29ydEVudGl0aWVzKHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGFsbEVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcyk7XHJcbiAgICAgICAgYWxsRW50aXRpZXMuc29ydChzb3J0KTtcclxuICAgICAgICB2YXIgbmV3U29ydGVkSWRzID0gYWxsRW50aXRpZXMubWFwKHNlbGVjdElkKTtcclxuICAgICAgICB2YXIgaWRzID0gc3RhdGUuaWRzO1xyXG4gICAgICAgIGlmICghYXJlQXJyYXlzRXF1YWwoaWRzLCBuZXdTb3J0ZWRJZHMpKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmlkcyA9IG5ld1NvcnRlZElkcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbW92ZU9uZTogcmVtb3ZlT25lLFxyXG4gICAgICAgIHJlbW92ZU1hbnk6IHJlbW92ZU1hbnksXHJcbiAgICAgICAgcmVtb3ZlQWxsOiByZW1vdmVBbGwsXHJcbiAgICAgICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxyXG4gICAgICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcclxuICAgICAgICB1cHNlcnRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0T25lTXV0YWJseSksXHJcbiAgICAgICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxyXG4gICAgICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxyXG4gICAgICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcclxuICAgICAgICBhZGRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE1hbnlNdXRhYmx5KSxcclxuICAgICAgICB1cGRhdGVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU1hbnlNdXRhYmx5KSxcclxuICAgICAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvZW50aXRpZXMvY3JlYXRlX2FkYXB0ZXIudHNcclxuZnVuY3Rpb24gY3JlYXRlRW50aXR5QWRhcHRlcihvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgdmFyIF9jID0gX19zcHJlYWRWYWx1ZXMoe1xyXG4gICAgICAgIHNvcnRDb21wYXJlcjogZmFsc2UsXHJcbiAgICAgICAgc2VsZWN0SWQ6IGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gaW5zdGFuY2UuaWQ7IH1cclxuICAgIH0sIG9wdGlvbnMpLCBzZWxlY3RJZCA9IF9jLnNlbGVjdElkLCBzb3J0Q29tcGFyZXIgPSBfYy5zb3J0Q29tcGFyZXI7XHJcbiAgICB2YXIgc3RhdGVGYWN0b3J5ID0gY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeSgpO1xyXG4gICAgdmFyIHNlbGVjdG9yc0ZhY3RvcnkgPSBjcmVhdGVTZWxlY3RvcnNGYWN0b3J5KCk7XHJcbiAgICB2YXIgc3RhdGVBZGFwdGVyID0gc29ydENvbXBhcmVyID8gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0Q29tcGFyZXIpIDogY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xyXG4gICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcclxuICAgICAgICBzZWxlY3RJZDogc2VsZWN0SWQsXHJcbiAgICAgICAgc29ydENvbXBhcmVyOiBzb3J0Q29tcGFyZXJcclxuICAgIH0sIHN0YXRlRmFjdG9yeSksIHNlbGVjdG9yc0ZhY3RvcnkpLCBzdGF0ZUFkYXB0ZXIpO1xyXG59XHJcbi8vIHNyYy9uYW5vaWQudHNcclxudmFyIHVybEFscGhhYmV0ID0gXCJNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXXCI7XHJcbnZhciBuYW5vaWQgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgaWYgKHNpemUgPT09IHZvaWQgMCkgeyBzaXplID0gMjE7IH1cclxuICAgIHZhciBpZCA9IFwiXCI7XHJcbiAgICB2YXIgaSA9IHNpemU7XHJcbiAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaWQ7XHJcbn07XHJcbi8vIHNyYy9jcmVhdGVBc3luY1RodW5rLnRzXHJcbnZhciBjb21tb25Qcm9wZXJ0aWVzID0gW1xyXG4gICAgXCJuYW1lXCIsXHJcbiAgICBcIm1lc3NhZ2VcIixcclxuICAgIFwic3RhY2tcIixcclxuICAgIFwiY29kZVwiXHJcbl07XHJcbnZhciBSZWplY3RXaXRoVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZWplY3RXaXRoVmFsdWUocGF5bG9hZCwgbWV0YSkge1xyXG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZWplY3RXaXRoVmFsdWU7XHJcbn0oKSk7XHJcbnZhciBGdWxmaWxsV2l0aE1ldGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGdWxmaWxsV2l0aE1ldGEocGF5bG9hZCwgbWV0YSkge1xyXG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBGdWxmaWxsV2l0aE1ldGE7XHJcbn0oKSk7XHJcbnZhciBtaW5pU2VyaWFsaXplRXJyb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgc2ltcGxlRXJyb3IgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNvbW1vblByb3BlcnRpZXNfMSA9IGNvbW1vblByb3BlcnRpZXM7IF9pIDwgY29tbW9uUHJvcGVydGllc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBjb21tb25Qcm9wZXJ0aWVzXzFbX2ldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlW3Byb3BlcnR5XSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgc2ltcGxlRXJyb3JbcHJvcGVydHldID0gdmFsdWVbcHJvcGVydHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaW1wbGVFcnJvcjtcclxuICAgIH1cclxuICAgIHJldHVybiB7IG1lc3NhZ2U6IFN0cmluZyh2YWx1ZSkgfTtcclxufTtcclxudmFyIGNyZWF0ZUFzeW5jVGh1bmsgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlQXN5bmNUaHVuazIodHlwZVByZWZpeCwgcGF5bG9hZENyZWF0b3IsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZnVsZmlsbGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9mdWxmaWxsZWRcIiwgZnVuY3Rpb24gKHBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCBtZXRhKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgICAgICBtZXRhOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBtZXRhIHx8IHt9KSwge1xyXG4gICAgICAgICAgICAgICAgYXJnOiBhcmcsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RTdGF0dXM6IFwiZnVsZmlsbGVkXCJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgdmFyIHBlbmRpbmcgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3BlbmRpbmdcIiwgZnVuY3Rpb24gKHJlcXVlc3RJZCwgYXJnLCBtZXRhKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICBwYXlsb2FkOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIG1ldGE6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGEgfHwge30pLCB7XHJcbiAgICAgICAgICAgICAgICBhcmc6IGFyZyxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdFN0YXR1czogXCJwZW5kaW5nXCJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9yZWplY3RlZFwiLCBmdW5jdGlvbiAoZXJyb3IsIHJlcXVlc3RJZCwgYXJnLCBwYXlsb2FkLCBtZXRhKSB7IHJldHVybiAoe1xyXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgICAgICBlcnJvcjogKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemVFcnJvciB8fCBtaW5pU2VyaWFsaXplRXJyb3IpKGVycm9yIHx8IFwiUmVqZWN0ZWRcIiksXHJcbiAgICAgICAgICAgIG1ldGE6IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1ldGEgfHwge30pLCB7XHJcbiAgICAgICAgICAgICAgICBhcmc6IGFyZyxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgcmVqZWN0ZWRXaXRoVmFsdWU6ICEhcGF5bG9hZCxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RTdGF0dXM6IFwicmVqZWN0ZWRcIixcclxuICAgICAgICAgICAgICAgIGFib3J0ZWQ6IChlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IubmFtZSkgPT09IFwiQWJvcnRFcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiAoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm5hbWUpID09PSBcIkNvbmRpdGlvbkVycm9yXCJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTsgfSk7XHJcbiAgICAgICAgdmFyIGRpc3BsYXllZFdhcm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB2YXIgQUMgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyICE9PSBcInVuZGVmaW5lZFwiID8gQWJvcnRDb250cm9sbGVyIDogLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaWduYWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvbmFib3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICByZWFzb246IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgICAgICB0aHJvd0lmQWJvcnRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNwbGF5ZWRXYXJuaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXllZFdhcm5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJUaGlzIHBsYXRmb3JtIGRvZXMgbm90IGltcGxlbWVudCBBYm9ydENvbnRyb2xsZXIuIFxcbklmIHlvdSB3YW50IHRvIHVzZSB0aGUgQWJvcnRDb250cm9sbGVyIHRvIHJlYWN0IHRvIGBhYm9ydGAgZXZlbnRzLCBwbGVhc2UgY29uc2lkZXIgaW1wb3J0aW5nIGEgcG9seWZpbGwgbGlrZSAnYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsL2Rpc3QvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsLW9ubHknLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvcihhcmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdElkID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaWRHZW5lcmF0b3IpID8gb3B0aW9ucy5pZEdlbmVyYXRvcihhcmcpIDogbmFub2lkKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWJvcnRDb250cm9sbGVyID0gbmV3IEFDKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWJvcnRSZWFzb247XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYWJvcnQocmVhc29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRSZWFzb24gPSByZWFzb247XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZTIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBmaW5hbEFjdGlvbiwgY29uZGl0aW9uUmVzdWx0LCBhYm9ydGVkUHJvbWlzZSwgZXJyXzEsIHNraXBEaXNwYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFswLCA0LCAsIDVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jb25kaXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIGFyZywgeyBnZXRTdGF0ZTogZ2V0U3RhdGUsIGV4dHJhOiBleHRyYSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1RoZW5hYmxlKGNvbmRpdGlvblJlc3VsdCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjb25kaXRpb25SZXN1bHRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uUmVzdWx0ID09PSBmYWxzZSB8fCBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbmRpdGlvbkVycm9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBYm9ydGVkIGR1ZSB0byBjb25kaXRpb24gY2FsbGJhY2sgcmV0dXJuaW5nIGZhbHNlLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChfLCByZWplY3QpIHsgcmV0dXJuIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkFib3J0RXJyb3JcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGFib3J0UmVhc29uIHx8IFwiQWJvcnRlZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9KTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHBlbmRpbmcocmVxdWVzdElkLCBhcmcsIChfYiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2V0UGVuZGluZ01ldGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKG9wdGlvbnMsIHsgcmVxdWVzdElkOiByZXF1ZXN0SWQsIGFyZzogYXJnIH0sIHsgZ2V0U3RhdGU6IGdldFN0YXRlLCBleHRyYTogZXh0cmEgfSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydGVkUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUocGF5bG9hZENyZWF0b3IoYXJnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0OiBhYm9ydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0V2l0aFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIG1ldGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVqZWN0V2l0aFZhbHVlKHZhbHVlLCBtZXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbFdpdGhWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBtZXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZ1bGZpbGxXaXRoTWV0YSh2YWx1ZSwgbWV0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRnVsZmlsbFdpdGhNZXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdC5wYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgcmVzdWx0Lm1ldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LCByZXF1ZXN0SWQsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsQWN0aW9uID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycl8xID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGVycl8xIGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlID8gcmVqZWN0ZWQobnVsbCwgcmVxdWVzdElkLCBhcmcsIGVycl8xLnBheWxvYWQsIGVycl8xLm1ldGEpIDogcmVqZWN0ZWQoZXJyXzEsIHJlcXVlc3RJZCwgYXJnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwRGlzcGF0Y2ggPSBvcHRpb25zICYmICFvcHRpb25zLmRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uICYmIHJlamVjdGVkLm1hdGNoKGZpbmFsQWN0aW9uKSAmJiBmaW5hbEFjdGlvbi5tZXRhLmNvbmRpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFza2lwRGlzcGF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKGZpbmFsQWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmluYWxBY3Rpb25dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0oKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb21pc2UyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQ6IGFib3J0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZzogYXJnLFxyXG4gICAgICAgICAgICAgICAgICAgIHVud3JhcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTIudGhlbih1bndyYXBSZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY3Rpb25DcmVhdG9yLCB7XHJcbiAgICAgICAgICAgIHBlbmRpbmc6IHBlbmRpbmcsXHJcbiAgICAgICAgICAgIHJlamVjdGVkOiByZWplY3RlZCxcclxuICAgICAgICAgICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXHJcbiAgICAgICAgICAgIHR5cGVQcmVmaXg6IHR5cGVQcmVmaXhcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUFzeW5jVGh1bmsyLndpdGhUeXBlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZUFzeW5jVGh1bmsyOyB9O1xyXG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jVGh1bmsyO1xyXG59KSgpO1xyXG5mdW5jdGlvbiB1bndyYXBSZXN1bHQoYWN0aW9uKSB7XHJcbiAgICBpZiAoYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWUpIHtcclxuICAgICAgICB0aHJvdyBhY3Rpb24ucGF5bG9hZDtcclxuICAgIH1cclxuICAgIGlmIChhY3Rpb24uZXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBhY3Rpb24uZXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XHJcbn1cclxuZnVuY3Rpb24gaXNUaGVuYWJsZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xyXG59XHJcbi8vIHNyYy9tYXRjaGVycy50c1xyXG52YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uIChtYXRjaGVyLCBhY3Rpb24pIHtcclxuICAgIGlmIChoYXNNYXRjaEZ1bmN0aW9uKG1hdGNoZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIubWF0Y2goYWN0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGlzQW55T2YoKSB7XHJcbiAgICB2YXIgbWF0Y2hlcnMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgbWF0Y2hlcnNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoZnVuY3Rpb24gKG1hdGNoZXIpIHsgcmV0dXJuIG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKTsgfSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzQWxsT2YoKSB7XHJcbiAgICB2YXIgbWF0Y2hlcnMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgbWF0Y2hlcnNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzLmV2ZXJ5KGZ1bmN0aW9uIChtYXRjaGVyKSB7IHJldHVybiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbik7IH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIHZhbGlkU3RhdHVzKSB7XHJcbiAgICBpZiAoIWFjdGlvbiB8fCAhYWN0aW9uLm1ldGEpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmFyIGhhc1ZhbGlkUmVxdWVzdElkID0gdHlwZW9mIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCA9PT0gXCJzdHJpbmdcIjtcclxuICAgIHZhciBoYXNWYWxpZFJlcXVlc3RTdGF0dXMgPSB2YWxpZFN0YXR1cy5pbmRleE9mKGFjdGlvbi5tZXRhLnJlcXVlc3RTdGF0dXMpID4gLTE7XHJcbiAgICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xyXG59XHJcbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FycmF5KGEpIHtcclxuICAgIHJldHVybiB0eXBlb2YgYVswXSA9PT0gXCJmdW5jdGlvblwiICYmIFwicGVuZGluZ1wiIGluIGFbMF0gJiYgXCJmdWxmaWxsZWRcIiBpbiBhWzBdICYmIFwicmVqZWN0ZWRcIiBpbiBhWzBdO1xyXG59XHJcbmZ1bmN0aW9uIGlzUGVuZGluZygpIHtcclxuICAgIHZhciBhc3luY1RodW5rcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhc3luY1RodW5rc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7IHJldHVybiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNQZW5kaW5nKCkoYXN5bmNUaHVua3NbMF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICB2YXIgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoZnVuY3Rpb24gKGFzeW5jVGh1bmspIHsgcmV0dXJuIGFzeW5jVGh1bmsucGVuZGluZzsgfSk7XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YuYXBwbHkodm9pZCAwLCBtYXRjaGVycyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpc1JlamVjdGVkKCkge1xyXG4gICAgdmFyIGFzeW5jVGh1bmtzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFzeW5jVGh1bmtzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicmVqZWN0ZWRcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNSZWplY3RlZCgpKGFzeW5jVGh1bmtzWzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXJzID0gYXN5bmNUaHVua3MubWFwKGZ1bmN0aW9uIChhc3luY1RodW5rKSB7IHJldHVybiBhc3luY1RodW5rLnJlamVjdGVkOyB9KTtcclxuICAgICAgICB2YXIgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZi5hcHBseSh2b2lkIDAsIG1hdGNoZXJzKTtcclxuICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVqZWN0ZWRXaXRoVmFsdWUoKSB7XHJcbiAgICB2YXIgYXN5bmNUaHVua3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXN5bmNUaHVua3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBoYXNGbGFnID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWU7XHJcbiAgICB9O1xyXG4gICAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FsbE9mKGlzUmVqZWN0ZWQuYXBwbHkodm9pZCAwLCBhc3luY1RodW5rcyksIGhhc0ZsYWcpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVqZWN0ZWRXaXRoVmFsdWUoKShhc3luY1RodW5rc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FsbE9mKGlzUmVqZWN0ZWQuYXBwbHkodm9pZCAwLCBhc3luY1RodW5rcyksIGhhc0ZsYWcpO1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNGdWxmaWxsZWQoKSB7XHJcbiAgICB2YXIgYXN5bmNUaHVua3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXN5bmNUaHVua3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikgeyByZXR1cm4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJmdWxmaWxsZWRcIl0pOyB9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcclxuICAgICAgICByZXR1cm4gaXNGdWxmaWxsZWQoKShhc3luY1RodW5rc1swXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIHZhciBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcChmdW5jdGlvbiAoYXN5bmNUaHVuaykgeyByZXR1cm4gYXN5bmNUaHVuay5mdWxmaWxsZWQ7IH0pO1xyXG4gICAgICAgIHZhciBjb21iaW5lZE1hdGNoZXIgPSBpc0FueU9mLmFwcGx5KHZvaWQgMCwgbWF0Y2hlcnMpO1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaXNBc3luY1RodW5rQWN0aW9uKCkge1xyXG4gICAgdmFyIGFzeW5jVGh1bmtzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFzeW5jVGh1bmtzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiLCBcImZ1bGZpbGxlZFwiLCBcInJlamVjdGVkXCJdKTsgfTtcclxuICAgIH1cclxuICAgIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzQXN5bmNUaHVua0FjdGlvbigpKGFzeW5jVGh1bmtzWzBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoZXJzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBhc3luY1RodW5rc18xID0gYXN5bmNUaHVua3M7IF9pIDwgYXN5bmNUaHVua3NfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGFzeW5jVGh1bmsgPSBhc3luY1RodW5rc18xW19pXTtcclxuICAgICAgICAgICAgbWF0Y2hlcnMucHVzaChhc3luY1RodW5rLnBlbmRpbmcsIGFzeW5jVGh1bmsucmVqZWN0ZWQsIGFzeW5jVGh1bmsuZnVsZmlsbGVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YuYXBwbHkodm9pZCAwLCBtYXRjaGVycyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL3V0aWxzLnRzXHJcbnZhciBhc3NlcnRGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jLCBleHBlY3RlZCkge1xyXG4gICAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGV4cGVjdGVkICsgXCIgaXMgbm90IGEgZnVuY3Rpb25cIik7XHJcbiAgICB9XHJcbn07XHJcbnZhciBub29wID0gZnVuY3Rpb24gKCkge1xyXG59O1xyXG52YXIgY2F0Y2hSZWplY3Rpb24gPSBmdW5jdGlvbiAocHJvbWlzZTIsIG9uRXJyb3IpIHtcclxuICAgIGlmIChvbkVycm9yID09PSB2b2lkIDApIHsgb25FcnJvciA9IG5vb3A7IH1cclxuICAgIHByb21pc2UyLmNhdGNoKG9uRXJyb3IpO1xyXG4gICAgcmV0dXJuIHByb21pc2UyO1xyXG59O1xyXG52YXIgYWRkQWJvcnRTaWduYWxMaXN0ZW5lciA9IGZ1bmN0aW9uIChhYm9ydFNpZ25hbCwgY2FsbGJhY2spIHtcclxuICAgIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjaywgeyBvbmNlOiB0cnVlIH0pO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjayk7IH07XHJcbn07XHJcbnZhciBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uID0gZnVuY3Rpb24gKGFib3J0Q29udHJvbGxlciwgcmVhc29uKSB7XHJcbiAgICB2YXIgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcclxuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghKFwicmVhc29uXCIgaW4gc2lnbmFsKSkge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWduYWwsIFwicmVhc29uXCIsIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IHJlYXNvbixcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgYWJvcnRDb250cm9sbGVyLmFib3J0KHJlYXNvbik7XHJcbn07XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvZXhjZXB0aW9ucy50c1xyXG52YXIgdGFzayA9IFwidGFza1wiO1xyXG52YXIgbGlzdGVuZXIgPSBcImxpc3RlbmVyXCI7XHJcbnZhciBjb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xyXG52YXIgY2FuY2VsbGVkID0gXCJjYW5jZWxsZWRcIjtcclxudmFyIHRhc2tDYW5jZWxsZWQgPSBcInRhc2stXCIgKyBjYW5jZWxsZWQ7XHJcbnZhciB0YXNrQ29tcGxldGVkID0gXCJ0YXNrLVwiICsgY29tcGxldGVkO1xyXG52YXIgbGlzdGVuZXJDYW5jZWxsZWQgPSBsaXN0ZW5lciArIFwiLVwiICsgY2FuY2VsbGVkO1xyXG52YXIgbGlzdGVuZXJDb21wbGV0ZWQgPSBsaXN0ZW5lciArIFwiLVwiICsgY29tcGxldGVkO1xyXG52YXIgVGFza0Fib3J0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUYXNrQWJvcnRFcnJvcihjb2RlKSB7XHJcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlRhc2tBYm9ydEVycm9yXCI7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGFzayArIFwiIFwiICsgY2FuY2VsbGVkICsgXCIgKHJlYXNvbjogXCIgKyBjb2RlICsgXCIpXCI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVGFza0Fib3J0RXJyb3I7XHJcbn0oKSk7XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdGFzay50c1xyXG52YXIgdmFsaWRhdGVBY3RpdmUgPSBmdW5jdGlvbiAoc2lnbmFsKSB7XHJcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbik7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgcHJvbWlzZTIpIHtcclxuICAgIHZhciBjbGVhbnVwID0gbm9vcDtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgdmFyIG5vdGlmeVJlamVjdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdChuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbikpOyB9O1xyXG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgICAgICAgICBub3RpZnlSZWplY3Rpb24oKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhbnVwID0gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihzaWduYWwsIG5vdGlmeVJlamVjdGlvbik7XHJcbiAgICAgICAgcHJvbWlzZTIuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBjbGVhbnVwKCk7IH0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNsZWFudXAgPSBub29wO1xyXG4gICAgfSk7XHJcbn1cclxudmFyIHJ1blRhc2sgPSBmdW5jdGlvbiAodGFzazIsIGNsZWFuVXApIHsgcmV0dXJuIF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdmFsdWUsIGVycm9yXzE7XHJcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzAsIDMsIDQsIDVdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmVzb2x2ZSgpXTtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGFzazIoKV07XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcIm9rXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBlcnJvcl8xIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyBcImNhbmNlbGxlZFwiIDogXCJyZWplY3RlZFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JfMVxyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBjbGVhblVwID09IG51bGwgPyB2b2lkIDAgOiBjbGVhblVwKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xyXG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSk7IH07XHJcbnZhciBjcmVhdGVQYXVzZSA9IGZ1bmN0aW9uIChzaWduYWwpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvbWlzZTIpIHtcclxuICAgICAgICByZXR1cm4gY2F0Y2hSZWplY3Rpb24ocmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlMikudGhlbihmdW5jdGlvbiAob3V0cHV0KSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfTtcclxufTtcclxudmFyIGNyZWF0ZURlbGF5ID0gZnVuY3Rpb24gKHNpZ25hbCkge1xyXG4gICAgdmFyIHBhdXNlID0gY3JlYXRlUGF1c2Uoc2lnbmFsKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGltZW91dE1zKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdXNlKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXRNcyk7IH0pKTtcclxuICAgIH07XHJcbn07XHJcbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcclxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XHJcbnZhciBJTlRFUk5BTF9OSUxfVE9LRU4gPSB7fTtcclxudmFyIGFsbSA9IFwibGlzdGVuZXJNaWRkbGV3YXJlXCI7XHJcbnZhciBjcmVhdGVGb3JrID0gZnVuY3Rpb24gKHBhcmVudEFib3J0U2lnbmFsLCBwYXJlbnRCbG9ja2luZ1Byb21pc2VzKSB7XHJcbiAgICB2YXIgbGlua0NvbnRyb2xsZXJzID0gZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHsgcmV0dXJuIGFkZEFib3J0U2lnbmFsTGlzdGVuZXIocGFyZW50QWJvcnRTaWduYWwsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgcGFyZW50QWJvcnRTaWduYWwucmVhc29uKTsgfSk7IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhc2tFeGVjdXRvciwgb3B0cykge1xyXG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKHRhc2tFeGVjdXRvciwgXCJ0YXNrRXhlY3V0b3JcIik7XHJcbiAgICAgICAgdmFyIGNoaWxkQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAgIGxpbmtDb250cm9sbGVycyhjaGlsZEFib3J0Q29udHJvbGxlcik7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJ1blRhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdDI7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHBhcmVudEFib3J0U2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGFza0V4ZWN1dG9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdDJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjaGlsZEFib3J0Q29udHJvbGxlciwgdGFza0NvbXBsZXRlZCk7IH0pO1xyXG4gICAgICAgIGlmIChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmF1dG9Kb2luKSB7XHJcbiAgICAgICAgICAgIHBhcmVudEJsb2NraW5nUHJvbWlzZXMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZXN1bHQ6IGNyZWF0ZVBhdXNlKHBhcmVudEFib3J0U2lnbmFsKShyZXN1bHQpLFxyXG4gICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn07XHJcbnZhciBjcmVhdGVUYWtlUGF0dGVybiA9IGZ1bmN0aW9uIChzdGFydExpc3RlbmluZywgc2lnbmFsKSB7XHJcbiAgICB2YXIgdGFrZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRpbWVvdXQpIHsgcmV0dXJuIF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlLCB0dXBsZVByb21pc2UsIHByb21pc2VzLCBvdXRwdXQ7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHR1cGxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3BMaXN0ZW5pbmcgPSBzdGFydExpc3RlbmluZyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGU6IHByZWRpY2F0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdDogZnVuY3Rpb24gKGFjdGlvbiwgbGlzdGVuZXJBcGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lckFwaS51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyQXBpLmdldFN0YXRlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyQXBpLmdldE9yaWdpbmFsU3RhdGUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wTGlzdGVuaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHVwbGVQcm9taXNlXHJcbiAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCwgbnVsbCk7IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMSwgLCAzLCA0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmFjZVdpdGhTaWduYWwoc2lnbmFsLCBQcm9taXNlLnJhY2UocHJvbWlzZXMpKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG91dHB1dF07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcmVkaWNhdGUsIHRpbWVvdXQpIHsgcmV0dXJuIGNhdGNoUmVqZWN0aW9uKHRha2UocHJlZGljYXRlLCB0aW1lb3V0KSk7IH07XHJcbn07XHJcbnZhciBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciB0eXBlID0gb3B0aW9ucy50eXBlLCBhY3Rpb25DcmVhdG9yID0gb3B0aW9ucy5hY3Rpb25DcmVhdG9yLCBtYXRjaGVyID0gb3B0aW9ucy5tYXRjaGVyLCBwcmVkaWNhdGUgPSBvcHRpb25zLnByZWRpY2F0ZSwgZWZmZWN0ID0gb3B0aW9ucy5lZmZlY3Q7XHJcbiAgICBpZiAodHlwZSkge1xyXG4gICAgICAgIHByZWRpY2F0ZSA9IGNyZWF0ZUFjdGlvbih0eXBlKS5tYXRjaDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFjdGlvbkNyZWF0b3IpIHtcclxuICAgICAgICB0eXBlID0gYWN0aW9uQ3JlYXRvci50eXBlO1xyXG4gICAgICAgIHByZWRpY2F0ZSA9IGFjdGlvbkNyZWF0b3IubWF0Y2g7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtYXRjaGVyKSB7XHJcbiAgICAgICAgcHJlZGljYXRlID0gbWF0Y2hlcjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByZWRpY2F0ZSkge1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3JlYXRpbmcgb3IgcmVtb3ZpbmcgYSBsaXN0ZW5lciByZXF1aXJlcyBvbmUgb2YgdGhlIGtub3duIGZpZWxkcyBmb3IgbWF0Y2hpbmcgYW4gYWN0aW9uXCIpO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0RnVuY3Rpb24oZWZmZWN0LCBcIm9wdGlvbnMubGlzdGVuZXJcIik7XHJcbiAgICByZXR1cm4geyBwcmVkaWNhdGU6IHByZWRpY2F0ZSwgdHlwZTogdHlwZSwgZWZmZWN0OiBlZmZlY3QgfTtcclxufTtcclxudmFyIGNyZWF0ZUxpc3RlbmVyRW50cnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIF9jID0gZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbShvcHRpb25zKSwgdHlwZSA9IF9jLnR5cGUsIHByZWRpY2F0ZSA9IF9jLnByZWRpY2F0ZSwgZWZmZWN0ID0gX2MuZWZmZWN0O1xyXG4gICAgdmFyIGlkID0gbmFub2lkKCk7XHJcbiAgICB2YXIgZW50cnkgPSB7XHJcbiAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgIGVmZmVjdDogZWZmZWN0LFxyXG4gICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgcHJlZGljYXRlOiBwcmVkaWNhdGUsXHJcbiAgICAgICAgcGVuZGluZzogbmV3IFNldCgpLFxyXG4gICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3Vic2NyaWJlIG5vdCBpbml0aWFsaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGVudHJ5O1xyXG59O1xyXG52YXIgY2FuY2VsQWN0aXZlTGlzdGVuZXJzID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICBlbnRyeS5wZW5kaW5nLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcclxuICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcclxuICAgIH0pO1xyXG59O1xyXG52YXIgY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBmdW5jdGlvbiAobGlzdGVuZXJNYXApIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGlzdGVuZXJNYXAuZm9yRWFjaChjYW5jZWxBY3RpdmVMaXN0ZW5lcnMpO1xyXG4gICAgICAgIGxpc3RlbmVyTWFwLmNsZWFyKCk7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgc2FmZWx5Tm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JIYW5kbGVyLCBlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZXJyb3JIYW5kbGVyKGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3JIYW5kbGVyRXJyb3IpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3JIYW5kbGVyRXJyb3I7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBhZGRMaXN0ZW5lciA9IGNyZWF0ZUFjdGlvbihhbG0gKyBcIi9hZGRcIik7XHJcbnZhciBjbGVhckFsbExpc3RlbmVycyA9IGNyZWF0ZUFjdGlvbihhbG0gKyBcIi9yZW1vdmVBbGxcIik7XHJcbnZhciByZW1vdmVMaXN0ZW5lciA9IGNyZWF0ZUFjdGlvbihhbG0gKyBcIi9yZW1vdmVcIik7XHJcbnZhciBkZWZhdWx0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBfX3NwcmVhZEFycmF5KFthbG0gKyBcIi9lcnJvclwiXSwgYXJncykpO1xyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUobWlkZGxld2FyZU9wdGlvbnMpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICBpZiAobWlkZGxld2FyZU9wdGlvbnMgPT09IHZvaWQgMCkgeyBtaWRkbGV3YXJlT3B0aW9ucyA9IHt9OyB9XHJcbiAgICB2YXIgbGlzdGVuZXJNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB2YXIgZXh0cmEgPSBtaWRkbGV3YXJlT3B0aW9ucy5leHRyYSwgX2MgPSBtaWRkbGV3YXJlT3B0aW9ucy5vbkVycm9yLCBvbkVycm9yID0gX2MgPT09IHZvaWQgMCA/IGRlZmF1bHRFcnJvckhhbmRsZXIgOiBfYztcclxuICAgIGFzc2VydEZ1bmN0aW9uKG9uRXJyb3IsIFwib25FcnJvclwiKTtcclxuICAgIHZhciBpbnNlcnRFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGVudHJ5LnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlzdGVuZXJNYXAuZGVsZXRlKGVudHJ5LmlkKTsgfTtcclxuICAgICAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNhbmNlbE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgaWYgKGNhbmNlbE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbmNlbE9wdGlvbnMuY2FuY2VsQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMoZW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICB2YXIgZmluZExpc3RlbmVyRW50cnkgPSBmdW5jdGlvbiAoY29tcGFyYXRvcikge1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2MgPSBBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKTsgX2kgPCBfYy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2NbX2ldO1xyXG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihlbnRyeSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdm9pZCAwO1xyXG4gICAgfTtcclxuICAgIHZhciBzdGFydExpc3RlbmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gZmluZExpc3RlbmVyRW50cnkoZnVuY3Rpb24gKGV4aXN0aW5nRW50cnkpIHsgcmV0dXJuIGV4aXN0aW5nRW50cnkuZWZmZWN0ID09PSBvcHRpb25zLmVmZmVjdDsgfSk7XHJcbiAgICAgICAgaWYgKCFlbnRyeSkge1xyXG4gICAgICAgICAgICBlbnRyeSA9IGNyZWF0ZUxpc3RlbmVyRW50cnkob3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnNlcnRFbnRyeShlbnRyeSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHN0b3BMaXN0ZW5pbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYyA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyksIHR5cGUgPSBfYy50eXBlLCBlZmZlY3QgPSBfYy5lZmZlY3QsIHByZWRpY2F0ZSA9IF9jLnByZWRpY2F0ZTtcclxuICAgICAgICB2YXIgZW50cnkgPSBmaW5kTGlzdGVuZXJFbnRyeShmdW5jdGlvbiAoZW50cnkyKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaFByZWRpY2F0ZU9yVHlwZSA9IHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiID8gZW50cnkyLnR5cGUgPT09IHR5cGUgOiBlbnRyeTIucHJlZGljYXRlID09PSBwcmVkaWNhdGU7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaFByZWRpY2F0ZU9yVHlwZSAmJiBlbnRyeTIuZWZmZWN0ID09PSBlZmZlY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbmNlbEFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gISFlbnRyeTtcclxuICAgIH07XHJcbiAgICB2YXIgbm90aWZ5TGlzdGVuZXIgPSBmdW5jdGlvbiAoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKSB7IHJldHVybiBfX2FzeW5jKF90aGlzLCBudWxsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGludGVybmFsVGFza0NvbnRyb2xsZXIsIHRha2UsIGF1dG9Kb2luUHJvbWlzZXMsIGxpc3RlbmVyRXJyb3JfMTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbFRhc2tDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRha2UgPSBjcmVhdGVUYWtlUGF0dGVybihzdGFydExpc3RlbmluZywgaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9Kb2luUHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2MudHJ5cy5wdXNoKFsxLCAzLCA0LCA2XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cnkucGVuZGluZy5hZGQoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yZXNvbHZlKGVudHJ5LmVmZmVjdChhY3Rpb24sIGFzc2lnbih7fSwgYXBpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPcmlnaW5hbFN0YXRlOiBnZXRPcmlnaW5hbFN0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uOiBmdW5jdGlvbiAocHJlZGljYXRlLCB0aW1lb3V0KSB7IHJldHVybiB0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkudGhlbihCb29sZWFuKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRha2U6IHRha2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF1c2U6IGNyZWF0ZVBhdXNlKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiBleHRyYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JrOiBjcmVhdGVGb3JrKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLCBhdXRvSm9pblByb21pc2VzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBlbnRyeS51bnN1YnNjcmliZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVyczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlciwgXywgc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSBpbnRlcm5hbFRhc2tDb250cm9sbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldC5kZWxldGUoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyRXJyb3JfMSA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShsaXN0ZW5lckVycm9yXzEgaW5zdGFuY2VvZiBUYXNrQWJvcnRFcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgbGlzdGVuZXJFcnJvcl8xLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWlzZWRCeTogXCJlZmZlY3RcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsU2V0dGxlZChhdXRvSm9pblByb21pc2VzKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDb21wbGV0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7IH07XHJcbiAgICB2YXIgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZShsaXN0ZW5lck1hcCk7XHJcbiAgICB2YXIgbWlkZGxld2FyZSA9IGZ1bmN0aW9uIChhcGkpIHsgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7IHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFpc0FjdGlvbihhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhZGRMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFydExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjbGVhckFsbExpc3RlbmVycy5tYXRjaChhY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbW92ZUxpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0b3BMaXN0ZW5pbmcoYWN0aW9uLnBheWxvYWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3JpZ2luYWxTdGF0ZSA9IGFwaS5nZXRTdGF0ZSgpO1xyXG4gICAgICAgIHZhciBnZXRPcmlnaW5hbFN0YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAob3JpZ2luYWxTdGF0ZSA9PT0gSU5URVJOQUxfTklMX1RPS0VOKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYWxtICsgXCI6IGdldE9yaWdpbmFsU3RhdGUgY2FuIG9ubHkgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsU3RhdGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyTWFwLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJFbnRyaWVzID0gQXJyYXkuZnJvbShsaXN0ZW5lck1hcC52YWx1ZXMoKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGxpc3RlbmVyRW50cmllc18xID0gbGlzdGVuZXJFbnRyaWVzOyBfaSA8IGxpc3RlbmVyRW50cmllc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGxpc3RlbmVyRW50cmllc18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcnVuTGlzdGVuZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5MaXN0ZW5lciA9IGVudHJ5LnByZWRpY2F0ZShhY3Rpb24sIGN1cnJlbnRTdGF0ZSwgb3JpZ2luYWxTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChwcmVkaWNhdGVFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5MaXN0ZW5lciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBwcmVkaWNhdGVFcnJvciwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2VkQnk6IFwicHJlZGljYXRlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVuTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5vdGlmeUxpc3RlbmVyKGVudHJ5LCBhY3Rpb24sIGFwaSwgZ2V0T3JpZ2luYWxTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhdGUgPSBJTlRFUk5BTF9OSUxfVE9LRU47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9OyB9OyB9O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtaWRkbGV3YXJlOiBtaWRkbGV3YXJlLFxyXG4gICAgICAgIHN0YXJ0TGlzdGVuaW5nOiBzdGFydExpc3RlbmluZyxcclxuICAgICAgICBzdG9wTGlzdGVuaW5nOiBzdG9wTGlzdGVuaW5nLFxyXG4gICAgICAgIGNsZWFyTGlzdGVuZXJzOiBjbGVhckxpc3RlbmVyTWlkZGxld2FyZVxyXG4gICAgfTtcclxufVxyXG4vLyBzcmMvYXV0b0JhdGNoRW5oYW5jZXIudHNcclxudmFyIFNIT1VMRF9BVVRPQkFUQ0ggPSBcIlJUS19hdXRvQmF0Y2hcIjtcclxudmFyIHByZXBhcmVBdXRvQmF0Y2hlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7XHJcbiAgICB2YXIgX2M7XHJcbiAgICByZXR1cm4gKHtcclxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgIG1ldGE6IChfYyA9IHt9LCBfY1tTSE9VTERfQVVUT0JBVENIXSA9IHRydWUsIF9jKVxyXG4gICAgfSk7XHJcbn07IH07XHJcbnZhciBwcm9taXNlO1xyXG52YXIgcXVldWVNaWNyb3Rhc2tTaGltID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSBcImZ1bmN0aW9uXCIgPyBxdWV1ZU1pY3JvdGFzay5iaW5kKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogZ2xvYmFsVGhpcykgOiBmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIChwcm9taXNlIHx8IChwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkpKS50aGVuKGNiKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgIHRocm93IGVycjtcclxufSwgMCk7IH0pOyB9O1xyXG52YXIgY3JlYXRlUXVldWVXaXRoVGltZXIgPSBmdW5jdGlvbiAodGltZW91dCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub3RpZnkpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KG5vdGlmeSwgdGltZW91dCk7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgckFGID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKDEwKTtcclxudmFyIGF1dG9CYXRjaEVuaGFuY2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgdHlwZTogXCJyYWZcIiB9OyB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0b3JlID0gbmV4dC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xyXG4gICAgICAgIHZhciBub3RpZnlpbmcgPSB0cnVlO1xyXG4gICAgICAgIHZhciBzaG91bGROb3RpZnlBdEVuZE9mVGljayA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHZhciBxdWV1ZUNhbGxiYWNrID0gb3B0aW9ucy50eXBlID09PSBcInRpY2tcIiA/IHF1ZXVlTWljcm90YXNrU2hpbSA6IG9wdGlvbnMudHlwZSA9PT0gXCJyYWZcIiA/IHJBRiA6IG9wdGlvbnMudHlwZSA9PT0gXCJjYWxsYmFja1wiID8gb3B0aW9ucy5xdWV1ZU5vdGlmaWNhdGlvbiA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKG9wdGlvbnMudGltZW91dCk7XHJcbiAgICAgICAgdmFyIG5vdGlmeUxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbm90aWZpY2F0aW9uUXVldWVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsKCk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUsIHtcclxuICAgICAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAobGlzdGVuZXIyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZExpc3RlbmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbm90aWZ5aW5nICYmIGxpc3RlbmVyMigpOyB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gc3RvcmUuc3Vic2NyaWJlKHdyYXBwZWRMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyMik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcjIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm90aWZ5aW5nID0gISgoX2EgPSBhY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGlvbi5tZXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2FbU0hPVUxEX0FVVE9CQVRDSF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gIW5vdGlmeWluZztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub3RpZmljYXRpb25RdWV1ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZUNhbGxiYWNrKG5vdGlmeUxpc3RlbmVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICBub3RpZnlpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9OyB9O1xyXG59O1xyXG4vLyBzcmMvaW5kZXgudHNcclxuZW5hYmxlRVM1KCk7XHJcbmV4cG9ydCB7IEVuaGFuY2VyQXJyYXksIE1pZGRsZXdhcmVBcnJheSwgU0hPVUxEX0FVVE9CQVRDSCwgVGFza0Fib3J0RXJyb3IsIGFkZExpc3RlbmVyLCBhdXRvQmF0Y2hFbmhhbmNlciwgY2xlYXJBbGxMaXN0ZW5lcnMsIGNvbmZpZ3VyZVN0b3JlLCBjcmVhdGVBY3Rpb24sIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLCBjcmVhdGVBc3luY1RodW5rLCBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciwgY3JlYXRlRW50aXR5QWRhcHRlciwgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLCBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsIGRlZmF1bHQyIGFzIGNyZWF0ZU5leHRTdGF0ZSwgY3JlYXRlUmVkdWNlciwgY3JlYXRlU2VsZWN0b3IyIGFzIGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsIGNyZWF0ZVNsaWNlLCBjdXJyZW50MiBhcyBjdXJyZW50LCBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUsIGZyZWV6ZSwgZ2V0RGVmYXVsdE1pZGRsZXdhcmUsIGdldFR5cGUsIGlzQWN0aW9uLCBpc0FjdGlvbkNyZWF0b3IsIGlzQWxsT2YsIGlzQW55T2YsIGlzQXN5bmNUaHVua0FjdGlvbiwgaXNEcmFmdDQgYXMgaXNEcmFmdCwgaXNGU0EgYXMgaXNGbHV4U3RhbmRhcmRBY3Rpb24sIGlzRnVsZmlsbGVkLCBpc0ltbXV0YWJsZURlZmF1bHQsIGlzUGVuZGluZywgaXNQbGFpbiwgaXNQbGFpbk9iamVjdCwgaXNSZWplY3RlZCwgaXNSZWplY3RlZFdpdGhWYWx1ZSwgbWluaVNlcmlhbGl6ZUVycm9yLCBuYW5vaWQsIG9yaWdpbmFsLCBwcmVwYXJlQXV0b0JhdGNoZWQsIHJlbW92ZUxpc3RlbmVyLCB1bndyYXBSZXN1bHQgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdXgtdG9vbGtpdC5lc20uanMubWFwIl0sIm5hbWVzIjpbIl9fZXh0ZW5kcyIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fZ2VuZXJhdG9yIiwidGhpc0FyZyIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJuZXh0IiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibiIsInYiLCJzdGVwIiwib3AiLCJkb25lIiwidmFsdWUiLCJwb3AiLCJsZW5ndGgiLCJwdXNoIiwiZSIsIl9fc3ByZWFkQXJyYXkiLCJ0byIsImZyb20iLCJpIiwiaWwiLCJqIiwiX19kZWZQcm9wIiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZlByb3BzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9fZ2V0T3duUHJvcERlc2NzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsIl9fZ2V0T3duUHJvcFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJfX2hhc093blByb3AiLCJfX3Byb3BJc0VudW0iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fc3ByZWFkVmFsdWVzIiwiYSIsInByb3AiLCJfaSIsIl9jIiwiX19zcHJlYWRQcm9wcyIsIl9fYXN5bmMiLCJfX3RoaXMiLCJfX2FyZ3VtZW50cyIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJ0aHJvdyIsIngiLCJ0aGVuIiwiYXBwbHkiLCJlbmFibGVFUzUiLCJkZWZhdWx0IiwiZGVmYXVsdDIiLCJjdXJyZW50IiwiY3VycmVudDIiLCJmcmVlemUiLCJvcmlnaW5hbCIsImlzRHJhZnQiLCJpc0RyYWZ0NCIsImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlU2VsZWN0b3IyIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IiLCJhcmdzIiwiYXJndW1lbnRzIiwic2VsZWN0b3IiLCJ3cmFwcGVkU2VsZWN0b3IiLCJyZXN0IiwiY3JlYXRlU3RvcmUiLCJjb21wb3NlIiwiY29tcG9zZTIiLCJhcHBseU1pZGRsZXdhcmUiLCJjb21iaW5lUmVkdWNlcnMiLCJjb21wb3NlV2l0aERldlRvb2xzIiwid2luZG93IiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIiwiZGV2VG9vbHNFbmhhbmNlciIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18iLCJub29wMiIsImlzUGxhaW5PYmplY3QiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiYmFzZVByb3RvIiwidGh1bmtNaWRkbGV3YXJlIiwiaGFzTWF0Y2hGdW5jdGlvbiIsIm1hdGNoIiwiY3JlYXRlQWN0aW9uIiwidHlwZSIsInByZXBhcmVBY3Rpb24iLCJhY3Rpb25DcmVhdG9yIiwicHJlcGFyZWQiLCJFcnJvciIsInBheWxvYWQiLCJtZXRhIiwiZXJyb3IiLCJ0b1N0cmluZyIsImFjdGlvbiIsImlzQWN0aW9uIiwiaXNBY3Rpb25DcmVhdG9yIiwiaXNGU0EiLCJrZXlzIiwiZXZlcnkiLCJpc1ZhbGlkS2V5IiwiaW5kZXhPZiIsImdldFR5cGUiLCJnZXRNZXNzYWdlIiwic3BsaXRUeXBlIiwic3BsaXQiLCJhY3Rpb25OYW1lIiwiY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUiLCJvcHRpb25zIiwicHJvY2VzcyIsImlzQWN0aW9uQ3JlYXRvcjIiLCJjb25zb2xlIiwid2FybiIsImNyZWF0ZU5leHRTdGF0ZSIsImlzRHJhZnRhYmxlIiwiZ2V0VGltZU1lYXN1cmVVdGlscyIsIm1heERlbGF5IiwiZm5OYW1lIiwiZWxhcHNlZCIsIm1lYXN1cmVUaW1lIiwiZm4iLCJzdGFydGVkIiwiRGF0ZSIsIm5vdyIsImZpbmlzaGVkIiwid2FybklmRXhjZWVkZWQiLCJNaWRkbGV3YXJlQXJyYXkiLCJfc3VwZXIiLCJfdGhpcyIsInNwZWNpZXMiLCJnZXQiLCJjb25jYXQiLCJhcnIiLCJwcmVwZW5kIiwiaXNBcnJheSIsImJpbmQiLCJFbmhhbmNlckFycmF5IiwiZnJlZXplRHJhZnRhYmxlIiwidmFsIiwiaXNQcm9kdWN0aW9uIiwicHJlZml4IiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsInN0cmluZ2lmeSIsInNlcmlhbGl6ZXIiLCJpbmRlbnQiLCJkZWN5Y2xlciIsIkpTT04iLCJnZXRTZXJpYWxpemUiLCJzdGFjayIsInNsaWNlIiwiam9pbiIsInRoaXNQb3MiLCJzcGxpY2UiLCJJbmZpbml0eSIsImlzSW1tdXRhYmxlRGVmYXVsdCIsImlzRnJvemVuIiwidHJhY2tGb3JNdXRhdGlvbnMiLCJpc0ltbXV0YWJsZSIsImlnbm9yZVBhdGhzIiwidHJhY2tlZFByb3BlcnRpZXMiLCJ0cmFja1Byb3BlcnRpZXMiLCJkZXRlY3RNdXRhdGlvbnMiLCJwYXRoIiwiY2hlY2tlZE9iamVjdHMiLCJTZXQiLCJ0cmFja2VkIiwiaGFzIiwiYWRkIiwiY2hpbGRyZW4iLCJjaGlsZFBhdGgiLCJpZ25vcmVkUGF0aHMiLCJ0cmFja2VkUHJvcGVydHkiLCJzYW1lUGFyZW50UmVmIiwicHJldk9iaiIsInNhbWVSZWYiLCJOdW1iZXIiLCJpc05hTiIsIndhc011dGF0ZWQiLCJrZXlzVG9EZXRlY3QiLCJoYXNJZ25vcmVkUGF0aHMiLCJfbG9vcF8xIiwibmVzdGVkUGF0aCIsImhhc01hdGNoZXMiLCJzb21lIiwiaWdub3JlZCIsIlJlZ0V4cCIsInRlc3QiLCJyZXN1bHQiLCJzdGF0ZV8xIiwiY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIiwiX2QiLCJ3YXJuQWZ0ZXIiLCJpZ25vcmUiLCJ0cmFjayIsImdldFN0YXRlIiwic3RhdGUiLCJ0cmFja2VyIiwibWVhc3VyZVV0aWxzIiwiZGlzcGF0Y2hlZEFjdGlvbiIsImlzUGxhaW4iLCJmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJpc1NlcmlhbGl6YWJsZSIsImdldEVudHJpZXMiLCJjYWNoZSIsImZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIiwia2V5UGF0aCIsImVudHJpZXMiLCJfbG9vcF8yIiwibmVzdGVkVmFsdWUiLCJlbnRyaWVzXzEiLCJzdGF0ZV8yIiwiaXNOZXN0ZWRGcm96ZW4iLCJ2YWx1ZXMiLCJjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJpZ25vcmVkQWN0aW9ucyIsIl9lIiwiaWdub3JlZEFjdGlvblBhdGhzIiwiX2YiLCJfZyIsIl9oIiwiaWdub3JlU3RhdGUiLCJfaiIsImlnbm9yZUFjdGlvbnMiLCJfayIsImRpc2FibGVDYWNoZSIsIldlYWtTZXQiLCJzdG9yZUFQSSIsImZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJpc0Jvb2xlYW4iLCJjdXJyeUdldERlZmF1bHRNaWRkbGV3YXJlIiwiY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlIiwiZ2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJ0aHVuayIsImltbXV0YWJsZUNoZWNrIiwic2VyaWFsaXphYmxlQ2hlY2siLCJhY3Rpb25DcmVhdG9yQ2hlY2siLCJtaWRkbGV3YXJlQXJyYXkiLCJ3aXRoRXh0cmFBcmd1bWVudCIsImV4dHJhQXJndW1lbnQiLCJpbW11dGFibGVPcHRpb25zIiwidW5zaGlmdCIsInNlcmlhbGl6YWJsZU9wdGlvbnMiLCJhY3Rpb25DcmVhdG9yT3B0aW9ucyIsIklTX1BST0RVQ1RJT04iLCJjb25maWd1cmVTdG9yZSIsInJlZHVjZXIiLCJtaWRkbGV3YXJlIiwiZGV2VG9vbHMiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VycyIsInJvb3RSZWR1Y2VyIiwiZmluYWxNaWRkbGV3YXJlIiwiaXRlbSIsIm1pZGRsZXdhcmVFbmhhbmNlciIsImZpbmFsQ29tcG9zZSIsInRyYWNlIiwiZGVmYXVsdEVuaGFuY2VycyIsInN0b3JlRW5oYW5jZXJzIiwiY29tcG9zZWRFbmhhbmNlciIsImNyZWF0ZU5leHRTdGF0ZTIiLCJpc0RyYWZ0MiIsImlzRHJhZnRhYmxlMiIsImV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrIiwiYnVpbGRlckNhbGxiYWNrIiwiYWN0aW9uc01hcCIsImFjdGlvbk1hdGNoZXJzIiwiZGVmYXVsdENhc2VSZWR1Y2VyIiwiYnVpbGRlciIsImFkZENhc2UiLCJ0eXBlT3JBY3Rpb25DcmVhdG9yIiwiYWRkTWF0Y2hlciIsIm1hdGNoZXIiLCJhZGREZWZhdWx0Q2FzZSIsImlzU3RhdGVGdW5jdGlvbiIsImhhc1dhcm5lZEFib3V0T2JqZWN0Tm90YXRpb24iLCJjcmVhdGVSZWR1Y2VyIiwiaW5pdGlhbFN0YXRlIiwibWFwT3JCdWlsZGVyQ2FsbGJhY2siLCJmaW5hbEFjdGlvbk1hdGNoZXJzIiwiZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXIiLCJnZXRJbml0aWFsU3RhdGUiLCJmcm96ZW5Jbml0aWFsU3RhdGVfMSIsImNhc2VSZWR1Y2VycyIsImZpbHRlciIsIm1hcCIsInJlZHVjZXIyIiwiY3IiLCJyZWR1Y2UiLCJwcmV2aW91c1N0YXRlIiwiY2FzZVJlZHVjZXIiLCJkcmFmdCIsImhhc1dhcm5lZEFib3V0T2JqZWN0Tm90YXRpb24yIiwiZ2V0VHlwZTIiLCJhY3Rpb25LZXkiLCJjcmVhdGVTbGljZSIsIm5hbWUiLCJyZWR1Y2VycyIsInJlZHVjZXJOYW1lcyIsInNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lIiwic2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUiLCJhY3Rpb25DcmVhdG9ycyIsImZvckVhY2giLCJyZWR1Y2VyTmFtZSIsIm1heWJlUmVkdWNlcldpdGhQcmVwYXJlIiwicHJlcGFyZUNhbGxiYWNrIiwicHJlcGFyZSIsImJ1aWxkUmVkdWNlciIsImV4dHJhUmVkdWNlcnMiLCJmaW5hbENhc2VSZWR1Y2VycyIsImFjdGlvbk1hdGNoZXJzXzEiLCJtIiwiX3JlZHVjZXIiLCJhY3Rpb25zIiwiZ2V0SW5pdGlhbEVudGl0eVN0YXRlIiwiaWRzIiwiZW50aXRpZXMiLCJjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5IiwiYWRkaXRpb25hbFN0YXRlIiwiYXNzaWduIiwiY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSIsImdldFNlbGVjdG9ycyIsInNlbGVjdFN0YXRlIiwic2VsZWN0SWRzIiwic2VsZWN0RW50aXRpZXMiLCJzZWxlY3RBbGwiLCJpZCIsInNlbGVjdElkIiwic2VsZWN0QnlJZCIsInNlbGVjdFRvdGFsIiwic2VsZWN0R2xvYmFsaXplZEVudGl0aWVzIiwiY3JlYXRlTmV4dFN0YXRlMyIsImlzRHJhZnQzIiwiY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yIiwibXV0YXRvciIsIm9wZXJhdG9yIiwiY3JlYXRlU3RhdGVPcGVyYXRvciIsIm9wZXJhdGlvbiIsImFyZyIsImlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50IiwiYXJnMiIsInJ1bk11dGF0b3IiLCJzZWxlY3RJZFZhbHVlIiwiZW50aXR5IiwiZW5zdXJlRW50aXRpZXNBcnJheSIsInNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMiLCJuZXdFbnRpdGllcyIsImFkZGVkIiwidXBkYXRlZCIsIm5ld0VudGl0aWVzXzEiLCJjaGFuZ2VzIiwiY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJhZGRPbmVNdXRhYmx5IiwiYWRkTWFueU11dGFibHkiLCJuZXdFbnRpdGllc18yIiwic2V0T25lTXV0YWJseSIsInNldE1hbnlNdXRhYmx5IiwibmV3RW50aXRpZXNfMyIsInNldEFsbE11dGFibHkiLCJyZW1vdmVPbmVNdXRhYmx5IiwicmVtb3ZlTWFueU11dGFibHkiLCJkaWRNdXRhdGUiLCJyZW1vdmVBbGxNdXRhYmx5IiwidGFrZU5ld0tleSIsInVwZGF0ZSIsIm9yaWdpbmFsMiIsIm5ld0tleSIsImhhc05ld0tleSIsInVwZGF0ZU9uZU11dGFibHkiLCJ1cGRhdGVNYW55TXV0YWJseSIsInVwZGF0ZXMiLCJuZXdLZXlzIiwidXBkYXRlc1BlckVudGl0eSIsImRpZE11dGF0ZUVudGl0aWVzIiwiZGlkTXV0YXRlSWRzIiwidXBzZXJ0T25lTXV0YWJseSIsInVwc2VydE1hbnlNdXRhYmx5IiwicmVtb3ZlQWxsIiwiYWRkT25lIiwiYWRkTWFueSIsInNldE9uZSIsInNldE1hbnkiLCJzZXRBbGwiLCJ1cGRhdGVPbmUiLCJ1cGRhdGVNYW55IiwidXBzZXJ0T25lIiwidXBzZXJ0TWFueSIsInJlbW92ZU9uZSIsInJlbW92ZU1hbnkiLCJjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJzb3J0IiwibW9kZWxzIiwibW9kZWwiLCJtZXJnZSIsImFwcGxpZWRVcGRhdGVzIiwidXBkYXRlc18xIiwibmV3SWQiLCJyZXNvcnRFbnRpdGllcyIsImFyZUFycmF5c0VxdWFsIiwiYWxsRW50aXRpZXMiLCJuZXdTb3J0ZWRJZHMiLCJjcmVhdGVFbnRpdHlBZGFwdGVyIiwic29ydENvbXBhcmVyIiwiaW5zdGFuY2UiLCJzdGF0ZUZhY3RvcnkiLCJzZWxlY3RvcnNGYWN0b3J5Iiwic3RhdGVBZGFwdGVyIiwidXJsQWxwaGFiZXQiLCJuYW5vaWQiLCJzaXplIiwiTWF0aCIsInJhbmRvbSIsImNvbW1vblByb3BlcnRpZXMiLCJSZWplY3RXaXRoVmFsdWUiLCJGdWxmaWxsV2l0aE1ldGEiLCJtaW5pU2VyaWFsaXplRXJyb3IiLCJzaW1wbGVFcnJvciIsImNvbW1vblByb3BlcnRpZXNfMSIsInByb3BlcnR5IiwiY3JlYXRlQXN5bmNUaHVuayIsImNyZWF0ZUFzeW5jVGh1bmsyIiwidHlwZVByZWZpeCIsInBheWxvYWRDcmVhdG9yIiwicmVxdWVzdElkIiwicmVxdWVzdFN0YXR1cyIsInBlbmRpbmciLCJzZXJpYWxpemVFcnJvciIsInJlamVjdGVkV2l0aFZhbHVlIiwiYWJvcnRlZCIsImRpc3BsYXllZFdhcm5pbmciLCJBQyIsIkFib3J0Q29udHJvbGxlciIsImNsYXNzXzEiLCJzaWduYWwiLCJhZGRFdmVudExpc3RlbmVyIiwiZGlzcGF0Y2hFdmVudCIsIm9uYWJvcnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVhc29uIiwidGhyb3dJZkFib3J0ZWQiLCJhYm9ydCIsImluZm8iLCJkaXNwYXRjaCIsImV4dHJhIiwiaWRHZW5lcmF0b3IiLCJhYm9ydENvbnRyb2xsZXIiLCJhYm9ydFJlYXNvbiIsInByb21pc2UyIiwiX2EiLCJfYiIsImZpbmFsQWN0aW9uIiwiY29uZGl0aW9uUmVzdWx0IiwiYWJvcnRlZFByb21pc2UiLCJlcnJfMSIsInNraXBEaXNwYXRjaCIsImlzVGhlbmFibGUiLCJnZXRQZW5kaW5nTWV0YSIsInJhY2UiLCJyZWplY3RXaXRoVmFsdWUiLCJmdWxmaWxsV2l0aFZhbHVlIiwiZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24iLCJ1bndyYXAiLCJ1bndyYXBSZXN1bHQiLCJ3aXRoVHlwZXMiLCJtYXRjaGVzIiwiaXNBbnlPZiIsIm1hdGNoZXJzIiwiaXNBbGxPZiIsImhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhIiwidmFsaWRTdGF0dXMiLCJoYXNWYWxpZFJlcXVlc3RJZCIsImhhc1ZhbGlkUmVxdWVzdFN0YXR1cyIsImlzQXN5bmNUaHVua0FycmF5IiwiaXNQZW5kaW5nIiwiYXN5bmNUaHVua3MiLCJhc3luY1RodW5rIiwiY29tYmluZWRNYXRjaGVyIiwiaXNSZWplY3RlZCIsImlzUmVqZWN0ZWRXaXRoVmFsdWUiLCJoYXNGbGFnIiwiaXNGdWxmaWxsZWQiLCJpc0FzeW5jVGh1bmtBY3Rpb24iLCJhc3luY1RodW5rc18xIiwiYXNzZXJ0RnVuY3Rpb24iLCJmdW5jIiwiZXhwZWN0ZWQiLCJub29wIiwiY2F0Y2hSZWplY3Rpb24iLCJvbkVycm9yIiwiY2F0Y2giLCJhZGRBYm9ydFNpZ25hbExpc3RlbmVyIiwiYWJvcnRTaWduYWwiLCJjYWxsYmFjayIsIm9uY2UiLCJhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uIiwidGFzayIsImxpc3RlbmVyIiwiY29tcGxldGVkIiwiY2FuY2VsbGVkIiwidGFza0NhbmNlbGxlZCIsInRhc2tDb21wbGV0ZWQiLCJsaXN0ZW5lckNhbmNlbGxlZCIsImxpc3RlbmVyQ29tcGxldGVkIiwiVGFza0Fib3J0RXJyb3IiLCJjb2RlIiwidmFsaWRhdGVBY3RpdmUiLCJyYWNlV2l0aFNpZ25hbCIsImNsZWFudXAiLCJub3RpZnlSZWplY3Rpb24iLCJmaW5hbGx5IiwicnVuVGFzayIsInRhc2syIiwiY2xlYW5VcCIsImVycm9yXzEiLCJzdGF0dXMiLCJjcmVhdGVQYXVzZSIsIm91dHB1dCIsImNyZWF0ZURlbGF5IiwicGF1c2UiLCJ0aW1lb3V0TXMiLCJzZXRUaW1lb3V0IiwiSU5URVJOQUxfTklMX1RPS0VOIiwiYWxtIiwiY3JlYXRlRm9yayIsInBhcmVudEFib3J0U2lnbmFsIiwicGFyZW50QmxvY2tpbmdQcm9taXNlcyIsImxpbmtDb250cm9sbGVycyIsImNvbnRyb2xsZXIiLCJ0YXNrRXhlY3V0b3IiLCJvcHRzIiwiY2hpbGRBYm9ydENvbnRyb2xsZXIiLCJyZXN1bHQyIiwiZGVsYXkiLCJhdXRvSm9pbiIsImNhbmNlbCIsImNyZWF0ZVRha2VQYXR0ZXJuIiwic3RhcnRMaXN0ZW5pbmciLCJ0YWtlIiwicHJlZGljYXRlIiwidGltZW91dCIsInVuc3Vic2NyaWJlIiwidHVwbGVQcm9taXNlIiwicHJvbWlzZXMiLCJzdG9wTGlzdGVuaW5nIiwiZWZmZWN0IiwibGlzdGVuZXJBcGkiLCJnZXRPcmlnaW5hbFN0YXRlIiwiZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbSIsImNyZWF0ZUxpc3RlbmVyRW50cnkiLCJlbnRyeSIsImNhbmNlbEFjdGl2ZUxpc3RlbmVycyIsImNyZWF0ZUNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlIiwibGlzdGVuZXJNYXAiLCJjbGVhciIsInNhZmVseU5vdGlmeUVycm9yIiwiZXJyb3JIYW5kbGVyIiwiZXJyb3JUb05vdGlmeSIsImVycm9ySW5mbyIsImVycm9ySGFuZGxlckVycm9yIiwiYWRkTGlzdGVuZXIiLCJjbGVhckFsbExpc3RlbmVycyIsInJlbW92ZUxpc3RlbmVyIiwiZGVmYXVsdEVycm9ySGFuZGxlciIsImNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZSIsIm1pZGRsZXdhcmVPcHRpb25zIiwiTWFwIiwiaW5zZXJ0RW50cnkiLCJkZWxldGUiLCJzZXQiLCJjYW5jZWxPcHRpb25zIiwiY2FuY2VsQWN0aXZlIiwiZmluZExpc3RlbmVyRW50cnkiLCJjb21wYXJhdG9yIiwiZXhpc3RpbmdFbnRyeSIsImVudHJ5MiIsIm1hdGNoUHJlZGljYXRlT3JUeXBlIiwibm90aWZ5TGlzdGVuZXIiLCJhcGkiLCJpbnRlcm5hbFRhc2tDb250cm9sbGVyIiwiYXV0b0pvaW5Qcm9taXNlcyIsImxpc3RlbmVyRXJyb3JfMSIsIkJvb2xlYW4iLCJmb3JrIiwic3Vic2NyaWJlIiwicmFpc2VkQnkiLCJhbGxTZXR0bGVkIiwiY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUiLCJvcmlnaW5hbFN0YXRlIiwiY3VycmVudFN0YXRlIiwibGlzdGVuZXJFbnRyaWVzIiwibGlzdGVuZXJFbnRyaWVzXzEiLCJydW5MaXN0ZW5lciIsInByZWRpY2F0ZUVycm9yIiwiY2xlYXJMaXN0ZW5lcnMiLCJTSE9VTERfQVVUT0JBVENIIiwicHJlcGFyZUF1dG9CYXRjaGVkIiwicHJvbWlzZSIsInF1ZXVlTWljcm90YXNrU2hpbSIsInF1ZXVlTWljcm90YXNrIiwiZ2xvYmFsIiwiZ2xvYmFsVGhpcyIsImNiIiwiZXJyIiwiY3JlYXRlUXVldWVXaXRoVGltZXIiLCJub3RpZnkiLCJyQUYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhdXRvQmF0Y2hFbmhhbmNlciIsInN0b3JlIiwibm90aWZ5aW5nIiwic2hvdWxkTm90aWZ5QXRFbmRPZlRpY2siLCJub3RpZmljYXRpb25RdWV1ZWQiLCJsaXN0ZW5lcnMiLCJxdWV1ZUNhbGxiYWNrIiwicXVldWVOb3RpZmljYXRpb24iLCJub3RpZnlMaXN0ZW5lcnMiLCJsIiwibGlzdGVuZXIyIiwid3JhcHBlZExpc3RlbmVyIiwiaXNGbHV4U3RhbmRhcmRBY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/node_modules/redux-thunk/es/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/node_modules/redux-thunk/es/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/** A function that accepts a potential \"extra argument\" value to be injected later,\r\n * and returns an instance of the thunk middleware that uses that value\r\n */ function createThunkMiddleware(extraArgument) {\n    // Standard Redux middleware definition pattern:\n    // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware\n    var middleware = function middleware(_ref) {\n        var dispatch = _ref.dispatch, getState = _ref.getState;\n        return function(next) {\n            return function(action) {\n                // The thunk middleware looks for any functions that were passed to `store.dispatch`.\n                // If this \"action\" is really a function, call it and return the result.\n                if (typeof action === \"function\") {\n                    // Inject the store's `dispatch` and `getState` methods, as well as any \"extra arg\"\n                    return action(dispatch, getState, extraArgument);\n                } // Otherwise, pass the action down the middleware chain as usual\n                return next(action);\n            };\n        };\n    };\n    return middleware;\n}\nvar thunk = createThunkMiddleware(); // Attach the factory function so users can create a customized version\n// with whatever \"extra arg\" they want to inject into their thunks\nthunk.withExtraArgument = createThunkMiddleware;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (thunk);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9ub2RlX21vZHVsZXMvcmVkdXgtdGh1bmsvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztDQUVDLEdBQ0QsU0FBU0Esc0JBQXNCQyxhQUFhO0lBQzFDLGdEQUFnRDtJQUNoRCwwRkFBMEY7SUFDMUYsSUFBSUMsYUFBYSxTQUFTQSxXQUFXQyxJQUFJO1FBQ3ZDLElBQUlDLFdBQVdELEtBQUtDLFFBQVEsRUFDeEJDLFdBQVdGLEtBQUtFLFFBQVE7UUFDNUIsT0FBTyxTQUFVQyxJQUFJO1lBQ25CLE9BQU8sU0FBVUMsTUFBTTtnQkFDckIscUZBQXFGO2dCQUNyRix3RUFBd0U7Z0JBQ3hFLElBQUksT0FBT0EsV0FBVyxZQUFZO29CQUNoQyxtRkFBbUY7b0JBQ25GLE9BQU9BLE9BQU9ILFVBQVVDLFVBQVVKO2dCQUNwQyxFQUFFLGdFQUFnRTtnQkFHbEUsT0FBT0ssS0FBS0M7WUFDZDtRQUNGO0lBQ0Y7SUFFQSxPQUFPTDtBQUNUO0FBRUEsSUFBSU0sUUFBUVIseUJBQXlCLHVFQUF1RTtBQUM1RyxrRUFBa0U7QUFFbEVRLE1BQU1DLGlCQUFpQixHQUFHVDtBQUMxQixpRUFBZVEsS0FBS0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2thZ2Uuc3RvcmUvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9ub2RlX21vZHVsZXMvcmVkdXgtdGh1bmsvZXMvaW5kZXguanM/YTE0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYSBwb3RlbnRpYWwgXCJleHRyYSBhcmd1bWVudFwiIHZhbHVlIHRvIGJlIGluamVjdGVkIGxhdGVyLFxyXG4gKiBhbmQgcmV0dXJucyBhbiBpbnN0YW5jZSBvZiB0aGUgdGh1bmsgbWlkZGxld2FyZSB0aGF0IHVzZXMgdGhhdCB2YWx1ZVxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRodW5rTWlkZGxld2FyZShleHRyYUFyZ3VtZW50KSB7XG4gIC8vIFN0YW5kYXJkIFJlZHV4IG1pZGRsZXdhcmUgZGVmaW5pdGlvbiBwYXR0ZXJuOlxuICAvLyBTZWU6IGh0dHBzOi8vcmVkdXguanMub3JnL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcGFydC00LXN0b3JlI3dyaXRpbmctY3VzdG9tLW1pZGRsZXdhcmVcbiAgdmFyIG1pZGRsZXdhcmUgPSBmdW5jdGlvbiBtaWRkbGV3YXJlKF9yZWYpIHtcbiAgICB2YXIgZGlzcGF0Y2ggPSBfcmVmLmRpc3BhdGNoLFxuICAgICAgICBnZXRTdGF0ZSA9IF9yZWYuZ2V0U3RhdGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAvLyBUaGUgdGh1bmsgbWlkZGxld2FyZSBsb29rcyBmb3IgYW55IGZ1bmN0aW9ucyB0aGF0IHdlcmUgcGFzc2VkIHRvIGBzdG9yZS5kaXNwYXRjaGAuXG4gICAgICAgIC8vIElmIHRoaXMgXCJhY3Rpb25cIiBpcyByZWFsbHkgYSBmdW5jdGlvbiwgY2FsbCBpdCBhbmQgcmV0dXJuIHRoZSByZXN1bHQuXG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gSW5qZWN0IHRoZSBzdG9yZSdzIGBkaXNwYXRjaGAgYW5kIGBnZXRTdGF0ZWAgbWV0aG9kcywgYXMgd2VsbCBhcyBhbnkgXCJleHRyYSBhcmdcIlxuICAgICAgICAgIHJldHVybiBhY3Rpb24oZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYUFyZ3VtZW50KTtcbiAgICAgICAgfSAvLyBPdGhlcndpc2UsIHBhc3MgdGhlIGFjdGlvbiBkb3duIHRoZSBtaWRkbGV3YXJlIGNoYWluIGFzIHVzdWFsXG5cblxuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBtaWRkbGV3YXJlO1xufVxuXG52YXIgdGh1bmsgPSBjcmVhdGVUaHVua01pZGRsZXdhcmUoKTsgLy8gQXR0YWNoIHRoZSBmYWN0b3J5IGZ1bmN0aW9uIHNvIHVzZXJzIGNhbiBjcmVhdGUgYSBjdXN0b21pemVkIHZlcnNpb25cbi8vIHdpdGggd2hhdGV2ZXIgXCJleHRyYSBhcmdcIiB0aGV5IHdhbnQgdG8gaW5qZWN0IGludG8gdGhlaXIgdGh1bmtzXG5cbnRodW5rLndpdGhFeHRyYUFyZ3VtZW50ID0gY3JlYXRlVGh1bmtNaWRkbGV3YXJlO1xuZXhwb3J0IGRlZmF1bHQgdGh1bms7Il0sIm5hbWVzIjpbImNyZWF0ZVRodW5rTWlkZGxld2FyZSIsImV4dHJhQXJndW1lbnQiLCJtaWRkbGV3YXJlIiwiX3JlZiIsImRpc3BhdGNoIiwiZ2V0U3RhdGUiLCJuZXh0IiwiYWN0aW9uIiwidGh1bmsiLCJ3aXRoRXh0cmFBcmd1bWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/node_modules/redux-thunk/es/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/node_modules/redux/es/redux.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/node_modules/redux/es/redux.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* binding */ ActionTypes),\n/* harmony export */   applyMiddleware: () => (/* binding */ applyMiddleware),\n/* harmony export */   bindActionCreators: () => (/* binding */ bindActionCreators),\n/* harmony export */   combineReducers: () => (/* binding */ combineReducers),\n/* harmony export */   compose: () => (/* binding */ compose),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   legacy_createStore: () => (/* binding */ legacy_createStore)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread2 */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/objectSpread2.js\");\n\n/**\n * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js\n *\n * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes\n * during build.\n * @param {number} code\n */ function formatProdErrorMessage(code) {\n    return \"Minified Redux error #\" + code + \"; visit https://redux.js.org/Errors?code=\" + code + \" for the full message or \" + \"use the non-minified dev environment for full errors. \";\n}\n// Inlined version of the `symbol-observable` polyfill\nvar $$observable = function() {\n    return typeof Symbol === \"function\" && Symbol.observable || \"@@observable\";\n}();\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */ var randomString = function randomString() {\n    return Math.random().toString(36).substring(7).split(\"\").join(\".\");\n};\nvar ActionTypes = {\n    INIT: \"@@redux/INIT\" + randomString(),\n    REPLACE: \"@@redux/REPLACE\" + randomString(),\n    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n        return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\n    }\n};\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */ function isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    var proto = obj;\n    while(Object.getPrototypeOf(proto) !== null){\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(obj) === proto;\n}\n// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of\nfunction miniKindOf(val) {\n    if (val === void 0) return \"undefined\";\n    if (val === null) return \"null\";\n    var type = typeof val;\n    switch(type){\n        case \"boolean\":\n        case \"string\":\n        case \"number\":\n        case \"symbol\":\n        case \"function\":\n            {\n                return type;\n            }\n    }\n    if (Array.isArray(val)) return \"array\";\n    if (isDate(val)) return \"date\";\n    if (isError(val)) return \"error\";\n    var constructorName = ctorName(val);\n    switch(constructorName){\n        case \"Symbol\":\n        case \"Promise\":\n        case \"WeakMap\":\n        case \"WeakSet\":\n        case \"Map\":\n        case \"Set\":\n            return constructorName;\n    } // other\n    return type.slice(8, -1).toLowerCase().replace(/\\s/g, \"\");\n}\nfunction ctorName(val) {\n    return typeof val.constructor === \"function\" ? val.constructor.name : null;\n}\nfunction isError(val) {\n    return val instanceof Error || typeof val.message === \"string\" && val.constructor && typeof val.constructor.stackTraceLimit === \"number\";\n}\nfunction isDate(val) {\n    if (val instanceof Date) return true;\n    return typeof val.toDateString === \"function\" && typeof val.getDate === \"function\" && typeof val.setDate === \"function\";\n}\nfunction kindOf(val) {\n    var typeOfVal = typeof val;\n    if (true) {\n        typeOfVal = miniKindOf(val);\n    }\n    return typeOfVal;\n}\n/**\n * @deprecated\n *\n * **We recommend using the `configureStore` method\n * of the `@reduxjs/toolkit` package**, which replaces `createStore`.\n *\n * Redux Toolkit is our recommended approach for writing Redux logic today,\n * including store setup, reducers, data fetching, and more.\n *\n * **For more details, please read this Redux docs page:**\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * `configureStore` from Redux Toolkit is an improved version of `createStore` that\n * simplifies setup and helps avoid common bugs.\n *\n * You should not be using the `redux` core package by itself today, except for learning purposes.\n * The `createStore` method from the core `redux` package will not be removed, but we encourage\n * all users to migrate to using Redux Toolkit for all Redux code.\n *\n * If you want to use `createStore` without this visual deprecation warning, use\n * the `legacy_createStore` import instead:\n *\n * `import { legacy_createStore as createStore} from 'redux'`\n *\n */ function createStore(reducer, preloadedState, enhancer) {\n    var _ref2;\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"function\" || typeof enhancer === \"function\" && typeof arguments[3] === \"function\") {\n        throw new Error( false ? 0 : \"It looks like you are passing several store enhancers to \" + \"createStore(). This is not supported. Instead, compose them \" + \"together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.\");\n    }\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n        enhancer = preloadedState;\n        preloadedState = undefined;\n    }\n    if (typeof enhancer !== \"undefined\") {\n        if (typeof enhancer !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the enhancer to be a function. Instead, received: '\" + kindOf(enhancer) + \"'\");\n        }\n        return enhancer(createStore)(reducer, preloadedState);\n    }\n    if (typeof reducer !== \"function\") {\n        throw new Error( false ? 0 : \"Expected the root reducer to be a function. Instead, received: '\" + kindOf(reducer) + \"'\");\n    }\n    var currentReducer = reducer;\n    var currentState = preloadedState;\n    var currentListeners = [];\n    var nextListeners = currentListeners;\n    var isDispatching = false;\n    /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */ function ensureCanMutateNextListeners() {\n        if (nextListeners === currentListeners) {\n            nextListeners = currentListeners.slice();\n        }\n    }\n    /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */ function getState() {\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"You may not call store.getState() while the reducer is executing. \" + \"The reducer has already received the state as an argument. \" + \"Pass it down from the top reducer instead of reading it from the store.\");\n        }\n        return currentState;\n    }\n    /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */ function subscribe(listener) {\n        if (typeof listener !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the listener to be a function. Instead, received: '\" + kindOf(listener) + \"'\");\n        }\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"You may not call store.subscribe() while the reducer is executing. \" + \"If you would like to be notified after the store has been updated, subscribe from a \" + \"component and invoke store.getState() in the callback to access the latest state. \" + \"See https://redux.js.org/api/store#subscribelistener for more details.\");\n        }\n        var isSubscribed = true;\n        ensureCanMutateNextListeners();\n        nextListeners.push(listener);\n        return function unsubscribe() {\n            if (!isSubscribed) {\n                return;\n            }\n            if (isDispatching) {\n                throw new Error( false ? 0 : \"You may not unsubscribe from a store listener while the reducer is executing. \" + \"See https://redux.js.org/api/store#subscribelistener for more details.\");\n            }\n            isSubscribed = false;\n            ensureCanMutateNextListeners();\n            var index = nextListeners.indexOf(listener);\n            nextListeners.splice(index, 1);\n            currentListeners = null;\n        };\n    }\n    /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing what changed. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */ function dispatch(action) {\n        if (!isPlainObject(action)) {\n            throw new Error( false ? 0 : \"Actions must be plain objects. Instead, the actual type was: '\" + kindOf(action) + \"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.\");\n        }\n        if (typeof action.type === \"undefined\") {\n            throw new Error( false ? 0 : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n        }\n        if (isDispatching) {\n            throw new Error( false ? 0 : \"Reducers may not dispatch actions.\");\n        }\n        try {\n            isDispatching = true;\n            currentState = currentReducer(currentState, action);\n        } finally{\n            isDispatching = false;\n        }\n        var listeners = currentListeners = nextListeners;\n        for(var i = 0; i < listeners.length; i++){\n            var listener = listeners[i];\n            listener();\n        }\n        return action;\n    }\n    /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */ function replaceReducer(nextReducer) {\n        if (typeof nextReducer !== \"function\") {\n            throw new Error( false ? 0 : \"Expected the nextReducer to be a function. Instead, received: '\" + kindOf(nextReducer));\n        }\n        currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.\n        // Any reducers that existed in both the new and old rootReducer\n        // will receive the previous state. This effectively populates\n        // the new state tree with any relevant data from the old one.\n        dispatch({\n            type: ActionTypes.REPLACE\n        });\n    }\n    /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */ function observable() {\n        var _ref;\n        var outerSubscribe = subscribe;\n        return _ref = {\n            /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */ subscribe: function subscribe(observer) {\n                if (typeof observer !== \"object\" || observer === null) {\n                    throw new Error( false ? 0 : \"Expected the observer to be an object. Instead, received: '\" + kindOf(observer) + \"'\");\n                }\n                function observeState() {\n                    if (observer.next) {\n                        observer.next(getState());\n                    }\n                }\n                observeState();\n                var unsubscribe = outerSubscribe(observeState);\n                return {\n                    unsubscribe: unsubscribe\n                };\n            }\n        }, _ref[$$observable] = function() {\n            return this;\n        }, _ref;\n    } // When a store is created, an \"INIT\" action is dispatched so that every\n    // reducer returns their initial state. This effectively populates\n    // the initial state tree.\n    dispatch({\n        type: ActionTypes.INIT\n    });\n    return _ref2 = {\n        dispatch: dispatch,\n        subscribe: subscribe,\n        getState: getState,\n        replaceReducer: replaceReducer\n    }, _ref2[$$observable] = observable, _ref2;\n}\n/**\n * Creates a Redux store that holds the state tree.\n *\n * **We recommend using `configureStore` from the\n * `@reduxjs/toolkit` package**, which replaces `createStore`:\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */ var legacy_createStore = createStore;\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */ function warning(message) {\n    /* eslint-disable no-console */ if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(message);\n    }\n    /* eslint-enable no-console */ try {\n        // This error was thrown as a convenience so that if you enable\n        // \"break on all exceptions\" in your console,\n        // it would pause the execution at this line.\n        throw new Error(message);\n    } catch (e) {} // eslint-disable-line no-empty\n}\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n    var reducerKeys = Object.keys(reducers);\n    var argumentName = action && action.type === ActionTypes.INIT ? \"preloadedState argument passed to createStore\" : \"previous state received by the reducer\";\n    if (reducerKeys.length === 0) {\n        return \"Store does not have a valid reducer. Make sure the argument passed \" + \"to combineReducers is an object whose values are reducers.\";\n    }\n    if (!isPlainObject(inputState)) {\n        return \"The \" + argumentName + ' has unexpected type of \"' + kindOf(inputState) + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n    }\n    var unexpectedKeys = Object.keys(inputState).filter(function(key) {\n        return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n    });\n    unexpectedKeys.forEach(function(key) {\n        unexpectedKeyCache[key] = true;\n    });\n    if (action && action.type === ActionTypes.REPLACE) return;\n    if (unexpectedKeys.length > 0) {\n        return \"Unexpected \" + (unexpectedKeys.length > 1 ? \"keys\" : \"key\") + \" \" + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + \". \") + \"Expected to find one of the known reducer keys instead: \" + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n    }\n}\nfunction assertReducerShape(reducers) {\n    Object.keys(reducers).forEach(function(key) {\n        var reducer = reducers[key];\n        var initialState = reducer(undefined, {\n            type: ActionTypes.INIT\n        });\n        if (typeof initialState === \"undefined\") {\n            throw new Error( false ? 0 : 'The slice reducer for key \"' + key + '\" returned undefined during initialization. ' + \"If the state passed to the reducer is undefined, you must \" + \"explicitly return the initial state. The initial state may \" + \"not be undefined. If you don't want to set a value for this reducer, \" + \"you can use null instead of undefined.\");\n        }\n        if (typeof reducer(undefined, {\n            type: ActionTypes.PROBE_UNKNOWN_ACTION()\n        }) === \"undefined\") {\n            throw new Error( false ? 0 : 'The slice reducer for key \"' + key + '\" returned undefined when probed with a random type. ' + (\"Don't try to handle '\" + ActionTypes.INIT + '\\' or other actions in \"redux/*\" ') + \"namespace. They are considered private. Instead, you must return the \" + \"current state for any unknown actions, unless it is undefined, \" + \"in which case you must return the initial state, regardless of the \" + \"action type. The initial state may not be undefined, but can be null.\");\n        }\n    });\n}\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */ function combineReducers(reducers) {\n    var reducerKeys = Object.keys(reducers);\n    var finalReducers = {};\n    for(var i = 0; i < reducerKeys.length; i++){\n        var key = reducerKeys[i];\n        if (true) {\n            if (typeof reducers[key] === \"undefined\") {\n                warning('No reducer provided for key \"' + key + '\"');\n            }\n        }\n        if (typeof reducers[key] === \"function\") {\n            finalReducers[key] = reducers[key];\n        }\n    }\n    var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same\n    // keys multiple times.\n    var unexpectedKeyCache;\n    if (true) {\n        unexpectedKeyCache = {};\n    }\n    var shapeAssertionError;\n    try {\n        assertReducerShape(finalReducers);\n    } catch (e) {\n        shapeAssertionError = e;\n    }\n    return function combination(state, action) {\n        if (state === void 0) {\n            state = {};\n        }\n        if (shapeAssertionError) {\n            throw shapeAssertionError;\n        }\n        if (true) {\n            var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n            if (warningMessage) {\n                warning(warningMessage);\n            }\n        }\n        var hasChanged = false;\n        var nextState = {};\n        for(var _i = 0; _i < finalReducerKeys.length; _i++){\n            var _key = finalReducerKeys[_i];\n            var reducer = finalReducers[_key];\n            var previousStateForKey = state[_key];\n            var nextStateForKey = reducer(previousStateForKey, action);\n            if (typeof nextStateForKey === \"undefined\") {\n                var actionType = action && action.type;\n                throw new Error( false ? 0 : \"When called with an action of type \" + (actionType ? '\"' + String(actionType) + '\"' : \"(unknown type)\") + ', the slice reducer for key \"' + _key + '\" returned undefined. ' + \"To ignore an action, you must explicitly return the previous state. \" + \"If you want this reducer to hold no value, you can return null instead of undefined.\");\n            }\n            nextState[_key] = nextStateForKey;\n            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n        }\n        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n        return hasChanged ? nextState : state;\n    };\n}\nfunction bindActionCreator(actionCreator, dispatch) {\n    return function() {\n        return dispatch(actionCreator.apply(this, arguments));\n    };\n}\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass an action creator as the first argument,\n * and get a dispatch wrapped function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */ function bindActionCreators(actionCreators, dispatch) {\n    if (typeof actionCreators === \"function\") {\n        return bindActionCreator(actionCreators, dispatch);\n    }\n    if (typeof actionCreators !== \"object\" || actionCreators === null) {\n        throw new Error( false ? 0 : \"bindActionCreators expected an object or a function, but instead received: '\" + kindOf(actionCreators) + \"'. \" + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n    }\n    var boundActionCreators = {};\n    for(var key in actionCreators){\n        var actionCreator = actionCreators[key];\n        if (typeof actionCreator === \"function\") {\n            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n        }\n    }\n    return boundActionCreators;\n}\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */ function compose() {\n    for(var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++){\n        funcs[_key] = arguments[_key];\n    }\n    if (funcs.length === 0) {\n        return function(arg) {\n            return arg;\n        };\n    }\n    if (funcs.length === 1) {\n        return funcs[0];\n    }\n    return funcs.reduce(function(a, b) {\n        return function() {\n            return a(b.apply(void 0, arguments));\n        };\n    });\n}\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */ function applyMiddleware() {\n    for(var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++){\n        middlewares[_key] = arguments[_key];\n    }\n    return function(createStore) {\n        return function() {\n            var store = createStore.apply(void 0, arguments);\n            var _dispatch = function dispatch() {\n                throw new Error( false ? 0 : \"Dispatching while constructing your middleware is not allowed. \" + \"Other middleware would not be applied to this dispatch.\");\n            };\n            var middlewareAPI = {\n                getState: store.getState,\n                dispatch: function dispatch() {\n                    return _dispatch.apply(void 0, arguments);\n                }\n            };\n            var chain = middlewares.map(function(middleware) {\n                return middleware(middlewareAPI);\n            });\n            _dispatch = compose.apply(void 0, chain)(store.dispatch);\n            return (0,_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__[\"default\"])((0,_babel_runtime_helpers_esm_objectSpread2__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, store), {}, {\n                dispatch: _dispatch\n            });\n        };\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9ub2RlX21vZHVsZXMvcmVkdXgvZXMvcmVkdXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBcUU7QUFFckU7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsdUJBQXVCQyxJQUFJO0lBQ2xDLE9BQU8sMkJBQTJCQSxPQUFPLDhDQUE4Q0EsT0FBTyw4QkFBOEI7QUFDOUg7QUFFQSxzREFBc0Q7QUFDdEQsSUFBSUMsZUFBZTtJQUNqQixPQUFPLE9BQU9DLFdBQVcsY0FBY0EsT0FBT0MsVUFBVSxJQUFJO0FBQzlEO0FBRUE7Ozs7O0NBS0MsR0FDRCxJQUFJQyxlQUFlLFNBQVNBO0lBQzFCLE9BQU9DLEtBQUtDLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHQyxLQUFLLENBQUMsSUFBSUMsSUFBSSxDQUFDO0FBQ2hFO0FBRUEsSUFBSUMsY0FBYztJQUNoQkMsTUFBTSxpQkFBaUJSO0lBQ3ZCUyxTQUFTLG9CQUFvQlQ7SUFDN0JVLHNCQUFzQixTQUFTQTtRQUM3QixPQUFPLGlDQUFpQ1Y7SUFDMUM7QUFDRjtBQUVBOzs7Q0FHQyxHQUNELFNBQVNXLGNBQWNDLEdBQUc7SUFDeEIsSUFBSSxPQUFPQSxRQUFRLFlBQVlBLFFBQVEsTUFBTSxPQUFPO0lBQ3BELElBQUlDLFFBQVFEO0lBRVosTUFBT0UsT0FBT0MsY0FBYyxDQUFDRixXQUFXLEtBQU07UUFDNUNBLFFBQVFDLE9BQU9DLGNBQWMsQ0FBQ0Y7SUFDaEM7SUFFQSxPQUFPQyxPQUFPQyxjQUFjLENBQUNILFNBQVNDO0FBQ3hDO0FBRUEsd0ZBQXdGO0FBQ3hGLFNBQVNHLFdBQVdDLEdBQUc7SUFDckIsSUFBSUEsUUFBUSxLQUFLLEdBQUcsT0FBTztJQUMzQixJQUFJQSxRQUFRLE1BQU0sT0FBTztJQUN6QixJQUFJQyxPQUFPLE9BQU9EO0lBRWxCLE9BQVFDO1FBQ04sS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FB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QVM5RDtnQkFDdkIsTUFBTSxJQUFJaEMsTUFBTVMsTUFBcUMsR0FBRzVDLENBQTBCLEdBQUcsb0VBQW9FO1lBQzNKO1lBRUEsSUFBSWtJLGdCQUFnQjtnQkFDbEJ4RSxVQUFVc0UsTUFBTXRFLFFBQVE7Z0JBQ3hCUyxVQUFVLFNBQVNBO29CQUNqQixPQUFPOEQsVUFBVWQsS0FBSyxDQUFDLEtBQUssR0FBR2pFO2dCQUNqQztZQUNGO1lBQ0EsSUFBSWlGLFFBQVFKLFlBQVlLLEdBQUcsQ0FBQyxTQUFVQyxVQUFVO2dCQUM5QyxPQUFPQSxXQUFXSDtZQUNwQjtZQUNBRCxZQUFZVixRQUFRSixLQUFLLENBQUMsS0FBSyxHQUFHZ0IsT0FBT0gsTUFBTTdELFFBQVE7WUFDdkQsT0FBT3BFLG9GQUFhQSxDQUFDQSxvRkFBYUEsQ0FBQyxDQUFDLEdBQUdpSSxRQUFRLENBQUMsR0FBRztnQkFDakQ3RCxVQUFVOEQ7WUFDWjtRQUNGO0lBQ0Y7QUFDRjtBQUVvSiIsInNvdXJjZXMiOlsid2VicGFjazovL2thZ2Uuc3RvcmUvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9ub2RlX21vZHVsZXMvcmVkdXgvZXMvcmVkdXguanM/MmUwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX29iamVjdFNwcmVhZCBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWQyJztcblxuLyoqXG4gKiBBZGFwdGVkIGZyb20gUmVhY3Q6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21hc3Rlci9wYWNrYWdlcy9zaGFyZWQvZm9ybWF0UHJvZEVycm9yTWVzc2FnZS5qc1xuICpcbiAqIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIHRocm93IGVycm9yIGNhbGxzLiBUaGVzZSBtZXNzYWdlcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggZXJyb3IgY29kZXNcbiAqIGR1cmluZyBidWlsZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZSkge1xuICByZXR1cm4gXCJNaW5pZmllZCBSZWR1eCBlcnJvciAjXCIgKyBjb2RlICsgXCI7IHZpc2l0IGh0dHBzOi8vcmVkdXguanMub3JnL0Vycm9ycz9jb2RlPVwiICsgY29kZSArIFwiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIFwiICsgJ3VzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMuICc7XG59XG5cbi8vIElubGluZWQgdmVyc2lvbiBvZiB0aGUgYHN5bWJvbC1vYnNlcnZhYmxlYCBwb2x5ZmlsbFxudmFyICQkb2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5vYnNlcnZhYmxlIHx8ICdAQG9ic2VydmFibGUnO1xufSkoKTtcblxuLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cbnZhciByYW5kb21TdHJpbmcgPSBmdW5jdGlvbiByYW5kb21TdHJpbmcoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoJycpLmpvaW4oJy4nKTtcbn07XG5cbnZhciBBY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogXCJAQHJlZHV4L0lOSVRcIiArIHJhbmRvbVN0cmluZygpLFxuICBSRVBMQUNFOiBcIkBAcmVkdXgvUkVQTEFDRVwiICsgcmFuZG9tU3RyaW5nKCksXG4gIFBST0JFX1VOS05PV05fQUNUSU9OOiBmdW5jdGlvbiBQUk9CRV9VTktOT1dOX0FDVElPTigpIHtcbiAgICByZXR1cm4gXCJAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OXCIgKyByYW5kb21TdHJpbmcoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBhcmd1bWVudCBhcHBlYXJzIHRvIGJlIGEgcGxhaW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIHZhciBwcm90byA9IG9iajtcblxuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gcHJvdG87XG59XG5cbi8vIElubGluZWQgLyBzaG9ydGVuZWQgdmVyc2lvbiBvZiBga2luZE9mYCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2tpbmQtb2ZcbmZ1bmN0aW9uIG1pbmlLaW5kT2YodmFsKSB7XG4gIGlmICh2YWwgPT09IHZvaWQgMCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAge1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHJldHVybiAnYXJyYXknO1xuICBpZiAoaXNEYXRlKHZhbCkpIHJldHVybiAnZGF0ZSc7XG4gIGlmIChpc0Vycm9yKHZhbCkpIHJldHVybiAnZXJyb3InO1xuICB2YXIgY29uc3RydWN0b3JOYW1lID0gY3Rvck5hbWUodmFsKTtcblxuICBzd2l0Y2ggKGNvbnN0cnVjdG9yTmFtZSkge1xuICAgIGNhc2UgJ1N5bWJvbCc6XG4gICAgY2FzZSAnUHJvbWlzZSc6XG4gICAgY2FzZSAnV2Vha01hcCc6XG4gICAgY2FzZSAnV2Vha1NldCc6XG4gICAgY2FzZSAnTWFwJzpcbiAgICBjYXNlICdTZXQnOlxuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZTtcbiAgfSAvLyBvdGhlclxuXG5cbiAgcmV0dXJuIHR5cGUuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzL2csICcnKTtcbn1cblxuZnVuY3Rpb24gY3Rvck5hbWUodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nID8gdmFsLmNvbnN0cnVjdG9yLm5hbWUgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yKHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIHZhbC5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiB2YWwuY29uc3RydWN0b3IgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5zdGFja1RyYWNlTGltaXQgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHR5cGVvZiB2YWwudG9EYXRlU3RyaW5nID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWwuZ2V0RGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsLnNldERhdGUgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGtpbmRPZih2YWwpIHtcbiAgdmFyIHR5cGVPZlZhbCA9IHR5cGVvZiB2YWw7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0eXBlT2ZWYWwgPSBtaW5pS2luZE9mKHZhbCk7XG4gIH1cblxuICByZXR1cm4gdHlwZU9mVmFsO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogKipXZSByZWNvbW1lbmQgdXNpbmcgdGhlIGBjb25maWd1cmVTdG9yZWAgbWV0aG9kXG4gKiBvZiB0aGUgYEByZWR1eGpzL3Rvb2xraXRgIHBhY2thZ2UqKiwgd2hpY2ggcmVwbGFjZXMgYGNyZWF0ZVN0b3JlYC5cbiAqXG4gKiBSZWR1eCBUb29sa2l0IGlzIG91ciByZWNvbW1lbmRlZCBhcHByb2FjaCBmb3Igd3JpdGluZyBSZWR1eCBsb2dpYyB0b2RheSxcbiAqIGluY2x1ZGluZyBzdG9yZSBzZXR1cCwgcmVkdWNlcnMsIGRhdGEgZmV0Y2hpbmcsIGFuZCBtb3JlLlxuICpcbiAqICoqRm9yIG1vcmUgZGV0YWlscywgcGxlYXNlIHJlYWQgdGhpcyBSZWR1eCBkb2NzIHBhZ2U6KipcbiAqICoqaHR0cHM6Ly9yZWR1eC5qcy5vcmcvaW50cm9kdWN0aW9uL3doeS1ydGstaXMtcmVkdXgtdG9kYXkqKlxuICpcbiAqIGBjb25maWd1cmVTdG9yZWAgZnJvbSBSZWR1eCBUb29sa2l0IGlzIGFuIGltcHJvdmVkIHZlcnNpb24gb2YgYGNyZWF0ZVN0b3JlYCB0aGF0XG4gKiBzaW1wbGlmaWVzIHNldHVwIGFuZCBoZWxwcyBhdm9pZCBjb21tb24gYnVncy5cbiAqXG4gKiBZb3Ugc2hvdWxkIG5vdCBiZSB1c2luZyB0aGUgYHJlZHV4YCBjb3JlIHBhY2thZ2UgYnkgaXRzZWxmIHRvZGF5LCBleGNlcHQgZm9yIGxlYXJuaW5nIHB1cnBvc2VzLlxuICogVGhlIGBjcmVhdGVTdG9yZWAgbWV0aG9kIGZyb20gdGhlIGNvcmUgYHJlZHV4YCBwYWNrYWdlIHdpbGwgbm90IGJlIHJlbW92ZWQsIGJ1dCB3ZSBlbmNvdXJhZ2VcbiAqIGFsbCB1c2VycyB0byBtaWdyYXRlIHRvIHVzaW5nIFJlZHV4IFRvb2xraXQgZm9yIGFsbCBSZWR1eCBjb2RlLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIHVzZSBgY3JlYXRlU3RvcmVgIHdpdGhvdXQgdGhpcyB2aXN1YWwgZGVwcmVjYXRpb24gd2FybmluZywgdXNlXG4gKiB0aGUgYGxlZ2FjeV9jcmVhdGVTdG9yZWAgaW1wb3J0IGluc3RlYWQ6XG4gKlxuICogYGltcG9ydCB7IGxlZ2FjeV9jcmVhdGVTdG9yZSBhcyBjcmVhdGVTdG9yZX0gZnJvbSAncmVkdXgnYFxuICpcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbmhhbmNlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMCkgOiAnSXQgbG9va3MgbGlrZSB5b3UgYXJlIHBhc3Npbmcgc2V2ZXJhbCBzdG9yZSBlbmhhbmNlcnMgdG8gJyArICdjcmVhdGVTdG9yZSgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIEluc3RlYWQsIGNvbXBvc2UgdGhlbSAnICsgJ3RvZ2V0aGVyIHRvIGEgc2luZ2xlIGZ1bmN0aW9uLiBTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wYXJ0LTQtc3RvcmUjY3JlYXRpbmctYS1zdG9yZS13aXRoLWVuaGFuY2VycyBmb3IgYW4gZXhhbXBsZS4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuaGFuY2VyID0gcHJlbG9hZGVkU3RhdGU7XG4gICAgcHJlbG9hZGVkU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEpIDogXCJFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICdcIiArIGtpbmRPZihlbmhhbmNlcikgKyBcIidcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyKSA6IFwiRXhwZWN0ZWQgdGhlIHJvb3QgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJ1wiICsga2luZE9mKHJlZHVjZXIpICsgXCInXCIpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IHByZWxvYWRlZFN0YXRlO1xuICB2YXIgY3VycmVudExpc3RlbmVycyA9IFtdO1xuICB2YXIgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIHZhciBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gIC8qKlxuICAgKiBUaGlzIG1ha2VzIGEgc2hhbGxvdyBjb3B5IG9mIGN1cnJlbnRMaXN0ZW5lcnMgc28gd2UgY2FuIHVzZVxuICAgKiBuZXh0TGlzdGVuZXJzIGFzIGEgdGVtcG9yYXJ5IGxpc3Qgd2hpbGUgZGlzcGF0Y2hpbmcuXG4gICAqXG4gICAqIFRoaXMgcHJldmVudHMgYW55IGJ1Z3MgYXJvdW5kIGNvbnN1bWVycyBjYWxsaW5nXG4gICAqIHN1YnNjcmliZS91bnN1YnNjcmliZSBpbiB0aGUgbWlkZGxlIG9mIGEgZGlzcGF0Y2guXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgc3RhdGUgdHJlZSBtYW5hZ2VkIGJ5IHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzKSA6ICdZb3UgbWF5IG5vdCBjYWxsIHN0b3JlLmdldFN0YXRlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ1RoZSByZWR1Y2VyIGhhcyBhbHJlYWR5IHJlY2VpdmVkIHRoZSBzdGF0ZSBhcyBhbiBhcmd1bWVudC4gJyArICdQYXNzIGl0IGRvd24gZnJvbSB0aGUgdG9wIHJlZHVjZXIgaW5zdGVhZCBvZiByZWFkaW5nIGl0IGZyb20gdGhlIHN0b3JlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQpIDogXCJFeHBlY3RlZCB0aGUgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICdcIiArIGtpbmRPZihsaXN0ZW5lcikgKyBcIidcIik7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDUpIDogJ1lvdSBtYXkgbm90IGNhbGwgc3RvcmUuc3Vic2NyaWJlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ0lmIHlvdSB3b3VsZCBsaWtlIHRvIGJlIG5vdGlmaWVkIGFmdGVyIHRoZSBzdG9yZSBoYXMgYmVlbiB1cGRhdGVkLCBzdWJzY3JpYmUgZnJvbSBhICcgKyAnY29tcG9uZW50IGFuZCBpbnZva2Ugc3RvcmUuZ2V0U3RhdGUoKSBpbiB0aGUgY2FsbGJhY2sgdG8gYWNjZXNzIHRoZSBsYXRlc3Qgc3RhdGUuICcgKyAnU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICBuZXh0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNikgOiAnWW91IG1heSBub3QgdW5zdWJzY3JpYmUgZnJvbSBhIHN0b3JlIGxpc3RlbmVyIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gJyArICdTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgdmFyIGluZGV4ID0gbmV4dExpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIGN1cnJlbnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gYWN0aW9uLiBJdCBpcyB0aGUgb25seSB3YXkgdG8gdHJpZ2dlciBhIHN0YXRlIGNoYW5nZS5cbiAgICpcbiAgICogVGhlIGByZWR1Y2VyYCBmdW5jdGlvbiwgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JlLCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBnaXZlbiBgYWN0aW9uYC4gSXRzIHJldHVybiB2YWx1ZSB3aWxsXG4gICAqIGJlIGNvbnNpZGVyZWQgdGhlICoqbmV4dCoqIHN0YXRlIG9mIHRoZSB0cmVlLCBhbmQgdGhlIGNoYW5nZSBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSBub3RpZmllZC5cbiAgICpcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBwbGFpbiBvYmplY3QgYWN0aW9ucy4gSWYgeW91IHdhbnQgdG9cbiAgICogZGlzcGF0Y2ggYSBQcm9taXNlLCBhbiBPYnNlcnZhYmxlLCBhIHRodW5rLCBvciBzb21ldGhpbmcgZWxzZSwgeW91IG5lZWQgdG9cbiAgICogd3JhcCB5b3VyIHN0b3JlIGNyZWF0aW5nIGZ1bmN0aW9uIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbWlkZGxld2FyZS4gRm9yXG4gICAqIGV4YW1wbGUsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGByZWR1eC10aHVua2AgcGFja2FnZS4gRXZlbiB0aGVcbiAgICogbWlkZGxld2FyZSB3aWxsIGV2ZW50dWFsbHkgZGlzcGF0Y2ggcGxhaW4gb2JqZWN0IGFjdGlvbnMgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gQSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIOKAnHdoYXQgY2hhbmdlZOKAnS4gSXQgaXNcbiAgICogYSBnb29kIGlkZWEgdG8ga2VlcCBhY3Rpb25zIHNlcmlhbGl6YWJsZSBzbyB5b3UgY2FuIHJlY29yZCBhbmQgcmVwbGF5IHVzZXJcbiAgICogc2Vzc2lvbnMsIG9yIHVzZSB0aGUgdGltZSB0cmF2ZWxsaW5nIGByZWR1eC1kZXZ0b29sc2AuIEFuIGFjdGlvbiBtdXN0IGhhdmVcbiAgICogYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggbWF5IG5vdCBiZSBgdW5kZWZpbmVkYC4gSXQgaXMgYSBnb29kIGlkZWEgdG8gdXNlXG4gICAqIHN0cmluZyBjb25zdGFudHMgZm9yIGFjdGlvbiB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gRm9yIGNvbnZlbmllbmNlLCB0aGUgc2FtZSBhY3Rpb24gb2JqZWN0IHlvdSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQsIGlmIHlvdSB1c2UgYSBjdXN0b20gbWlkZGxld2FyZSwgaXQgbWF5IHdyYXAgYGRpc3BhdGNoKClgIHRvXG4gICAqIHJldHVybiBzb21ldGhpbmcgZWxzZSAoZm9yIGV4YW1wbGUsIGEgUHJvbWlzZSB5b3UgY2FuIGF3YWl0KS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNykgOiBcIkFjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiBJbnN0ZWFkLCB0aGUgYWN0dWFsIHR5cGUgd2FzOiAnXCIgKyBraW5kT2YoYWN0aW9uKSArIFwiJy4gWW91IG1heSBuZWVkIHRvIGFkZCBtaWRkbGV3YXJlIHRvIHlvdXIgc3RvcmUgc2V0dXAgdG8gaGFuZGxlIGRpc3BhdGNoaW5nIG90aGVyIHZhbHVlcywgc3VjaCBhcyAncmVkdXgtdGh1bmsnIHRvIGhhbmRsZSBkaXNwYXRjaGluZyBmdW5jdGlvbnMuIFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNC1zdG9yZSNtaWRkbGV3YXJlIGFuZCBodHRwczovL3JlZHV4LmpzLm9yZy90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3BhcnQtNi1hc3luYy1sb2dpYyN1c2luZy10aGUtcmVkdXgtdGh1bmstbWlkZGxld2FyZSBmb3IgZXhhbXBsZXMuXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6ICdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGFuIGFjdGlvbiB0eXBlIHN0cmluZyBjb25zdGFudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoOSkgOiAnUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG5cblxuICBmdW5jdGlvbiByZXBsYWNlUmVkdWNlcihuZXh0UmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEwKSA6IFwiRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQsIHJlY2VpdmVkOiAnXCIgKyBraW5kT2YobmV4dFJlZHVjZXIpKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyOyAvLyBUaGlzIGFjdGlvbiBoYXMgYSBzaW1pbGlhciBlZmZlY3QgdG8gQWN0aW9uVHlwZXMuSU5JVC5cbiAgICAvLyBBbnkgcmVkdWNlcnMgdGhhdCBleGlzdGVkIGluIGJvdGggdGhlIG5ldyBhbmQgb2xkIHJvb3RSZWR1Y2VyXG4gICAgLy8gd2lsbCByZWNlaXZlIHRoZSBwcmV2aW91cyBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgICAvLyB0aGUgbmV3IHN0YXRlIHRyZWUgd2l0aCBhbnkgcmVsZXZhbnQgZGF0YSBmcm9tIHRoZSBvbGQgb25lLlxuXG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogQWN0aW9uVHlwZXMuUkVQTEFDRVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbiAgICovXG5cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTEpIDogXCJFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LiBJbnN0ZWFkLCByZWNlaXZlZDogJ1wiICsga2luZE9mKG9ic2VydmVyKSArIFwiJ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmWyQkb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9IC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuXG5cbiAgZGlzcGF0Y2goe1xuICAgIHR5cGU6IEFjdGlvblR5cGVzLklOSVRcbiAgfSk7XG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMlskJG9ic2VydmFibGVdID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBSZWR1eCBzdG9yZSB0aGF0IGhvbGRzIHRoZSBzdGF0ZSB0cmVlLlxuICpcbiAqICoqV2UgcmVjb21tZW5kIHVzaW5nIGBjb25maWd1cmVTdG9yZWAgZnJvbSB0aGVcbiAqIGBAcmVkdXhqcy90b29sa2l0YCBwYWNrYWdlKiosIHdoaWNoIHJlcGxhY2VzIGBjcmVhdGVTdG9yZWA6XG4gKiAqKmh0dHBzOi8vcmVkdXguanMub3JnL2ludHJvZHVjdGlvbi93aHktcnRrLWlzLXJlZHV4LXRvZGF5KipcbiAqXG4gKiBUaGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZSBkYXRhIGluIHRoZSBzdG9yZSBpcyB0byBjYWxsIGBkaXNwYXRjaCgpYCBvbiBpdC5cbiAqXG4gKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gKiBwYXJ0cyBvZiB0aGUgc3RhdGUgdHJlZSByZXNwb25kIHRvIGFjdGlvbnMsIHlvdSBtYXkgY29tYmluZSBzZXZlcmFsIHJlZHVjZXJzXG4gKiBpbnRvIGEgc2luZ2xlIHJlZHVjZXIgZnVuY3Rpb24gYnkgdXNpbmcgYGNvbWJpbmVSZWR1Y2Vyc2AuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVkdWNlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlblxuICogdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGFjdGlvbiB0byBoYW5kbGUuXG4gKlxuICogQHBhcmFtIHthbnl9IFtwcmVsb2FkZWRTdGF0ZV0gVGhlIGluaXRpYWwgc3RhdGUuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBoeWRyYXRlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYVxuICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAqIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2Vyc2AgdG8gcHJvZHVjZSB0aGUgcm9vdCByZWR1Y2VyIGZ1bmN0aW9uLCB0aGlzIG11c3QgYmVcbiAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGBjb21iaW5lUmVkdWNlcnNgIGtleXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2VuaGFuY2VyXSBUaGUgc3RvcmUgZW5oYW5jZXIuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gKiBpcyBgYXBwbHlNaWRkbGV3YXJlKClgLlxuICpcbiAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gKiBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZXMuXG4gKi9cblxudmFyIGxlZ2FjeV9jcmVhdGVTdG9yZSA9IGNyZWF0ZVN0b3JlO1xuXG4vKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cblxuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG5cbn1cblxuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBBY3Rpb25UeXBlcy5JTklUID8gJ3ByZWxvYWRlZFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuIFwiVGhlIFwiICsgYXJndW1lbnROYW1lICsgXCIgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcXFwiXCIgKyBraW5kT2YoaW5wdXRTdGF0ZSkgKyBcIlxcXCIuIEV4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgXCIgKyAoXCJrZXlzOiBcXFwiXCIgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArIFwiXFxcIlwiKTtcbiAgfVxuXG4gIHZhciB1bmV4cGVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGlucHV0U3RhdGUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICFyZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XTtcbiAgfSk7XG4gIHVuZXhwZWN0ZWRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldID0gdHJ1ZTtcbiAgfSk7XG4gIGlmIChhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IEFjdGlvblR5cGVzLlJFUExBQ0UpIHJldHVybjtcblxuICBpZiAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBcIlVuZXhwZWN0ZWQgXCIgKyAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/ICdrZXlzJyA6ICdrZXknKSArIFwiIFwiICsgKFwiXFxcIlwiICsgdW5leHBlY3RlZEtleXMuam9pbignXCIsIFwiJykgKyBcIlxcXCIgZm91bmQgaW4gXCIgKyBhcmd1bWVudE5hbWUgKyBcIi4gXCIpICsgXCJFeHBlY3RlZCB0byBmaW5kIG9uZSBvZiB0aGUga25vd24gcmVkdWNlciBrZXlzIGluc3RlYWQ6IFwiICsgKFwiXFxcIlwiICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyBcIlxcXCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlZHVjZXJTaGFwZShyZWR1Y2Vycykge1xuICBPYmplY3Qua2V5cyhyZWR1Y2VycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHJlZHVjZXIgPSByZWR1Y2Vyc1trZXldO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHVuZGVmaW5lZCwge1xuICAgICAgdHlwZTogQWN0aW9uVHlwZXMuSU5JVFxuICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMikgOiBcIlRoZSBzbGljZSByZWR1Y2VyIGZvciBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uIFwiICsgXCJJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgXCIgKyBcImV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgXCIgKyBcIm5vdCBiZSB1bmRlZmluZWQuIElmIHlvdSBkb24ndCB3YW50IHRvIHNldCBhIHZhbHVlIGZvciB0aGlzIHJlZHVjZXIsIFwiICsgXCJ5b3UgY2FuIHVzZSBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLlwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlZHVjZXIodW5kZWZpbmVkLCB7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5QUk9CRV9VTktOT1dOX0FDVElPTigpXG4gICAgfSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMykgOiBcIlRoZSBzbGljZSByZWR1Y2VyIGZvciBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIHByb2JlZCB3aXRoIGEgcmFuZG9tIHR5cGUuIFwiICsgKFwiRG9uJ3QgdHJ5IHRvIGhhbmRsZSAnXCIgKyBBY3Rpb25UeXBlcy5JTklUICsgXCInIG9yIG90aGVyIGFjdGlvbnMgaW4gXFxcInJlZHV4LypcXFwiIFwiKSArIFwibmFtZXNwYWNlLiBUaGV5IGFyZSBjb25zaWRlcmVkIHByaXZhdGUuIEluc3RlYWQsIHlvdSBtdXN0IHJldHVybiB0aGUgXCIgKyBcImN1cnJlbnQgc3RhdGUgZm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsIFwiICsgXCJpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgXCIgKyBcImFjdGlvbiB0eXBlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZCwgYnV0IGNhbiBiZSBudWxsLlwiKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgcmVkdWNlciBmdW5jdGlvbnMsIGludG8gYSBzaW5nbGVcbiAqIHJlZHVjZXIgZnVuY3Rpb24uIEl0IHdpbGwgY2FsbCBldmVyeSBjaGlsZCByZWR1Y2VyLCBhbmQgZ2F0aGVyIHRoZWlyIHJlc3VsdHNcbiAqIGludG8gYSBzaW5nbGUgc3RhdGUgb2JqZWN0LCB3aG9zZSBrZXlzIGNvcnJlc3BvbmQgdG8gdGhlIGtleXMgb2YgdGhlIHBhc3NlZFxuICogcmVkdWNlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZHVjZXJzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBkaWZmZXJlbnRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW5cbiAqIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzIHJlZHVjZXJzYCBzeW50YXguIFRoZSByZWR1Y2VycyBtYXkgbmV2ZXIgcmV0dXJuXG4gKiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpciBpbml0aWFsIHN0YXRlXG4gKiBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnlcbiAqIHVucmVjb2duaXplZCBhY3Rpb24uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZVxuICogcGFzc2VkIG9iamVjdCwgYW5kIGJ1aWxkcyBhIHN0YXRlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICovXG5cblxuZnVuY3Rpb24gY29tYmluZVJlZHVjZXJzKHJlZHVjZXJzKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGZpbmFsUmVkdWNlcnMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2FybmluZyhcIk5vIHJlZHVjZXIgcHJvdmlkZWQgZm9yIGtleSBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmaW5hbFJlZHVjZXJzW2tleV0gPSByZWR1Y2Vyc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaW5hbFJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMoZmluYWxSZWR1Y2Vycyk7IC8vIFRoaXMgaXMgdXNlZCB0byBtYWtlIHN1cmUgd2UgZG9uJ3Qgd2FybiBhYm91dCB0aGUgc2FtZVxuICAvLyBrZXlzIG11bHRpcGxlIHRpbWVzLlxuXG4gIHZhciB1bmV4cGVjdGVkS2V5Q2FjaGU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGUgPSB7fTtcbiAgfVxuXG4gIHZhciBzaGFwZUFzc2VydGlvbkVycm9yO1xuXG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNoYXBlKGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2hhcGVBc3NlcnRpb25FcnJvciA9IGU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gY29tYmluYXRpb24oc3RhdGUsIGFjdGlvbikge1xuICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGF0ZSA9IHt9O1xuICAgIH1cblxuICAgIGlmIChzaGFwZUFzc2VydGlvbkVycm9yKSB7XG4gICAgICB0aHJvdyBzaGFwZUFzc2VydGlvbkVycm9yO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgd2FybmluZ01lc3NhZ2UgPSBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKHN0YXRlLCBmaW5hbFJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSk7XG5cbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICB3YXJuaW5nKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0U3RhdGUgPSB7fTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9rZXkgPSBmaW5hbFJlZHVjZXJLZXlzW19pXTtcbiAgICAgIHZhciByZWR1Y2VyID0gZmluYWxSZWR1Y2Vyc1tfa2V5XTtcbiAgICAgIHZhciBwcmV2aW91c1N0YXRlRm9yS2V5ID0gc3RhdGVbX2tleV07XG4gICAgICB2YXIgbmV4dFN0YXRlRm9yS2V5ID0gcmVkdWNlcihwcmV2aW91c1N0YXRlRm9yS2V5LCBhY3Rpb24pO1xuXG4gICAgICBpZiAodHlwZW9mIG5leHRTdGF0ZUZvcktleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGFjdGlvblR5cGUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE0KSA6IFwiV2hlbiBjYWxsZWQgd2l0aCBhbiBhY3Rpb24gb2YgdHlwZSBcIiArIChhY3Rpb25UeXBlID8gXCJcXFwiXCIgKyBTdHJpbmcoYWN0aW9uVHlwZSkgKyBcIlxcXCJcIiA6ICcodW5rbm93biB0eXBlKScpICsgXCIsIHRoZSBzbGljZSByZWR1Y2VyIGZvciBrZXkgXFxcIlwiICsgX2tleSArIFwiXFxcIiByZXR1cm5lZCB1bmRlZmluZWQuIFwiICsgXCJUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuIFwiICsgXCJJZiB5b3Ugd2FudCB0aGlzIHJlZHVjZXIgdG8gaG9sZCBubyB2YWx1ZSwgeW91IGNhbiByZXR1cm4gbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5cIik7XG4gICAgICB9XG5cbiAgICAgIG5leHRTdGF0ZVtfa2V5XSA9IG5leHRTdGF0ZUZvcktleTtcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcbiAgICB9XG5cbiAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoc3RhdGUpLmxlbmd0aDtcbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhbiBhY3Rpb24gY3JlYXRvciBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZGlzcGF0Y2ggd3JhcHBlZCBmdW5jdGlvbiBpbiByZXR1cm4uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IGFjdGlvbkNyZWF0b3JzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvblxuICogY3JlYXRvciBmdW5jdGlvbnMuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzYFxuICogc3ludGF4LiBZb3UgbWF5IGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNwYXRjaCBUaGUgYGRpc3BhdGNoYCBmdW5jdGlvbiBhdmFpbGFibGUgb24geW91ciBSZWR1eFxuICogc3RvcmUuXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gVGhlIG9iamVjdCBtaW1pY2tpbmcgdGhlIG9yaWdpbmFsIG9iamVjdCwgYnV0IHdpdGhcbiAqIGV2ZXJ5IGFjdGlvbiBjcmVhdG9yIHdyYXBwZWQgaW50byB0aGUgYGRpc3BhdGNoYCBjYWxsLiBJZiB5b3UgcGFzc2VkIGFcbiAqIGZ1bmN0aW9uIGFzIGBhY3Rpb25DcmVhdG9yc2AsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBhbHNvIGJlIGEgc2luZ2xlXG4gKiBmdW5jdGlvbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNikgOiBcImJpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgYnV0IGluc3RlYWQgcmVjZWl2ZWQ6ICdcIiArIGtpbmRPZihhY3Rpb25DcmVhdG9ycykgKyBcIicuIFwiICsgXCJEaWQgeW91IHdyaXRlIFxcXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVxcXCIgaW5zdGVhZCBvZiBcXFwiaW1wb3J0ICogYXMgQWN0aW9uQ3JlYXRvcnMgZnJvbVxcXCI/XCIpO1xuICB9XG5cbiAgdmFyIGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gYWN0aW9uQ3JlYXRvcnMpIHtcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9IGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuLyoqXG4gKiBDb21wb3NlcyBzaW5nbGUtYXJndW1lbnQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC4gVGhlIHJpZ2h0bW9zdFxuICogZnVuY3Rpb24gY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzIGFzIGl0IHByb3ZpZGVzIHRoZSBzaWduYXR1cmUgZm9yXG4gKiB0aGUgcmVzdWx0aW5nIGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jcyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gb2J0YWluZWQgYnkgY29tcG9zaW5nIHRoZSBhcmd1bWVudCBmdW5jdGlvbnNcbiAqIGZyb20gcmlnaHQgdG8gbGVmdC4gRm9yIGV4YW1wbGUsIGNvbXBvc2UoZiwgZywgaCkgaXMgaWRlbnRpY2FsIHRvIGRvaW5nXG4gKiAoLi4uYXJncykgPT4gZihnKGgoLi4uYXJncykpKS5cbiAqL1xuZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmNzWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmNzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYShiLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0b3JlIGVuaGFuY2VyIHRoYXQgYXBwbGllcyBtaWRkbGV3YXJlIHRvIHRoZSBkaXNwYXRjaCBtZXRob2RcbiAqIG9mIHRoZSBSZWR1eCBzdG9yZS4gVGhpcyBpcyBoYW5keSBmb3IgYSB2YXJpZXR5IG9mIHRhc2tzLCBzdWNoIGFzIGV4cHJlc3NpbmdcbiAqIGFzeW5jaHJvbm91cyBhY3Rpb25zIGluIGEgY29uY2lzZSBtYW5uZXIsIG9yIGxvZ2dpbmcgZXZlcnkgYWN0aW9uIHBheWxvYWQuXG4gKlxuICogU2VlIGByZWR1eC10aHVua2AgcGFja2FnZSBhcyBhbiBleGFtcGxlIG9mIHRoZSBSZWR1eCBtaWRkbGV3YXJlLlxuICpcbiAqIEJlY2F1c2UgbWlkZGxld2FyZSBpcyBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMsIHRoaXMgc2hvdWxkIGJlIHRoZSBmaXJzdFxuICogc3RvcmUgZW5oYW5jZXIgaW4gdGhlIGNvbXBvc2l0aW9uIGNoYWluLlxuICpcbiAqIE5vdGUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBiZSBnaXZlbiB0aGUgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBmdW5jdGlvbnNcbiAqIGFzIG5hbWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBtaWRkbGV3YXJlcyBUaGUgbWlkZGxld2FyZSBjaGFpbiB0byBiZSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHN0b3JlIGVuaGFuY2VyIGFwcGx5aW5nIHRoZSBtaWRkbGV3YXJlLlxuICovXG5cbmZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1pZGRsZXdhcmVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjcmVhdGVTdG9yZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZS5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG5cbiAgICAgIHZhciBfZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTUpIDogJ0Rpc3BhdGNoaW5nIHdoaWxlIGNvbnN0cnVjdGluZyB5b3VyIG1pZGRsZXdhcmUgaXMgbm90IGFsbG93ZWQuICcgKyAnT3RoZXIgbWlkZGxld2FyZSB3b3VsZCBub3QgYmUgYXBwbGllZCB0byB0aGlzIGRpc3BhdGNoLicpO1xuICAgICAgfTtcblxuICAgICAgdmFyIG1pZGRsZXdhcmVBUEkgPSB7XG4gICAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICAgICAgICAgIHJldHVybiBfZGlzcGF0Y2guYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGNoYWluID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgICAgIHJldHVybiBtaWRkbGV3YXJlKG1pZGRsZXdhcmVBUEkpO1xuICAgICAgfSk7XG4gICAgICBfZGlzcGF0Y2ggPSBjb21wb3NlLmFwcGx5KHZvaWQgMCwgY2hhaW4pKHN0b3JlLmRpc3BhdGNoKTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0b3JlKSwge30sIHtcbiAgICAgICAgZGlzcGF0Y2g6IF9kaXNwYXRjaFxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IHsgQWN0aW9uVHlwZXMgYXMgX19ET19OT1RfVVNFX19BY3Rpb25UeXBlcywgYXBwbHlNaWRkbGV3YXJlLCBiaW5kQWN0aW9uQ3JlYXRvcnMsIGNvbWJpbmVSZWR1Y2VycywgY29tcG9zZSwgY3JlYXRlU3RvcmUsIGxlZ2FjeV9jcmVhdGVTdG9yZSB9O1xuIl0sIm5hbWVzIjpbIl9vYmplY3RTcHJlYWQiLCJmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIiwiY29kZSIsIiQkb2JzZXJ2YWJsZSIsIlN5bWJvbCIsIm9ic2VydmFibGUiLCJyYW5kb21TdHJpbmciLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJzcGxpdCIsImpvaW4iLCJBY3Rpb25UeXBlcyIsIklOSVQiLCJSRVBMQUNFIiwiUFJPQkVfVU5LTk9XTl9BQ1RJT04iLCJpc1BsYWluT2JqZWN0Iiwib2JqIiwicHJvdG8iLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsIm1pbmlLaW5kT2YiLCJ2YWwiLCJ0eXBlIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNEYXRlIiwiaXNFcnJvciIsImNvbnN0cnVjdG9yTmFtZSIsImN0b3JOYW1lIiwic2xpY2UiLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJFcnJvciIsIm1lc3NhZ2UiLCJzdGFja1RyYWNlTGltaXQiLCJEYXRlIiwidG9EYXRlU3RyaW5nIiwiZ2V0RGF0ZSIsInNldERhdGUiLCJraW5kT2YiLCJ0eXBlT2ZWYWwiLCJwcm9jZXNzIiwiY3JlYXRlU3RvcmUiLCJyZWR1Y2VyIiwicHJlbG9hZGVkU3RhdGUiLCJlbmhhbmNlciIsIl9yZWYyIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwiY3VycmVudFJlZHVjZXIiLCJjdXJyZW50U3RhdGUiLCJjdXJyZW50TGlzdGVuZXJzIiwibmV4dExpc3RlbmVycyIsImlzRGlzcGF0Y2hpbmciLCJlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzIiwiZ2V0U3RhdGUiLCJzdWJzY3JpYmUiLCJsaXN0ZW5lciIsImlzU3Vic2NyaWJlZCIsInB1c2giLCJ1bnN1YnNjcmliZSIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsImRpc3BhdGNoIiwiYWN0aW9uIiwibGlzdGVuZXJzIiwiaSIsImxlbmd0aCIsInJlcGxhY2VSZWR1Y2VyIiwibmV4dFJlZHVjZXIiLCJfcmVmIiwib3V0ZXJTdWJzY3JpYmUiLCJvYnNlcnZlciIsIm9ic2VydmVTdGF0ZSIsIm5leHQiLCJsZWdhY3lfY3JlYXRlU3RvcmUiLCJ3YXJuaW5nIiwiY29uc29sZSIsImVycm9yIiwiZSIsImdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2UiLCJpbnB1dFN0YXRlIiwicmVkdWNlcnMiLCJ1bmV4cGVjdGVkS2V5Q2FjaGUiLCJyZWR1Y2VyS2V5cyIsImtleXMiLCJhcmd1bWVudE5hbWUiLCJ1bmV4cGVjdGVkS2V5cyIsImZpbHRlciIsImtleSIsImhhc093blByb3BlcnR5IiwiZm9yRWFjaCIsImFzc2VydFJlZHVjZXJTaGFwZSIsImluaXRpYWxTdGF0ZSIsImNvbWJpbmVSZWR1Y2VycyIsImZpbmFsUmVkdWNlcnMiLCJmaW5hbFJlZHVjZXJLZXlzIiwic2hhcGVBc3NlcnRpb25FcnJvciIsImNvbWJpbmF0aW9uIiwic3RhdGUiLCJ3YXJuaW5nTWVzc2FnZSIsImhhc0NoYW5nZWQiLCJuZXh0U3RhdGUiLCJfaSIsIl9rZXkiLCJwcmV2aW91c1N0YXRlRm9yS2V5IiwibmV4dFN0YXRlRm9yS2V5IiwiYWN0aW9uVHlwZSIsIlN0cmluZyIsImJpbmRBY3Rpb25DcmVhdG9yIiwiYWN0aW9uQ3JlYXRvciIsImFwcGx5IiwiYmluZEFjdGlvbkNyZWF0b3JzIiwiYWN0aW9uQ3JlYXRvcnMiLCJib3VuZEFjdGlvbkNyZWF0b3JzIiwiY29tcG9zZSIsIl9sZW4iLCJmdW5jcyIsImFyZyIsInJlZHVjZSIsImEiLCJiIiwiYXBwbHlNaWRkbGV3YXJlIiwibWlkZGxld2FyZXMiLCJzdG9yZSIsIl9kaXNwYXRjaCIsIm1pZGRsZXdhcmVBUEkiLCJjaGFpbiIsIm1hcCIsIm1pZGRsZXdhcmUiLCJfX0RPX05PVF9VU0VfX0FjdGlvblR5cGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/node_modules/redux/es/redux.js\n");

/***/ })

};
;